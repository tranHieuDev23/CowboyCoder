<!doctype html>
<html>

<head>
  <!-- Font Awesome -->
  <script src="https://use.fontawesome.com/d96de7908c.js"></script>
  <!-- Home Page Title -->
  <title>Cowboy Coder</title>
  <!-- Mobile first -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Bootstrap CSS -->
  <!-- Latest compiled and minified CSS -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Oswald" rel="stylesheet">

  <!-- Bootstrap Dropdown Hover CSS -->
  <link href="/css/animate.min.css" rel="stylesheet" type="text/css">
  <link href="/css/bootstrap-dropdownhover.min.css" rel="stylesheet" type="text/css">

  <!-- Stylesheet of the page -->
  <link rel="stylesheet" href="/css/stylesheet.css" type="text/css" />
  <link rel="stylesheet" href="/css/jumbotron.css" type="text/css" />
  <link rel="stylesheet" href="/css/navbar.css" type="text/css" />
  <link rel="stylesheet" href="/css/sidebar.css" type="text/css" />
  <link rel="stylesheet" href="/css/social-icon-button.css" type="text/css" />
  <link rel="stylesheet" href="/css/footer.css" type="text/css" />
  <link rel="stylesheet" href="/css/search.css" type="text/css" />
  <link rel="stylesheet" href="/css/navbar-hover-dropdown.css" type="text/css" />
  <link rel="stylesheet" href="/css/label.css" type="text/css" />
  <link rel="stylesheet" href="/css/post-preview.css" type="text/css" />
  <link rel="stylesheet" href="/css/post-preview-side.css" type="text/css" />

  <!-- Favicon -->
  <link rel="apple-touch-icon" sizes="57x57" href="/favicon/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/favicon/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/favicon/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/favicon/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/favicon/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/favicon/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/favicon/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/favicon/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/favicon/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/favicon/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
  <link rel="manifest" href="/favicon/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">

  <!-- Facebook meta tags -->
  <meta property="fb:app_id" content="155198375049942" />
</head>

<body>

  <!-- Facebook SDK -->
  <div id="fb-root"></div>
  <script>(function (d, s, id) {
      var js, fjs = d.getElementsByTagName(s)[0];
      if (d.getElementById(id)) return;
      js = d.createElement(s); js.id = id;
      js.src = 'https://connect.facebook.net/vi_VN/sdk.js#xfbml=1&version=v3.2&appId=500534520394032&autoLogAppEvents=1';
      fjs.parentNode.insertBefore(js, fjs);
    }(document, 'script', 'facebook-jssdk'));</script>

  <!-- Navbar -->
  <nav class="navbar navbar-default navbar-static-top">
    <div class="navbar-header">
      <a class="navbar-brand" href="https://cowboycoder.vercel.app">Cowboy Coder</a>
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>

    <div class="collapse navbar-collapse" id="myNavbar">
      <div class="container-fluid">

        <ul class="nav navbar-nav">

          <li class="dropdown">

            <a class="navbar-button dropdown-toggle" data-hover="dropdown" href="/categories/spoj"
              data-animations="none none none none">SPOJ</a>
          </li>

          <li class="dropdown">

            <a class="navbar-button dropdown-toggle" data-hover="dropdown" href="/categories/codeforces"
              data-animations="none none none none">Codeforces</a>
          </li>

          <li class="dropdown">

            <a class="navbar-button dropdown-toggle" data-hover="dropdown" href="/categories/article"
              data-animations="none none none none">Bài viết</a>
          </li>

          <li><a href="/tag">Tag</a></li>
          <li><a href="/about">About us</a></li>
        </ul>

      </div>
    </div>
  </nav>
  <!-- Navbar -->

  <!-- Jumbotron -->
  <div class="jumbotron">
    <div class="container">
      <h1>Cowboy Coder</h1>
      <h2>To code like a Cowboy!</h2>
    </div>
  </div>
  <!-- Jumbotron -->



  <div class="container">

    <!-- Content -->
    <div class="row">
      <div class="col-sm-8">
        <div class="seach-box">
          <form class="aside-form" action="/search" method="GET">
            <div class="input-group">
              <input type="text" class="form-control" id="search-box" placeholder="Tìm kiếm..." name="query" />
              <div class="input-group-btn">
                <button class="btn btn-default" type="submit" id="search-submit" />
                <i class="glyphicon glyphicon-search"></i>
                </button>
              </div>
            </div>
          </form>
        </div>

        <ul id="search-results"></ul>

        <script>
          window.store = [

            {
              title: "[SPOJ] CATGO - Cắt gỗ",
              author: "houtaru",
              category: ["spoj"],
              tag: ["spoj", "dp"],
              content: "Link đề bài: http://vnoi.info/problems/CATGO/Đề bài:Giới hạnThời gian: 0.1sBộ nhớ: 1536MBMã nguồn: 50000 bytesỞ một xưởng gỗ có rất nhiều đoạn gỗ thừa. Để đạt năng suất cao, người ta muốn tận dụng những thanh gỗ này. Tất nhiên giá trị của mỗi đoạn gỗ sẽ phụ thuộc vào độ dài của chúng. Tuy nhiên sự phụ thuộc này không đơn giản chỉ là sự phụ thuộc tuyến tính: các thanh gỗ càng dài càng có giá trị cao. Do đó, nếu cần thiết, người ta sẽ cắt các thanh gỗ này ra làm nhiều đoạn nhỏ hơn.Người ta có một máy cắt, mỗi lần có thể cắt một thanh gỗ ra làm hai thanh có độ dài ngắn hơn. Do lưỡi cưa sẽ mòn dần trong quá trình cắt, chi phí của mỗi lần cắt sẽ được tính như sau: lần đầu sẽ mất 1VNĐ, lần thứ 2 sẽ là 2VNĐ, lần thứ 3 sẽ là 3VNĐ,…Nhiệm vụ của bạn sẽ là tính lợi nhuận lớn nhất có thể thu được từ các đoạn gỗ thừa này.Dữ liệu  Dòng đầu ghi số N, số thanh gỗ thừa.  N dòng sau, mỗi dòng ghi một số nguyên dương là độ dài của một thanh gỗ.  Dòng tiếp theo ghi số M, số độ dài có giá trị.  M dòng tiếp theo, mỗi dòng ghi 2 số nguyên dương lần lượt là độ dài của một đoạn gỗ và giá trị thu được (tính bằng VNĐ) nếu ta có đoạn gỗ đó.Kết quảGhi ra một số duy nhất là lợi nhuận lớn nhất có được, đừng quên tính cả chi phí dùng để cắt gỗ.Giới hạn  1 ≤ N ≤ 50.  1 ≤ M ≤ 50.  Độ dài của một thanh gỗ không quá 50.  Giá trị thu được của một đoạn gỗ không quá 50.Ví dụDữ liệu23421 102 11Kết quả55Solution: http://brisktopia.com/9wDVCode: http://brisktopia.com/9w0r",
              url: "/spoj/spoj-catgo-cat-go"
            }
            ,

            {
              title: "[SPOJ] TRAKA - TRAKA",
              author: "houtaru",
              category: ["spoj"],
              tag: ["spoj", "shortest-path", "geometry"],
              content: "Link đề bài: http://vnoi.info/problems/show/TRAKA/Đề bài:Có N người thợ, M chiếc xe. Người thứ i hoàn thành việc sửa bộ phận xe mình phụ trách với tốc độ T[i]. Xe thứ j có độ rắc rối là F[j]. Thời gian người thứ i cửa xong bộ phận người i phụ trách trên xe j trong thời gian T[i] * F[j]. Các công việc được thực hiện theo thứ tự từ người 1 -&gt; n. Người i làm việc liên tục ko đc dừng lại(tức là sửa xong xe i thì đến xe i + 1). Với mỗi thời điểm t, mỗi chiếc xe chỉ được sửa bởi tối đa 1 người. Tính thời điểm bé nhất để n người sửa xong m chiếc xe.Dữ Liệu:  Dòng đầu gồm 2 số nguyên N (1 &lt;= N &lt;= 100 000) - số người thợ, M (1 &lt;= M &lt;= 100 000) - số chiếc xe cần sửa.  Dòng thứ i trong n dòng tiếp theo là T[i] - tốc độ sửa xong bộ phận người i phụ trách.  Dòng thứ j trong m dòng tiếp theo là F[j] - độ rắc rối của chiếc xe thứ j.Kết quả:  Gồm 1 dòng là kết quả của bài toán.Ví dụ:Input:3 3211211Output:11Solution: http://vializer.com/1MsRCode: http://vializer.com/1K5j",
              url: "/spoj/spoj-traka-traka"
            }
            ,

            {
              title: "[SPOJ] VOSNET - Social Network",
              author: "houtaru",
              category: ["spoj"],
              tag: ["spoj", "graph", "math"],
              content: "Link đề bài: http://vnoi.info/problems/show/VOSNET/Đề bài:Social Network - Một cụm từ chắc ai trong chúng ta đều biết! Một mạng xã hội sẽ gồm nhiều tài khoản (được biết như những người trong một xã hội) và các mối quan hệ giữa chúng (như sự quen biết giữa con người với con người).Chúng ta hãy cùng làm một “nghiên cứu” nho nhỏ về mạng xã hội. Mạng sẽ gồm N tài khoản (để đơn giản đặt tên từ 1 đến N) và M cặp quan hệ (U,V) cho biết U và V quen biết nhau.Theo dự đoán, cứ trung bình một tháng, một người sẽ quen hết tất cả những người có quen với bạn của người đó. Nói cách khác nếu:A quen với B, B quen với C;A không quen với CThì sau một tháng A sẽ quen với C, và một mối quan hệ mới (A,C) được tạo thành !Sẽ đến 1 tháng, mà sẽ không có mối quan hệ mới nào được tạo thành (và sự phát triển của mạng xã hội sẽ tạm dừng, nếu không kích thích tạo thêm tài khoản mới, quan hệ mới) - người ta gọi tháng đó là tháng bão hòa.Cứ sau mỗi tháng, người ta sẽ thống kê số mối quan hệ mới được tạo thành. Dựa vào dự đoán ở trên, bạn hãy tính toán những con số quan trọng cho đó đến khi tháng bão hòa bắt đầu.InputDòng đầu tiên gồm 2 số N và M;M dòng tiếp theo, mỗi dòng gồm cặp số biểu diễn quan hệ (U,V);OutputMột dòng duy nhất chứa 1 dãy số, số thứ i từ trái sang sẽ biểu diễn số mối quan hệ mới được tạo thành trong tháng thứ i (tất nhiên số cuối cùng sẽ là 0 - biểu diễn tháng bão hòa);ExampleInput:6 61 22 33 44 62 55 6Output:7 2 0Giải thích:Các mối quan hệ mới theo mỗi tháng:  (1,3), (1,5), (2,4), (2,6), (3,5), (3,6), (4,5);  (1,4), (1,6);  Không tạo mới;Giới hạnN ≤ 3000, M ≤ 6000;20% số dữ liệu có N ≤ 100;Solution: http://twineer.com/1IbACode: http://twineer.com/1I8v",
              url: "/spoj/spoj-vosnet-social-network"
            }
            ,

            {
              title: "[SPOJ] COMPUTER - Máy tính",
              author: "houtaru",
              category: ["spoj"],
              tag: ["spoj", "dp", "binary-search"],
              content: "Link đề bài : http://vnoi.info/problems/show/COMPUTER/Đề bài:Công ty phần mềm XYZ mới mua x máy tính để bàn và y máy tính xách tay. Giá một chiếc máy tính để bàn là a đôla còn giá một chiếc máy tính xách tay là b đôla. Để tránh sự thắc mắc giữa các phòng ban, Tổng giám đốc đã đưa ra cách phân bổ các máy tính này về n phòng ban như sau:Sắp xếp n phòng ban theo thứ tự về mức độ quan trọng của các phòng ban.Tiến hành phân bổ các máy tính cho các phòng ban bảo đảm nếu phòng ban i có mức độ quan trọng nhỏ hơn mức độ quan trọng của phòng ban j thì tổng giá trị máy tính được phân bổ cho phòng ban i không được vượt quá tổng giá trị máy tính được phân bổ cho phòng ban j.Phòng ban nhận được tổng giá trị máy tính nhỏ nhất là lớn nhất.Là một lập trình viên giỏi nhưng lại thuộc phòng ban có mức độ quan trọng nhỏ nhất, Khanh muốn chứng tỏ tay nghề của mình với đồng nghiệp nên đã lập trình tính ra ngay được tổng giá trị máy tính mà phòng ban mình nhận được rồi mời bạn tính lại thử xem!Yêu cầuCho x, a, y, b, n. Hãy tính tổng giá trị máy tính mà phòng Khanh nhận được.Dữ liệuGồm 2 bộ dữ liệu, mỗi bộ trên một dòng, mỗi dòng chứa 5 số nguyên dương x, a, y, b, n (các số có giá trị không vượt quá 1000).Kết quảGồm hai dòng là mỗi dòng là đáp án tương ứng với bộ dữ liệu vào.Giới hạn50% số test có x,a,y,b,n không vượt quá 100.Ví dụDữ liệu:3 300 2 500 24 300 3 500 2Kết quả:9001300Solution: http://yobuilder.com/8YjvCode: http://yobuilder.com/8YmM",
              url: "/spoj/spoj-computer-may-tinh"
            }
            ,

            {
              title: "[C++ Cơ bản] Phần 28: Áp dụng C++ vào lập trình thực tế (phần cuối)",
              author: "Admin Tổng Quản",
              category: ["article"],
              tag: ["cpp-cơ-bản", "programming"],
              content: "Phần trước: [C++ Cơ bản] Phần 27: Template. Thư viện template chuẩn của C++.Vậy là sau một chặng đường dài, chúng ta cuối cùng cũng đã đi đến cuối chặng đường học tập về ngôn ngữ C++ rồi, yeah :vSeries bài viết mới chỉ giới thiệu cho các bạn những kiến thức cơ bản về ngôn ngữ C++. Nhằm mục đích làm cho bài viết trở nên dễ hiểu hơn, mình đã lược bỏ đi nhiều chi tiết rườm rà, chỉ để lại những đề mục quan trọng nhất. Để có thể thật sự thành thục được ngôn ngữ C++, bạn không thể chỉ mong chờ đọc xong một hai bài viết, mà cần phải vươn xa hơn, tự tìm hiểu tìm tòi và áp dụng những kiến thức học được vào trong ứng dụng thực tế.Để kết thúc series C++ Cơ bản, bài viết này sẽ giới thiệu với các bạn một số môi trường lập trình sử dụng C++ mà các bạn có thể nhanh chóng tìm hiểu, để đưa những kiến thức ở trong series bài viết này vào thực tiễn.Microsoft Visual StudioVisual Studio là IDE do Microsoft phát triển, được sử dụng chủ yếu để phát triển các chương trình cho hệ điều hành Microsoft Windows. Ngoài ra IDE này còn hỗ trợ phát triển web app, website, các dịch vụ trên web và app dành cho các thiết bị di động. Visual Studio mặc định hỗ trợ các ngôn ngữ C, C++, C#, F#, VB.NET và TypeScript, nhưng có thể mở rộng ra để hỗ trợ nhiều ngôn ngữ và nền tảng hơn.Các bạn có thể tìm hiểu và download Visual Studio tại https://www.visualstudio.com/.QtQt (đọc giống như “cute”) là một framework cho phép tạo ra các ứng dụng chạy được trên nhiều nền tảng khác nhau, từ desktop, mobile tới các thiết bị IoT, mà không cần phải thực hiện nhiều thay đổi lên codebase. Qt có hai phiên bản, một phiên bản thương mại trả tiền và một phiên bản mã nguồn mở miễn phí. Các bạn có thể download phiên bản free tại https://info.qt.io/download-qt-for-application-development.Hướng dẫn sử dụng Qt bằng tiếng Việt có tại http://devnt.org/qt-tut-series-1/.Cocos2d-xBạn muốn làm game và hi vọng trở thành Nguyễn Hà Đông với Flappy Bird thứ hai? Cocos2d-x là một framework mã nguồn mở cho phép người dùng tạo ra các game và app có giao diện đồ họa trên nhiều nền tảng. Trên stdio.vn có một series bài viết hướng dẫn đầy đủ về Cococs2d-x, từ cài đặt tới lập trình, tất cả đều bằng tiếng Việt, các bạn có thể xem thêm tại https://www.stdio.vn/programs/content/2/games-va-cocos2d-x.Lập trình thi đấuC++ cũng là một ngôn ngữ được yêu thích trong cộng đồng lập trình thi đấu. Tham gia các kì thi lập trình, bạn sẽ có thêm nhiều hiểu biết về thuật toán, kinh nghiệm trong lập trình, và làm đẹp cho hồ sơ cá nhân về sau. Các cuộc thi lập trình cũng có nhiều giải thưởng hấp dẫn dành cho những người chiến thắng.Các bạn có thể tìm hiểu thêm về lập trình thi đấu trong series bài viết Lập trình thi đấu cơ bản trên trang Cowboy Coder.Đến đây là kết thúc series bài viết C++ Cơ bản rồi. Mình rất cảm ơn các bạn đã theo dõi các bài viết của mình tới ngày hôm nay, và với những kiến thức các bạn đã học được qua cuộc hành trình này, xin chúc các bạn có nhiều thành công lớn hơn trên con đường sắp tới :))",
              url: "/article/c-co-ban-phan-27-ap-dung-c-vao-lap-trinh-thuc-te-phan-cuoi"
            }
            ,

            {
              title: "[C++ Cơ bản] Phần 27: Template. Thư viện template chuẩn của C++.",
              author: "Admin Tổng Quản",
              category: ["article"],
              tag: ["cpp-cơ-bản", "programming"],
              content: "Phần trước: [C++ Cơ bản] Phần 26: Bài thực hành - Game đố vuiGiả sử ta muốn tạo ra một hàm lấy max của hai số nguyên, ta sẽ viết như sauint Max(int x, int y){    return (x &gt; y? x : y);}Cũng trong cùng một chương trình đó, ta muốn lấy max của hai string, ta sẽ phải viết thêm một hàm mớistring Max(string x, string y) // Overload{    return (x &gt; y? x : y);}Nếu như chỉ tới đây thôi thì không sao. Đằng này chương trình lại còn cần phải lấy max của hai giá trị kiểu char, rồi double, của giá trị kiểu class mà ta thiết kế ra… Chả lẽ lại viết lại hết tất cả các hàm có cùng một nội dung lặp đi lặp lại? Template ra đời nhằm mục giải quyết các vấn đề như vậy.Template và Generic programmingGeneric programming là khả năng cho phép lập trình viên có thể viết chương trình có khả năng thích nghi với nhiều kiểu dữ liệu, thay vì một kiểu dữ liệu cố định. Kiểu dữ liệu được sử dụng sẽ được cung cấp khi chương trình gọi tới hàm hoặc class cài đặt generic. Trong C++, ta có thể áp dụng generic thông qua từ khóa template (kiểu mẫu) và các tham số template. Tham số template là một kiểu tham số đặc biệt, có khả năng truyền kiểu dữ liệu/class vào để dùng trong hàm hoặc class generic.Để áp dụng generic, ta chèn thêm nội dung sau vào trước hàm hoặc class cần cài đặt:template &lt;/* danh sách tham số */&gt;Trong đó danh sách tham số được liệt kê giống như tham số của hàm, trừ một điểm: kiểu dữ liệu có thể được truyền vào làm tham số, nếu kiểu dữ liệu của tham số này là typename hoặc class. Hai từ khóa này có giá trị như nhau trong template, nên bạn có thể sử dụng cái nào cũng được.Sau khi khai báo tham số template, ta có thể sử dụng tên của các tham số trong hàm hoặc class mục tiêu.Ví dụ với hàm max ở trên, ta muốn áp dụng generic để có một hàm max đa năng với mọi kiểu dữ liệu. Ta sẽ làm như sau:template &lt;typename T&gt; T Max(T x, T y){    return (x &gt; y? x : y);}Về sau chỉ cần gọi hàm Max() với kiểu dữ liệu làm tham số template T, chương trình sẽ tự động thay T bằng kiểu dữ liệu được cung cấp trong ngoặc &lt;&gt;, và chạy chương trình bình thường.#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt; T Max(T x, T y){    return (x &gt; y? x : y);}int main(){    cout &lt;&lt; Max&lt;int&gt;(2, 3) &lt;&lt; ' ' &lt;&lt; Max&lt;string&gt;(\"abc\", \"adc\");    return 0;}Output3 adcVí dụ khi áp dụng với class: Một class với biến value được cung cấp kiểu dữ liệu về sau, thông qua template.#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt; class Container{    public:        T value;};int main(){    Container&lt;string&gt; stringContainer;    stringContainer.value = \"Hello world!\";    Container&lt;int&gt; intContainer;    intContainer.value = 100;    cout &lt;&lt; stringContainer.value &lt;&lt; ' ' &lt;&lt; intContainer.value;    return 0;}OutputHello world! 100Chú ý rằng trong trường hợp với hàm Max() ở trên, nếu như kiểu dữ liệu được cung cấp vào không hỗ trợ toán tử &gt; (ví dụ như một class không được overload toán tử này), hàm sẽ không thể hoạt động và chương trình sẽ báo lỗi khi dịch.Ngoài kiểu dữ liệu ra, ta có thể truyền thông tin khác vào template được không?Hoàn toàn có thể! Ta chỉ cần thay typename hoặc class bằng kiểu dữ liệu bình thường là được. Chú ý tham số được cung cấp vào phải hoàn toàn xác định vào thời điểm dịch chương trình (có thể là các giá trị được viết thẳng như 100, 'a', \"abc\", hoặc các biến được đánh dấu là hằng số bằng từ khóa const). Nếu không, chương trình sẽ báo lỗi khi dịch.Ví dụ áp dụng: Class sau sẽ có một mảng có kiểu dữ liệu và kích cỡ được cung cấp về sau qua template.template &lt;typename T, int size&gt; class Example{    public:        T arr[size];};Example&lt;int, 100&gt; a;Thư viện template chuẩn STL của C++Như các bạn đã thấy, template cho phép chúng ta tạo ra các đoạn code đa năng, sử dụng được với nhiều kiểu dữ liệu và trong nhiều trường hợp khác nhau. Bản thân ngôn ngữ C++ cũng cung cấp cho chúng ta hệ thống thư viện STL - Standard Template Library - với rất nhiều template hàm và cấu trúc dữ liệu mạnh mẽ, sẵn sàng đáp ứng các yêu cầu của dự án lập trình.STL rất rộng lớn, để có thể bao quát được hết các thư viện sẽ mất nhiều thời gian và đòi hỏi phải áp dụng nhiều trong thực tế để có thể thuần thục được. Các bạn có thể nghiên cứu thêm về hệ thống thư viện STL trong tài liệu C++ STL for newbies của tác giả Điêu Xuân Mạnh.Phần sau: [C++ Cơ bản] Phần 28: Áp dụng C++ vào lập trình thực tế (phần cuối)",
              url: "/article/c-co-ban-phan-27-template-thu-vien-template-chuan-cua-c"
            }
            ,

            {
              title: "[C++ Cơ bản] Phần 26: Bài thực hành - Game đố vui",
              author: "Admin Tổng Quản",
              category: ["article"],
              tag: ["cpp-cơ-bản", "programming"],
              content: "Phần trước: [C++ Cơ bản] Phần 25: Abstract class - Class trừu tượngChào mừng các bạn đến với chương trình Ai là Cốt đơ trên trang Cowboy Coder. Để có thể giành được giải thưởng 100 triệu cái hắt hơi của chương trình, các bạn sẽ phải trả lời một vài câu hỏi. Các câu hỏi sẽ có 3 dạng: Câu hỏi trắc nghiệm, Câu hỏi đúng sai và Câu hỏi nhập số. Nào, hãy cùng nhau bắt đầu chương trình!Yeah, chả ai quan tâm đâu.Nhưng nếu bây giờ bạn phải triển khai phần mềm cho chương trình trên, bạn sẽ làm như thế nào? Bài thực hành này sẽ giúp bạn tạo được một chương trình đố vui bằng C++, đồng thời cũng giúp bạn tổng quát lại các kết thức về Lập trình hướng đối tượng với C++.Yêu cầu của bài thực hànhKhi chương trình khởi động, ta sẽ chỉ định chương trình đọc file chứa câu hỏi. File chứa câu hỏi sẽ có nội dung như sau:  Dòng đầu tiên chứa một số n - số lượng câu hỏi.  Các nhóm dòng tiếp theo chứa nội dung các câu hỏi. Dòng đầu tiên là một chữ cái biểu diễn loại câu hỏi - M (Multiple Choice) là câu hỏi trắc nghiệm 4 đáp án, T (True/False) là câu hỏi đúng sai và N (Number) là câu hỏi nhập đáp án dạng số.  Đối với câu hỏi dạng M, 4 dòng tiếp theo chứa nội dung của 4 đáp án A, B, C, D. Sau 4 dòng này là một dòng thứ 5, chứa đáp án được viết dưới dạng chữ in hoa.  Đối với câu hỏi dạng T, dòng tiếp theo chứa đáp án T hoặc F (đúng hoặc sai).  Đối với câu hỏi dạng N, dòng tiếp theo chứa đáp án là một số thực.Sau khi đọc hết n câu hỏi, chương trình sẽ lần lượt hiện ra các câu hỏi đã đọc vào. Người dùng sẽ trả lời các câu hỏi bằng kí tự in hoa (đối với câu hỏi dạng M hoặc T), hoặc bằng số thực (nếu là câu hỏi dạng N). Chương trình sẽ thông báo người dùng có trả lời đúng hay không, và nếu trả lời sai, thì đáp án đúng là gì. Kết thúc chương trình, chương trình sẽ thông báo số lượng câu trả lời người dùng đã trả lời đúng.Để cho đơn giản, ta mặc định người dùng luôn luôn nhập vào đúng kiểu đáp án, để không phải mất công kiểm tra.Các bạn có thể download chương trình đã hoàn thiện ở đây, cùng với file câu hỏi mẫu ở đây.Interface QuestionChắc hẳn các bạn cũng đã có thể nghe nhạc hiệu đoán được chương trình rồi: Chúng ta sẽ sử dụng một interface Question chung cho 3 loại câu hỏi trên, để có thể chung đường xử lý cho cả 3 dạng câu hỏi.Một câu hỏi có 3 chức năng cần cài đặt: đọc vào nội dung câu hỏi từ file input, in ra nội dung câu hỏi, và nhận vào câu trả lời. Do đó interface Question sẽ cần phải cài đặt 3 hàm abstract readFromFile(), printQuestion() và getAnswer() tương ứng, để các subclass triển khai sau.  readFromFile() nhận một tham số truyền biến là một object thuộc class ifstream - luồng vào từ file cần nhập - và đọc nội dung câu hỏi vào object. Nhớ là tham số truyền biến, sử dụng toán tử &amp;, nếu không sẽ sinh lỗi khi dịch.  printQuestion() in ra nội dung câu hỏi theo mẫu có sẵn.  getAnswer() là một hàm kiểu bool, đợi người dùng nhập câu trả lời vào, in ra thông báo phù hợp và trả lại true nếu người dùng trả lời đúng, false nếu trả lời sai.class Question{    public:        virtual void readFromFile(ifstream &amp;fileInput) =0;        virtual void printQuestion() =0;        virtual bool getAnswer() =0;};Đừng quên thêm thư viện fstream vào để có thể sử dụng được ifstream nhé.Sau khi có interface Question rồi, ta có thể dễ dàng hình dung ra nội dung của hàm int main() ở dưới thành các bước sau:  Đọc file câu hỏi vào một mảng con trỏ interface Question  Mở file câu hỏi, sử dụng câu lệnh điều kiện để quyết định dùng loại class câu hỏi nào  Duyệt qua từng câu hỏi một, in ra nội dung, và nhận lại câu trả lời từ người dùng  In ra số lượng câu trả lời đúng, và kết thúc chương trìnhTạm thời ta sẽ bỏ trống phần đọc nội dung câu hỏi tới khi cài đặt xong class của 3 dạng câu hỏi về sau.char fileName[100];int n, correctAnswer = 0; /* correctAnswer là số lượng câu trả lời đúng */Question *allQuestion[1000];int main(){    cout &lt;&lt; \"Hay nhap file cau hoi: \";    cin &gt;&gt; fileName;    ifstream fileInput; fileInput.open(fileName);    fileInput &gt;&gt; n;    /* Đọc vào nội dung các câu hỏi */    for (int i = 1; i &lt;= n; i ++)    {        allQuestion[i]-&gt;PrintQuestion();        if (allQuestion[i]-&gt;GetAnswer())            correctAnswer ++;    }    cout &lt;&lt; \"So luong cau tra loi dung: \" &lt;&lt; correctAnswer;    return 0;}Class MultipleQuestion - câu hỏi trắc nghiệmDạng câu hỏi đầu tiên ta triển khai sẽ là câu hỏi trắc nghiệm - class MultipleQuestion. Trước khi làm bất cứ thao tác gì, đừng quên tuyên bố class này là subclass của interface Question.class MultipleQuestion: public QuestionCâu hỏi trắc nghiệm thì cần có 1 nội dung lớn, 4 lựa chon và 1 đáp án đúng. Ta sẽ lưu trữ chúng trong các object string là question (câu hỏi), mảng string choice[] (lựa chọn) và biến char correctAnswer (đáp án đúng). Chẳng có lý do gì mà ta muốn công khai các nội dung này ra cả, nên ta sẽ để chúng là private.class MultipleQuestion: public Question{    private:        string question, choice[4];        char correctAnswer;Giờ tới lúc triển khai việc đọc. Nội dung câu hỏi và các đáp án chiếm trọn một dòng và bao gồm cả dấu cách. Ta cần cách đọc hết cả một dòng mà không bỏ qua dấu cách. Còn nhớ hàm getline() ở bài thực hành trước chứ?    public:        void readFromFile(ifstream &amp;fileInput)        {            getline(fileInput, question);            for (int i = 0; i &lt; 4; i ++)                getline(fileInput, choice[i]);            fileInput &gt;&gt; correctAnswer;        }Việc đọc câu hỏi vào rất đơn giản, việc in nội dung ra cũng vậy. Chỉ có một điều khác biệt, đó là ta cần in ra các chữ cái đại diện cho đáp án. Trong bảng mã ASCII mà C++ sử dụng, các chữ cái A, B, C, D được đặt liền nhau. Do đó ta sẽ cộng biến đếm vào giá trị của kí tự 'A', để trả lại chữ cái in ra phù hợp - biến label.void printQuestion(){    cout &lt;&lt; question &lt;&lt; '\\n';    for (int i = 0; i &lt; 4; i ++)    {        char label = 'A' + i;        cout &lt;&lt; label &lt;&lt; \": \" &lt;&lt; choice[i] &lt;&lt; '\\n';    }}Cuối cùng là việc đọc đáp án. Công việc này cũng rất đơn giản - chỉ cần cin đáp án vào một biến dạng char, và kiểm tra xem đáp án có bằng với correctAnswer hay không để in ra thông báo phù hợp.bool getAnswer(){    char answer; cin &gt;&gt; answer;    if (answer == correctAnswer)    {        cout &lt;&lt; \"Cau tra loi dung!\\n\";        return true;    }    else    {        cout &lt;&lt; \"Cau tra loi sai! Cau tra loi dung la \" &lt;&lt; correctAnswer &lt;&lt; '\\n';        return false;    }}Nội dung hoàn chỉnh của class MultipleQuestion sẽ là như sauclass MultipleQuestion: public Question{    private:        string question, choice[4];        char correctAnswer;    public:        void readFromFile(ifstream &amp;fileInput)        {            getline(fileInput, question);            for (int i = 0; i &lt; 4; i ++)                getline(fileInput, choice[i]);            fileInput &gt;&gt; correctAnswer;        }        void printQuestion()        {            cout &lt;&lt; question &lt;&lt; '\\n';            for (int i = 0; i &lt; 4; i ++)            {                char label = 'A' + i;                cout &lt;&lt; label &lt;&lt; \": \" &lt;&lt; choice[i] &lt;&lt; '\\n';            }        }        bool getAnswer()        {            char answer; cin &gt;&gt; answer;            if (answer == correctAnswer)            {                cout &lt;&lt; \"Cau tra loi dung!\\n\";                return true;            }            else            {                cout &lt;&lt; \"Cau tra loi sai! Cau tra loi dung la \" &lt;&lt; correctAnswer &lt;&lt; '\\n';                return false;            }        }};Class TrueFalse (câu hỏi đúng sai) và class NumberQuestion (câu hỏi dạng số)Dạng câu hỏi đúng sai giống hệt như dạng câu hỏi MultipleQuestion, nhưng chỉ khác là từ 4 lựa chọn ta chỉ có 2 (T hoặc F). Do đó cách triển khai cũng chỉ khác ở việc đọc nội dung vào và ở cách nội dung được in ra mà thôi.class TrueFalse: public Question{    private:        string question;        char correctAnswer;    public:        void readFromFile(ifstream &amp;fileInput)        {            getline(fileInput, question);            fileInput &gt;&gt; correctAnswer;        }        void printQuestion()        {            cout &lt;&lt; question &lt;&lt; \" (T/F)\\n\";        }                bool getAnswer()        {            char answer; cin &gt;&gt; answer;            if (answer == correctAnswer)            {                cout &lt;&lt; \"Cau tra loi dung!\\n\";                return true;            }            else            {                cout &lt;&lt; \"Cau tra loi sai! Cau tra loi dung la \" &lt;&lt; correctAnswer &lt;&lt; '\\n';                return false;            }        }};Class NumberQuestion thì giống hệt class TrueFalse, nhưng chỉ khác là phải chuyển correctAnswer từ một kí tự thành một số thôi. Ta chỉ cần copy lại class này, đổi tên class và đổi kiểu dữ liệu của correctAnswer thành double, thế là xong.class NumberQuestion: public Question{    private:        string question;        double correctAnswer;    public:        void readFromFile(ifstream &amp;fileInput)        {            getline(fileInput, question);            fileInput &gt;&gt; correctAnswer;        }        void printQuestion()        {            cout &lt;&lt; question &lt;&lt; \" (T/F)\\n\";        }        bool getAnswer()        {            double answer; cin &gt;&gt; answer;            if (answer == correctAnswer)            {                cout &lt;&lt; \"Cau tra loi dung!\\n\";                return true;            }            else            {                cout &lt;&lt; \"Cau tra loi sai! Cau tra loi dung la \" &lt;&lt; correctAnswer &lt;&lt; '\\n';                return false;            }        }};Áp dụng 3 dạng câu hỏi vào chương trìnhSau khi cài đặt xong 3 dạng câu hỏi, ta chỉ còn một chi tiết cuối, đó là đọc nội dung của chúng từ file. Ta sẽ sử dụng câu lệnh điều kiện if cho việc này - nếu như biến dạng char type (loại, tức loại của câu hỏi) đọc vào có giá trị là 'M', câu hỏi sẽ là câu hỏi trắc nghiệm và con trỏ tương ứng phải chỉ vào một đối tượng class MultipleQuestion. Tương tự với hai dạng kia.int main(){    cout &lt;&lt; \"Hay nhap file cau hoi: \";    cin &gt;&gt; fileName;    ifstream fileInput; fileInput.open(fileName);    fileInput &gt;&gt; n;    for (int i = 1; i &lt;= n; i ++)    {        char questionType;        fileInput &gt;&gt; questionType;        string temp; getline(fileInput, temp); /* Dọn dẹp phần còn lại của dòng để xuống dòng */        if (questionType == 'M')            allQuestion[i] = new MultipleQuestion;        if (questionType == 'T')            allQuestion[i] = new TrueFalse;        if (questionType == 'N')            allQuestion[i] = new NumberQuestion;Cuối cùng là việc đọc nội dung câu hỏi vào đối tượng.        allQuestion[i]-&gt;readFromFile(fileInput);    }Vậy là chương trình của chúng ta đã xong rồi! Các bạn có thể xem lại code của chương trình tại đây.Bình luậnOOP thật sự rất tiện lợi cho việc lắp đặt và nâng cấp - với interface Question đã được định nghĩa sẵn, ta có thể thêm vào chương trình bất cứ loại câu hỏi nào mà ta có thể nghĩ ra, với điều kiện phải overload lại 3 hàm abstract cần thiết. Giả sử ta có một class phụ trách việc hiển thị câu hỏi lên giao diện đồ họa, ta cũng có thể điều chỉnh chương trình này lại sao cho phù hợp với cấu trúc của class kia, và lắp đặt lại thành một trò chơi câu hỏi đẹp mắt.Bài thực hành này kết thúc phần học về lập trình hướng đối tượng với C++. Bài viết tiếp theo sẽ giúp các bạn làm quen với STL - thư viện template của C++ và các class quan trọng trong thư viện này.Phần sau: [C++ Cơ bản] Phần 27: Template. Thư viện template chuẩn của C++.",
              url: "/article/c-co-ban-phan-26-bai-thuc-hanh-game-do-vui"
            }
            ,

            {
              title: "[C++ Cơ bản] Phần 25: Abstract class - Class trừu tượng",
              author: "Admin Tổng Quản",
              category: ["article"],
              tag: ["cpp-cơ-bản", "programming"],
              content: "Phần trước: [C++ Cơ bản] Phần 24: Overload - Viết đè chương trình con và toán tửỞ trong các bài viết trước về tính thừa kế và overload, chúng ta có nói đến ví dụ về class Shape và Rectangle. Class Shape có một chương trình con là printArea(), cho phép chương trình in ra diện tích của hình đang được biểu diễn bởi object. Tuy nhiên chi tiết hình được biểu diễn như thế nào, phải tới subclass Rectangle mới có. Nếu ta gọi printArea() ở Shape, ta chỉ in ra kết quả là No data.class Shape{    public:        virtual void printArea()        {            cout &lt;&lt; \"No data\\n\";        }};class Rectangle: public Shape{    private:        double width, height;    public:        Rectangle(double _width, double _height)        {            width = _width;            height = _height;        }        void printArea()        {            cout &lt;&lt; width * height &lt;&lt; '\\n';        }};Giờ chúng ta muốn thiết kế lại class Shape như sau: Đằng nào thì cũng không biết hình được biểu diễn như thế nào rồi, ta không cho class Shape có chương trình con printArea() nữa. Tất cả các subclass của Shape phải được thừa kế và phải overload lại printArea() (vì bây giờ chúng có biểu diễn hình cụ thể rồi). Để có thể làm được như vậy, chúng ta sử dụng abstract class - class trừu tượng.Nhắc lại về tính trừu tượng - abstraction của OOPỞ trong bài viết giới thiệu về OOP, chúng ta biết rằng abstraction là tính chất cho phép các hàm và chương trình con của chương trình có thể được gọi mà không cần quan tâm về mặt cài đặt ở phía sau. Tính chất này được biểu diễn qua hai điều sau:  Thứ nhất, việc ta có thể cài đặt quyền truy cập của các yếu tố trong class, giúp ta có thể công khai các yếu tố mặt tiền của object mà vẫn giấu đi các chi tiết cài đặt ở sau. Ví dụ như ở class string, ta có thể gọi hàm substr() để lấy một string con của string, mà không cần quan tâm hàm này cài đặt ra sao.  Thứ hai, việc ta có thể chỉ định một hàm/chương trình con ở superclass là abstract (trừu tượng) - không có thông tin về nội dung thực hiện - và bắt buộc các subclass phải overload lại hàm này để có nội dung cụ thể. Khi ta tạo một object thuộc subclass, overload các hàm abstract của superclass, và gọi hàm đã được overload thông qua superclass (ví dụ như khi ta gán con trỏ object này cho một con trỏ object superclass), hàm đã được overload ở subclass sẽ được gọi.Bài viết này sẽ xoay quanh yếu tố thứ hai.Abstract function (hàm trừu tượng)Để tuyên bố một hàm trong class là abstract, ta thêm =0 vào sau định nghĩa của hàm đó, và bỏ qua phần nội dung cài đặt. Chú ý là hàm đó phải có thể overload được (sử dụng từ khóa virtual) và có dấu chấm phẩy ở cuối định nghĩa.virtual kiểu_dữ_liệu_trả_lại tên_hàm(các tham số) =0;Ví dụ: Để định nghĩa chương trình con printArea() trong class Shape là abstract:class Shape{    public:        virtual void printArea() =0;};Một class có hàm abstract được gọi là một interface (giao diện), trong khi class không có hàm abstract (tất cả đều được định nghĩa) được gọi là concrete class (class cụ thể). Ta không thể tạo ra một object thuộc vào class interface được, nhưng ta có thể tạo ra subclass của chúng.Subclass của interface hoặc phải overload lại tất cả các hàm abstract, hoặc các hàm không được overload sẽ được coi là abstract, và subclass mới sẽ trở thành một interface khác. Nếu như subclass là concrete class, ta có thể tạo ra các object mới thuộc về subclass đó.class Shape{    public:        virtual void printArea() =0;};class Rectangle: public Shape{    private:        double width, height;    public:        Rectangle(double _width, double _height)        {            width = _width;            height = _height;        }        void printArea()        {            cout &lt;&lt; width * height &lt;&lt; '\\n';        }};Rectangle rec = Rectangle(2, 3);Các con trỏ của interface, chỉ tới các đối tượng có superclass là interface, cũng có thể được tạo ra và truy cập vào.Shape *objectPointer;Ví dụ thực hành: Ta có class Shape và Rectangle như ở trên, ngoài ra ta còn cài đặt thêm hai class nữa là Circle (hình tròn) và Triangle (hình tam giác). Circle có một biến double radius (bán kính) và diện tích của Circle sẽ được tính bằng radius * radius * 3.14. Triangle có ba biến a, b, c, đại diện cho 3 cạnh của tam giác, và diện tích sẽ tính bằng công thức Heron.Sau khi cài đặt hai class trên, ta sẽ tạo ra một mảng con trỏ allShape[], để truy cập tới các đối tượng Rectangle, Circle và Triangle, và chạy hàm printArea() của chúng.#include &lt;iostream&gt;#include &lt;cmath&gt; /* Để sử dụng hàm tính căn sqrt() */using namespace std;class Shape{    public:        virtual void printArea() =0;};class Rectangle: public Shape{    private:        double width, height;    public:        Rectangle(double _width, double _height) /* Constructor */        {            width = _width;            height = _height;        }        void printArea()        {            cout &lt;&lt; width * height &lt;&lt; '\\n';        }};class Circle: public Shape{    private:        double radius;    public:        Circle(double _radius) /* Constructor */        {            radius = _radius;        }        void printArea()        {            cout &lt;&lt; radius * radius * 3.14 &lt;&lt; '\\n';        }};class Triangle: public Shape{    private:        double a, b, c;    public:        Triangle(double _a, double _b, double _c) /* Constructor */        {            a = _a; b = _b; c = _c;        }        void printArea()        {            double p = (a + b + c) / 2;            cout &lt;&lt; sqrt(p * (p - a) * (p - b) * (p - c)) &lt;&lt; '\\n'; /* Công thức Heron */        }};Shape *allShape[] = {    new Rectangle(3, 4),    new Circle(1),    new Triangle(3, 4, 5)};int n = 3; /* Số lượng phần tử trong mảng */int main(){    for (int i = 0; i &lt; n; i ++)        allShape[i]-&gt;printArea();    return 0;}Output123.146Tại sao phải sử dụng abstract function và interface?Lý do thứ nhất là vì với interface, ta có thể bắt buộc các subclass của interface phải cài đặt gì, đảm bảo tính đồng bộ. Giả sử bạn tạo ra một cái TV có cổng video, mà bạn không quy định cổng video đó hoạt động như thế nào, các nhà sản xuất đầu kĩ thuật số sẽ mỗi người một nẻo, cuối cùng một cái TV mà có hàng trăm kiểu đầu vào khác nhau, thế là không được. Trong lập trình cũng như vậy.Lý do thứ hai là interface cho ta khả năng nâng cấp và mở rộng - không cần biết class của anh cài đặt như thế nào, miễn class của anh thừa hưởng cái interface như thế này, thì class của anh có thể lắp vào hoạt động với class của tôi - giống như với đầu vào video của TV vậy.Lý do thứ ba là với interface, ta có thể gom chung các đối tượng cùng thừa hưởng interface với nhau (ví dụ như các hình học trong ví dụ trên đã được gom chung vào một mảng con trỏ allShape[]) để xử lý chung.Tới đây là kết thúc phần lập trình hướng đối tượng với C++ rồi. Bài viết tiếp theo sẽ là một bài thực hành, để các bạn có thể tổng hợp lại tất cả kiến thực hướng đối tượng với C++.Phần sau: [C++ Cơ bản] Phần 26: Bài thực hành - Game đố vui",
              url: "/article/c-co-ban-phan-25-abstract-class-class-truu-tuong"
            }
            ,

            {
              title: "[C++ Cơ bản] Phần 24: Overload - Viết đè chương trình con và toán tử",
              author: "Admin Tổng Quản",
              category: ["article"],
              tag: ["cpp-cơ-bản", "programming"],
              content: "Phần trước: [C++ Cơ bản] Phần 23: Tính thừa kế - Class con (subclass)Chúng ta đều biết hai kiểu dữ liệu số nguyên int và long long int đều có giới hạn về khoảng biểu diễn. Sẽ xảy ra trường hợp ta cần phải tự triển khai một kiểu dữ liệu số riêng để vượt qua các giới hạn ấy. Ý tưởng là tạo một class biểu diễn số bằng một string các kí tự chữ số. Vậy làm thế nào để có thể viết toán tử cộng trừ nhân chia cho class mới này?Trong bài viết này chúng ta sẽ học về overload - khả năng viết đè các chương trình con và toán tử đã định nghĩa từ trước.Overload chương trình con trong chương trình C++C++ cho phép chúng ta có nhiều chương trình con có cùng tên với nhau, với điều kiện là các biến tham số của mỗi một cá thể phải khác nhau - có thể khác nhau về số lượng hoặc về kiểu dữ liệu của tham số.Ví dụ:#include &lt;iostream&gt;using namespace std;void print(int x){    cout &lt;&lt; \"Int: \" &lt;&lt; x &lt;&lt; '\\n';}void print(double x){    cout &lt;&lt; \"Double: \" &lt;&lt; x &lt;&lt; '\\n';}void print(string x){    cout &lt;&lt; \"String: \" &lt;&lt; x &lt;&lt; '\\n';}int main(){    print(1);    print(3.14);    print(\"Hello world!\");    return 0;}OutputInt: 1Double: 3.14String: Hello world!Bộ dịch C++ sẽ tự động quyết định cá thể nào của chương trình con sẽ được chạy, dựa vào kiểu dữ liệu của tham số được cung cấp.Overload chương trình con của class chaGiả sử chúng ta có hai class Shape (hình nói chung) và Rectangle (hình chữ nhật), trong đó Rectangle là subclass của Shape. Hai class này đều có một hàm printArea() để in diện tích của hình.Đối với class Shape, do không có thông số cụ thể để định nghĩa hình, nên ta sẽ in ra dòng chữ \"No data\" rồi xuống dòng.Đối với class Rectangle, ta có hai biến private kiểu double width và height - chiều rộng và chiều dài của hình chữ nhật. Khi gọi hàm printArea() ta sẽ in ra diện tích của hình chữ nhật bằng width * height.Ta triển khai chương trình như sau:#include &lt;iostream&gt;using namespace std;class Shape{    public:        void printArea()        {            cout &lt;&lt; \"No data\\n\";        }};class Rectangle: public Shape{    private:        double width, height;    public:        Rectangle(double _width, double _height)        {            width = _width;            height = _height;        }        void printArea()        {            cout &lt;&lt; width * height &lt;&lt; '\\n';        }};int main(){    Shape* rec = new Rectangle(2, 3);    rec -&gt; printArea();    return 0;}OutputNo dataHãy quan sát con trỏ object rec ở dưới - không ổn lắm nhỉ. Đúng đây là một object thuộc class Shape rồi, nhưng đây cũng là một object dạng Rectangle. Khi ra lệnh chạy hàm printArea() mà in ra No data thì không được, ta muốn nó phải in ra như của class Rectangle cơ.Giải pháp là overload hàm printArea() của class Shape. Để quy định một hàm trong class là hàm có thể overload được ở subclass, ta sử dụng từ khóa virtual. Khi ta gọi một hàm từ con trỏ hoặc tham chiếu của một object, chương trình C++ sẽ xem xét class gốc của con trỏ hoặc tham chiếu là gì, và quyết định sử dụng hàm nào để chạy.Chỉ cần thêm từ khóa vào trước void printArea() của class Shapevirtual void printArea()Rồi chạy chương trình. Output sẽ ra 6 - kết quả của việc chạy hàm printArea() trên class Rectangle.Đây chính là cách polymorphism - tính đa hình của OOP - được biểu diễn trong C++.Chú ý là tính chất này chỉ xảy ra khi chạy hàm thông qua con trỏ hoặc tham chiếu - một khi đã gán vào một object thuộc superclass, object đó trở thành một object hoàn toàn độc lập, thuộc hẳn về superclass, nên sẽ chạy hàm gốc chứ không chạy hàm overload.Overload toán tửTa cũng có thể định nghĩa lại hoặc định nghĩa mới phần lớn các toán tử trong C++, để áp dụng vào các class ta tạo ra. Để overload toán tử ta sử dụng từ khóa operator.Lấy ví dụ với class BigInt như ở đầu bài viết yêu cầu. Có hai phương pháp overload operator.  Overload bên trong class. Khi đó ta chỉ cần cung cấp giá trị bên phải toán tử làm tham số.class BigInteger{    BigInteger operator + (BigInteger x)    {        return x;    }};Overload bên ngoài class, như một hàm của chương trình lớn. Khi đó ta cần cung cấp giá trị hai bên toán tử.class BigInteger{    //nội dung;};BigInteger operator + (BigInteger x, BigInteger y){    //nội dung;}Hãy để ý rằng các phép toán tử này cũng có kiểu dữ liệu trả về, giống như một chương trình con bình thường vậy - thực chất chúng cũng là chương trình con, nhưng được gọi bằng các toán tử thay vì bằng tên.Ta có thể overload tất cả các toán tử trong C++, trừ toán tử truy cập scope ::, toán tử truy cập yếu tố trong class ., toán tử điều kiện ?: và toán tử tham chiếu yếu tố của class .* (mà bạn chưa cần phải quan tâm ở đây).Subclass sẽ không được thừa hưởng các toán tử được overload của superclass.Phần sau: [C++ Cơ bản] Phần 25: Abstract class - Class trừu tượng",
              url: "/article/c-co-ban-phan-24-overload-viet-de-chuong-trinh-con-va-toan-tu"
            }
            ,

            {
              title: "[C++ Cơ bản] Phần 23: Tính thừa kế - Class con (subclass)",
              author: "Admin Tổng Quản",
              category: ["article"],
              tag: ["cpp-cơ-bản", "programming"],
              content: "Phần trước: [C++ Cơ bản] Phần 22: Class và ObjectTính thừa kết giúp chúng ta tiết kiệm công sức viết code, bằng cách để cho các class con (subclass) thừa hưởng các tính chất của class cha (superclass). Trong bài viết này chúng ta sẽ tìm hiểu về cách triển khai tính thừa kế trong C++.Định nghĩa subclassĐể định nghĩa subclass, ta sử dụng cú phápclass tên_class: kiểu_thừa_kế_1 tên_superclass_1, kiểu_thừa_kế_2 tên superclass_2,…{    nội dung;}Trong đó kiểu thừa kế có thể là public, protected, hoặc private.Ví dụ: Chương trình sau có 2 class Animal và Cat, trong đó Cat là subclass của Animal, do đó Cat thừa hưởng hai biến type và area của Animal.#include &lt;iostream&gt;using namespace std;class Animal{    protected:        string type, area;};class Cat: public Animal{    private:        string name;        int age;    public:        string getType()        {            return type;        }        void setType(string _type)        {            type = _type;        }};int main(){    Cat cat;    cat.setType(\"Cat\");    cout &lt;&lt; cat.getType();    return 0;}OutputCatSau khi định nghĩa subclass xong, ta lại có thể tiếp tục định nghĩa subclass của nó nữa. Ví dụ như class MeoTamThe sau đây là subclass của Cat.class MeoTamThe: public Cat{    public:        string color[3];};Một object khi thuộc về một class thì cũng sẽ thuộc về tất cả các superclass của class đó. Để dễ hình dung thì “Nếu đây là một con mèo, thì đây cũng là một con động vật”.Animal cat = Cat();Quyền truy cậpSubclass có quyền truy cập tới tất cả các yếu tố public và protected của superclass.Quyền thừa kếQuyền truy cập của các yếu tố mà subclass được thừa kế sẽ phụ thuộc vào kiểu thừa kế của subclass đối với superclass.  Nếu kiểu thừa kế là public, tất cả các yếu tố public và protected của superclass sẽ giữ nguyên quyền truy cập khi thừa kế xuống subclass.  Nếu kiểu thừa kế là protected, tất cả các yếu tố public và protected của superclass sẽ trở thành protected của subclass.  Nếu kiểu thừa kế là private, tất cả các yếu tố public và protected của superclass sẽ trở thành private của subclass.Kiểu thừa kế giống như là việc co gọn quyền truy cập khi xuống tới subclass vậy.Subclass sẽ không được thừa hưởng các yếu tố sau:  constructor, destructor và copy constructor của superclass.  Các toán tử đã bị viết đè (overload) ở class cha. Ta sẽ nghiên cứu thêm về overload trong bài viết tiếp theo.Thừa kế từ nhiều classMột class trong C++ có thể được thừa kế từ nhiều superclass, chỉ cần liệt kê danh sách các class thừa kế ở trong định nghĩa của nó.Ví dụ ở trong chương trình sau, class MyClass được thừa kế từ hai class SuperClassOne và SuperClassTwo, nên có thể sử dụng được hai biến intOne và intTwo.#include &lt;iostream&gt;using namespace std;class SuperClassOne{    protected:        int intOne;};class SuperClassTwo{    protected:        int intTwo;};class MyClass: public SuperClassOne, public SuperClassTwo{    public:        MyClass(int _intOne, int _intTwo)        {            intOne = _intOne;            intTwo = _intTwo;        }        int getSum()        {            return intOne + intTwo;        }};int main(){    MyClass myObject = MyClass(1, 1);    cout &lt;&lt; myObject.getSum();    return 0;}Output2Phần sau: [C++ Cơ bản] Phần 24: Overload - Viết đè chương trình con và toán tử",
              url: "/article/c-co-ban-phan-23-tinh-thua-ke-class-con-subclass"
            }
            ,

            {
              title: "[C++ Cơ bản] Phần 22: Class và Object",
              author: "Admin Tổng Quản",
              category: ["article"],
              tag: ["cpp-cơ-bản", "programming"],
              content: "Phần trước: [C++ Cơ bản] Phần 21: Lập trình hướng đối tượng - Object Oriented ProgrammingỞ phần trước chúng ta đã đề cập tới định nghĩa và các tính chất của Lập trình Hướng đối tượng (OOP). Trong phần này chúng ta sẽ bắt đầu ứng dụng những lí thuyết ấy vào thực hành với C++.Định nghĩa classHãy đọc lại bài Cấu trúc dữ liệu - struct và class. Cài đặt class cũng gần giống như struct, ta sử dụng cú pháp sau:class tên_class {    khai báo các biến, hàm của đối tượng thuộc class;} [khai báo đối tượng thuộc class, không bắt buộc];Ví dụclass Cat{    string type;    int age;    void increaseAge()    {        age ++;    }};Vậy có gì khác biệt giữa struct và class? Có 2 sự khác biệt ở đây  Về mặt ngữ nghĩa, struct thường được sử dụng để định nghĩa các kiểu dữ liệu Plain-Old-Data (dữ liệu không, không bao gồm các chương trình con hay các yếu tố đóng gói). class thường được sử dụng trong lập trình OOP đầy đủ.  Quyền truy cập mặc định tới các yếu tố trong struct là public, còn với class là private.struct có thể chỉnh sửa được thành class và ngược lại, và có thể sử dụng được các yếu tố của OOP như nhau. Để thống nhất, từ nay trở đi ta sẽ chỉ sử dụng class.Sau khi định nghĩa class xong, ta có thể định nghĩa các object như các biến thông thường.Cat cat1, cat2, cat3;Ta cũng truy cập các yếu tố public của object bằng toán tử dấu chấm ..Quyền truy cậpỞ trên ta có nhắc tới quyền truy cập. Đối với các yếu tố trong class, quyền truy cập mặc định là private - các yếu tố trong class chỉ có thể được truy cập từ nội bộ bên trong class, và từ bên ngoài không thể gọi vào.Ngoài private ra, còn có 2 kiểu quyền truy cập khác:  public: Yếu tố public có thể được truy cập từ bên ngoài đối tượng.  protected: Yếu tố protected không thể được truy cập từ bên ngoài đối tượng, nhưng có thể truy cập được từ các đối tượng thuộc class con của class hiện tại. Class con và sự thừa kế sẽ được đề cập kĩ hơn trong các bài viết sau.Để có thể thiết lập quyền truy cập cho đối tượng, ta sử dụng các từ khóa private, public và protected đi kèm cùng dấu hai chấm :. Các yếu tố tiếp theo sau từ khóa sẽ được áp dụng quyền truy cập tương ứng, cho tới khi có một từ khóa mới xuất hiện.class Cat{    private:        void privateVoid()        {        }    public:        void publicVoid()        {        }    protected:        void protectedVoid()        {        }};Trong class ví dụ ở trên, void privateVoid() chỉ có thể được gọi từ bên trong đối tượng thuộc vào class Cat, void publicVoid() có thể gọi được từ bất kì đâu, còn void protectedVoid() chỉ có thể gọi từ bên trong đối tượng thuộc class Cat, hoặc các đối tượng thuộc vào class con của Cat.Đây chính là encapsulation - tính đóng gói của lập trình hướng đối tượng. Với cách đặt quyền truy cập cho các yếu tố trong class, ta có thể giới hạn sử dụng của class tới những chức năng cần thiết đối với bên ngoài.Hàm khởi tạo (constructor) và hàm phá hủy (destructor)Tương tự đối với struct, ta cũng có thể viết hàm khởi tạo để khởi tạo các yếu tố của object thuộc class. Ví dụ:#include &lt;iostream&gt;using namespace std;class Cat{    public:        string name;        int age;        Cat(string _name, int _age)        {            name = _name;            age = _age;        }};int main(){    Cat cat = Cat(\"Tom\", 3);    cout &lt;&lt; cat.name &lt;&lt; ' ' &lt;&lt; cat.age;    return 0;}OutputTom 3Hàm phá hủy (destructor) là một loại chương trình con đặc biệt khác, được gọi ra khi object bị phá hủy (ví dụ: khi chương trình kết thúc và bộ nhớ được giải phóng). Hàm phá hủy được định nghĩa theo cú pháp~tên_class(){    nội dung;}Ví dụ như khi áp dụng vào class Cat ở trên:#include &lt;iostream&gt;using namespace std;class Cat{    public:        string name;        int age;        Cat(string _name, int _age)        {            name = _name;            age = _age;        }        ~Cat()        {            cout &lt;&lt; \"Object dang bi pha huy!\";        }};int main(){    Cat cat = Cat(\"Tom\", 3);    cout &lt;&lt; cat.name &lt;&lt; ' ' &lt;&lt; cat.age &lt;&lt; '\\n';    return 0;}OutputTom 3Object dang bi pha huy!Ta có thể sử dụng destructor để dọn dẹp dữ liệu sau khi đối tượng bị phá hủy, lưu trữ thông tin quan trọng, vân vân…Hàm gán (copy constructor)Copy constructor là một loại hàm khởi tạo đặc biệt - nó được gọi ra khi một object của class được gán giá trị bằng một object khác (ví dụ như khi gán bằng nhau, khi đặt giá trị cho tham số của hàm, vân vân). Khi đó ta có thể sử dụng copy constuctor để can thiệp vào quá trình gán đó.Một class thường không bắt buộc phải có copy constructor - trình dịch sẽ tự động xử lý việc gán nếu như không có, tuy nhiên các class có biến kiểu con trỏ và có khả năng cấp phát bộ nhớ động thì bắt buộc phải có copy constructor.Cú pháp của copy constructor làtên_class(const tên_class&amp; đối_tượng){    nội dung;}const là từ khóa hằng số - nó mang ý nghĩa rằng biến được khai báo sau nó là hằng số và sẽ không bao giờ bị thay đổi. Chú ý kiểu dữ liệu ở đây là truyền tham biến (toán tử &amp;).Ví dụ:#include &lt;iostream&gt;using namespace std;class Cat{    public:        string name;        int age;        Cat(string _name, int _age)        {            name = _name;            age = _age;        }        Cat(const Cat&amp; cat)        {            cout &lt;&lt; \"Copy constructor!\\n\";            name = cat.name;            age = cat.age;        }};int main(){    Cat cat = Cat(\"Tom\", 3);    cout &lt;&lt; cat.name &lt;&lt; ' ' &lt;&lt; cat.age &lt;&lt; '\\n';    Cat secondCat = cat;    cout &lt;&lt; secondCat.name &lt;&lt; ' ' &lt;&lt; secondCat.age;    return 0;}OutputTom 3Copy constructor!Tom 3Con trỏ với class - thisTất cả các object thuộc class đều có thể truy cập tới giá trị con trỏ bộ nhớ của mình thông qua từ khóa this. Ví dụ:#include &lt;iostream&gt;using namespace std;class Cat{    public:        string name;        int age;        Cat(string _name, int _age)        {            name = _name;            age = _age;        }        void printThis()        {            cout &lt;&lt; this &lt;&lt; '\\n';        }};int main(){    Cat cat = Cat(\"Tom\", 3);    cat.printThis();    Cat secondCat = cat;    secondCat.printThis();    return 0;}Hai giá trị được in ra sẽ khác nhau, do hai đối tượng được lưu ở hai vị trí bộ nhớ khác nhau.Các thao tác đối với con trỏ bộ nhớ trên class cũng tương tự như với struct.Các yếu tố tĩnh (static) của classGiả sử bây giờ ta muốn đếm số lượng object Cat đã được sử dụng trong chương trình. Ta có thể sử dụng một biến global catNumber, và mỗi khi chạy hàm khởi tạo một object Cat thì ta tăng catNumber lên một. Tuy nhiên mỗi khi sử dụng class Cat, ta sẽ lại phải khai báo bên ngoài một biến catNumber, trong khi rõ ràng biến catNumber này vẫn luôn luôn gắn kèm về mặt ý nghĩa với class Cat. Điều này có thể sinh ra nhiều rắc rồi trong tương lai.Giải phải là thay vì để catNumber là một biến global, ta sẽ khai báo catNumber thành một biến tĩnh - static - của class. Các yếu tố static hoàn toàn độc lập với các object của class - cho dù có bao nhiêu object thuộc class trong chương trình, các yếu tố static sẽ luôn luôn chỉ có một, và có thể truy cập thông qua toán tử :: (toán tử truy cập scope).class Cat{    static int catNumber;}int Cat::catNumber = 0;Các biến static sẽ được khởi tạo cùng với object đầu tiên được tạo ra của class. Nếu như chưa có object nào được tạo ra, nhưng ta vẫn muốn truy cập vào biến static, ta phải khai báo giá trị của biến static ở bên ngoài, sử dụng toán tử ::.Tương tự, ta cũng có thể định nghĩa các chương trình con static độc lập với toàn bộ object của class bằng từ khóa static.Ví dụ:#include &lt;iostream&gt;using namespace std;class Cat{    static int catNumber;    public:        string name;        int age;        Cat(string _name, int _age)        {            catNumber ++;            name = _name;            age = _age;        }        static void printCatNumber()        {            cout &lt;&lt; catNumber &lt;&lt; '\\n';        }};int Cat::catNumber = 0;int main(){    Cat cat = Cat(\"Tom\", 3);    Cat secondCat = Cat(\"Jerry\", 1);    Cat::printCatNumber();    return 0;}Output2Một ứng dụng quan trọng của các yếu tố static là Design Pattern Singleton - thiết kế chương trình đảm bảo chỉ có một object của class tồn tại trong suốt quá trình chạy của chương trình.Giả sử ta có một class rất to và nặng, chỉ cần tạo ra một lần trong toàn bộ chương trình (ví dụ như database). Khi đó ta sẽ lưu một object của class đó dưới dạng static, và cho phép gán giá trị của object static này cho các đối tượng thông qua một hàm getInstance() thay vì phải khởi tạo lại từ đầu.#include &lt;iostream&gt;using namespace std;class Cat{    private:        static Cat *instance;    public:        static Cat getInstance()        {            if (instance == NULL)                instance = new Cat();            return *instance;        }};Cat *Cat::instance = NULL;int main(){    Cat cat = Cat::getInstance();    return 0;}Phần sau: [C++ Cơ bản] Phần 23: Tính thừa kế - Class con (subclass)",
              url: "/article/c-co-ban-phan-22-class-va-object"
            }
            ,

            {
              title: "[Lập trình thi đấu cơ bản] Phần cuối: Kinh nghiệm khi thi cử",
              author: "Nam Phương Đại Hiệp",
              category: ["article"],
              tag: ["competitive-programming", "cp"],
              content: "Phần trước: [Lập trình thi đấu cơ bản] Phần 3: Kiểm tra và soát lỗi bài làmNhư vậy là sau 4 bài trước của series Lập trình thi đấu cơ bản, chúng ta đã phần nào hiểu rõ những khái niệm, những nguyên tắc đơn giản nhất để bước chân vào “giang hồ”. Chúng mình rất muốn chia sẻ với các bạn nhiều hơn nữa, tuy nhiên do thời gian có hạn và phải gánh thêm nhiều series khác, do đó Cowboy Coder xin tạm kết thúc series “Lập trình thi đấu cơ bản” ở bài này.Ngay từ đầu, đối tượng hướng đến của series này chính đó là các bạn học sinh, sinh viên. Các bạn là những người có nhiều cơ hội được tham gia thi thố, cọ sát. Và hơn cả là những kì thi quan trọng có thể ảnh hưởng đến cả tương lai của các bạn như kì thi học sinh giỏi quốc gia chẳng hạn. Vì vậy, ở bài này chúng ta sẽ bàn về những kinh nghiệm khi thi cử. Để làm sao tối đa hóa khả năng bản thân, cũng như đạt những kết quả như mong muốn.Trước khi thiChuẩn bị luôn là bước quan trọng nhất. Nếu bạn muốn có một kết quả tốt thì bạn phải có một bước chuẩn bị kĩ càng. Tuy nhiên, việc chuẩn bị là cả một quá trình, chứ không phải trong một vài ngày là đủ. Đừng bao giờ dành những ngày cuối cùng trước khi thi của mình để nhồi nhét, để cố ôn tập bất kì thứ gì. Bời vì kiến thức ở môn tin học và trong lập trình thi đấu có đặc thù của nó. Là một môn đề cao khả năng tư duy, mà tư duy thì phải cần có thời gian rèn giũa mới phát triển được. Do đó, việc học và training của bạn là cả một quá trình dài đã qua. Đừng vì lo sợ thiếu sót kiến thức mà lao đầu vào cày cuốc, việc đó chỉ khiến bạn thêm bối rối và phát hiện thêm nhiều lỗ hổng của mình mà thôi. Còn nếu thật sự kiến thức bạn quá thiếu sót, kiểu như chưa biết gì thì… thôi cứ YOLO đi. Vì vài ngày ngắn ngủi cũng chẳng giúp bạn hơn được ai cả. Thay vào đó, hãy thư giản, nghe nhạc, xem phim hay chơi game chẳng hạn. Và điều quan trọng nhất vẫn là sức khỏe. Hãy giữ cho mình một tinh thần sảng khoái và tràn đầy sức sống trước khi bước vào bất kì một cuộc thi nào.Trong kì thiBình tĩnh là điều quan trọng nhất trong các kì thi. Nếu không giữ được bình tĩnh thì mọi thứ gần như tan vỡ. Vì vậy, tập giữ bình tĩnh, không lo lắng trong kì thi là một điều quan trọng. Ngoài ra, mình cũng xin liệt kê một số thói quen mà mình thấy là những người “pro” trong lập trình thi đấu thường có:  Test máy kĩ, hãy làm những điều quen thuộc như với máy tính của bạn vậy. Hãy xem đó như làm quen với không khí còn bỡ ngỡ khi vừa bước vào phòng thi.  Hãy giải lao vài phút khi lâm vào thế bí. Với những bài tập dạng “thách đấu” trong kì thi thì việc đôi lúc lâm vào thế bí là một chuyện hết sức bình thường. Khi ấy, đừng cố bám theo những dữ kiện đã làm mình rơi vào chân tường nữa. Mà hãy cho mình vài phút giải lao (xin ra ngoài hóng gió, hay uống nước chẳng hạn, …). Và sau đó bắt đầu suy nghĩ lại từ đầu, theo kinh nghiệm của nhiều người đúc kết được thì đó là cách hiệu quả nhất để gỡ rối.  Vét cạn: Luôn giữ càng nhiều điểm càng tốt. Để chắc chắn, hãy viết solution cho từng subtask và với nhiều điều kiện của test khác nhau hãy cho chạy từng subtask một để chắc ăn nhất. Ví dụ như thế này chẳng hạn:if (N &lt; 1000) sol_subtask1();else sol_subtask2();  Tham lam: Đôi khi với những bài quá khó. Bạn đã cố thử mọi cách cũng như vét cạn hết các subtask nhỏ, nhưng còn subtask còn lại thì có vẻ không khả thi. Lúc đó, phương pháp tham lam chính là lúc cần lên tiếng. Trong nhiều cuộc thi, phương pháp tham lam của ai khoan ngoan hơn là cách duy nhất để phân định thứ hạng, khi những subtask dễ còn lại hầu như ai cũng giải được. Vì vậy, tại sao không thử một cách tham lam đơn giản mà bạn có thể nghĩ ra, biết đâu bạn sẽ gặp may mắn thì sao.  Phân thời gian hợp lí: Như đã nói ở các bài trước vì sao cần phải phân chia thời gian. Ở đây mình chỉ nhắc lại rằng nó là một điều cốt yếu cho thành bại của cả một bài thi.  Bài dễ làm trước, bài khó làm sau: Điều này thì trước khi thi chắc có lẽ bạn sẽ được dặn dò khá nhiều lần. Lí do của nó chắc ai cũng biết, tuy nhiên lại có một số thành phần khá hổ báo, vừa bắt đầu đã solo với những bài khó. Mình xin nhắc lại, điều đó hoàn toàn không khoa học, trừ khi bạn là những ACMer ngoại hạng kiểu như Petr hay tourist, chứ nếu không thì thôi, pleaseee… hãy đọc đề kĩ và làm bài dễ trước. Đó mới là cách tốt nhất cho chúng ta.Sau khi thiĐây là lúc yolo được rồi. Bạn có một thời gian rãnh làm mọi điều bạn muốn trong lúc chờ đợi kết quả. Nhưng mà, mình khuyên các bạn nên làm một cái gì đó có ích một chút, chứ đừng ngồi chờ kết quả cả tuần, cả tháng. Vì kết quả là do người khác quyết định chứ không phải bạn, dù bạn có cầu nguyện hay làm gì đi nữa thì cũng chẳng có tác dụng gì cả. :)",
              url: "/article/lap-trinh-thi-dau-co-ban-phan-cuoi-kinh-nghiem-khi-thi-cu"
            }
            ,

            {
              title: "[C++ Cơ bản] Phần 21: Lập trình hướng đối tượng - Object Oriented Programming",
              author: "Admin Tổng Quản",
              category: ["article"],
              tag: ["cpp-cơ-bản", "programming"],
              content: "Phần trước: [C++ Cơ bản] Phần 20: Bài thực hành tổng hợp - Chương trình quản lý học sinh (tiếp)Trước khi bắt đầu bài viết, hãy cùng công nhận hai sự thật sau:  Viết lặp code là xấu  Code sẽ luôn luôn bị thay đổiĐiều đầu tiên là rõ ràng - nếu như có nhiều đoạn code cùng làm một chức năng trong chương trình, khi ta muốn chỉnh sửa sẽ phải chỉnh sửa tất cả các đoạn code như thế. Điều đó rất dễ sinh ra lỗi, hoặc ít nhất sẽ khiến bạn và những người phải đọc code của bạn vô cùng khó chịu. Đó cũng là lý do vì sao chúng ta phải sử dụng tới chương trình con.Trừ khi bạn đang viết những chương trình “dùng một lần rồi bỏ”, ngược lại thì điều thứ hai cũng đúng. Bạn sẽ luôn luôn phải mó đến code cũ để sửa bug hoặc nâng cấp chương trình, hoặc sửa bug vì nâng cấp chương trình, vân vân… Đời là bể khổ, viết code là quá trình viết ra bug mà ¯\\(ツ)/¯Để thích nghi với hai điều trên, bắt đầu từ bài viết này chúng ta sẽ làm quen với một phương pháp lập trình mới rất quan trọng trong ứng dụng thực tế, đó là lập trình hướng đối tượng.Programming Paradigm - Mẫu hình lập trìnhGiống như các vấn đề trong thực tế, các bài toán lập trình cũng có nhiều cách tiếp cận khác nhau. Ta gọi các cách tiếp cận tới bài toán lập trình là các mẫu hình lập trình - Programming Paradigm. Phần lớn các ngôn ngữ sẽ được viết theo một paradigm nhất định, nhưng cũng có các ngôn ngữ hỗ trợ nhiều paradigm như C++. Hai paradigm quan trọng nhất trong lập trình là lập trình thủ tục - Procedural Paradigm và lập trình hướng đối tượng - Object-oriented Paradigm.Procedural Programming (PP)Lập trình thủ tục sử dụng các chương trình con để xử lý dữ liệu theo từng bước một. Cách tiếp cận bài toán là hình dung thông tin như dòng chảy từ input, di chuyển qua các thành phần xử lý trong chương trình, và đưa ra output. Chẳng đâu xa, từ đầu series bài viết tới giờ, chúng ta đã sử dụng PP rồi.Phương pháp lập trình này rất trực quan, vì nó giống như cách mà một chiếc máy tính hoạt động: bằng cách cung cấp chỉ dẫn từng bước một cho nó. Vậy nên cũng dễ hiểu tại sao các ngôn ngữ lập trình đời đầu như Fortran, COBOL hay C đều là các ngôn ngữ PP.Object-oriented Programming (OOP)Lập trình hướng đối tượng lại là một cách tiếp cận bài toán khác: Ta hình dung dữ liệu như các đối tượng, với các đặc tính và hành vi đặc trưng, và chương trình hoạt động bằng cách cho các đối tượng giao tiếp với nhau.Ví dụ áp dụng bài thực hành tổng hợp khi trước: Ta có một kiểu dữ liệu Student lưu trữ thông tin của học sinh, một kiểu dữ liệu DatabaseProcessor có khả năng thực hiện các thao tác trên cơ sở dữ liệu, và một kiểu dữ liệu UserInterface quản lý giao diện người dùng của chương trình. Khi người dùng thực hiện các thao tác như click, nhập dữ liệu, đối tượng UserInterface sẽ thực hiện thay đổi lên đối tượng Student, rồi đẩy đối tượng Student cho DatabaseProcessor để lưu trữ. Toàn bộ chương trình chính là một hệ thống định nghĩa các đối tượng này và cách mà chúng giao tiếp với nhau.C++ ra đời nhằm mục đích bổ sung thêm khả năng lập trình OOP cho C (vì vậy ban đầu nó còn có tên là C with Class). Java là một ngôn ngữ lập trình hướng đối tượng phổ biến khác.OOP có những tính chất gì?Class và ObjectỞ trong bài viết Cú pháp C++ cơ bản, chúng ta đã nói về Class và Object. Ta hiểu rằng object là các đối tượng trong chương trình, và class là định nghĩa cho các nhóm đối tượng đó. Các object có các thuộc tính (attribute) và phương thức (method) để giao tiếp với nhau. Việc viết chương trình OOP định nghĩa các class và quy định chúng giao tiếp với nhau như thế nào.Tính thừa kế (inheritance)Giả sử chúng ta có class Animal, bao gồm một số thông tin cơ bản về các loài động vật như là tên loài, thuộc nhóm nào, chi nào. Sau đó chúng ta lại muốn tạo ra một class Cat để mô tả loài mèo. Rõ ràng là mèo là một loài động vật rồi, nên nó cũng phải thừa hưởng tất cả các tính chất chung của động vật. Nếu mà copy code rồi paste ra thì không ổn, vi phạm quy tắc 1 ở trên. Bằng cách cho class Cat là một class con của Animal, Cat sẽ thừa hưởng mọi đặc tính của Animal - đây chính là ví dụ của tính thừa kế.Tính trừu tượng (abstraction)Lại nói tới chuyện class Animal. Đã là động vật thì phải biết đi, vậy nên tất cả các loài động vật đều có chương trình con walk(). Thế nhưng mỗi loài động vật lại có một cách đi riêng: Con mèo thi chạy bằng 4 chân, con rắn thì bò, con người thì bước bằng 2 chân…Nếu bây giờ bạn có một object thuộc class Animal, bạn chỉ muốn ra lệnh walk() cho nó, mà không hề muốn quan tâm gì tới cái phần ẩn phía dưới kia hết. Đó chính là tính trừu tượng - cung cấp phần quan trọng của đối tượng mà không cần quan tâm tới các yếu tố hậu trường.Tính đa hình (polymorphism)Như ở trong ví dụ đi lại của động vật, ta thấy rõ ràng rằng với cùng một class Animal, đối tượng này có thể có chương trình con walk() hoạt động như thế này, trong khi đối tượng khác có thể có walk() hoạt động kiểu khác. Đây chính là ví dụ của tính đa hình - cùng một chương trình con có thể có cách hoạt động khác nhau, tùy vào cài đặt object đang được gọi.Tính đóng gói (encapsulation)Ta chuyển sang chuyện ăn uống của các loài động vật. Cũng giống như đi lại, các loài động vật chỉ cần cho thức ăn vào miệng và ăn, không cần quan trọng phía bên trong ruột rà xử lý ra làm sao (táy máy vào có khi còn lòi ruột). Trong lập trình cũng như thế, có những yếu tố của một đối tượng mà ta muốn che giấu khỏi người khác hoặc chương trình khác, để không bị xáo trộn lung tung gây hỏng hóc.Ví dụ: Ta có một class Date, dùng để biểu diễn ngày. Trong class Date có một biến int gọi là weekDay, dùng để chỉ thị xem ngày đang được biểu diễn là thứ mấy, với giá trị từ 1 tới 7. Giả sử từ bên ngoài, ta có thể thay đổi được giá trị weekDay này. Thế thì ta có thể tha hồ gán giá trị lung tung cho weekDay, như 86400 chẳng hạn, và làm hỏng cả hệ thống.Tính đóng gói cho phép ta gói dữ liệu nội bộ bên trong class, giới hạn những gì có thể truy cập được từ bên ngoài (public) và những gì không (private), để dễ dàng kiểm soát đối tượng.Tại sao lại phải dùng OOP?Quay trở về hai quy tắc ở đầu bài, ta thấy OOP chính là giải pháp đáp ứng phù hợp. Bằng việc thiết kế đối tượng một cách hợp lý, ta có thể tạo ra các cấu trúc thừa kế các tính chất của nhau, tránh việc phải lặp đi lặp lại code. Các class được thiết kế như các module nhỏ của chương trình, và chỉ cần lắp đặt khớp vào với nhau thì chương trình có thể dễ dàng nâng cấp hay chỉnh sửa.Đó, xong phần lý thuyết rồi. Bài viết tiếp theo sẽ nói về cách triển khai OOP trong C++, bắt đầu với class và object.Phần sau: [C++ Cơ bản] Phần 22: Class và Object",
              url: "/article/c-co-ban-phan-21-lap-trinh-huong-doi-tuong-object-oriented-programming"
            }
            ,

            {
              title: "[C++ Cơ bản] Phần 20: Bài thực hành tổng hợp - Chương trình quản lý học sinh (tiếp)",
              author: "Admin Tổng Quản",
              category: ["article"],
              tag: ["cpp-cơ-bản"],
              content: "Phần trước: [C++ Cơ bản] Phần 19: Bài thực hành tổng hợp - Chương trình quản lý học sinhỞ trong bài trước, chúng ta đã hoàn thành các chức năng tạo file mới, mở file cũ và thêm - sửa - xóa thông tin của học sinh. Trong bài viết này chúng ta sẽ hoàn thành các chức năng còn lại là liệt kê toàn bộ học sinh, lọc học sinh theo thông tin và lưu dữ liệu vào file.Liệt kê toàn bộ học sinhTa sẽ thống nhất sử dụng một mẫu output chung cho thông tin học sinh, bao gồm 5 dòng:  Dòng đầu tiên là mã số học sinh, chính là chỉ số phần tử của học sinh đó trong mảng  Dòng thứ hai là tên, lớp và địa chỉ của học sinh  3 dòng tiếp theo là điểm số 3 môn của học sinhVà tất nhiên, vì ta phải in thông tin học sinh ra nhiều lần, sẽ tiện lợi hơn nếu ta viết một hàm printStudentInfo(int id) để in thông tin của học sinh ở chỉ số id.void printStudentInfo(int id){    cout    &lt;&lt; \"Ma so hoc sinh: \" &lt;&lt; id &lt;&lt; '\\n'    &lt;&lt; allStudent[id].name &lt;&lt; \", hoc sinh lop \" &lt;&lt; allStudent[id].inClass &lt;&lt; \", song tai \" &lt;&lt; allStudent[id].address    &lt;&lt; '\\n'    &lt;&lt; \"Diem mon Toan: \" &lt;&lt; allStudent[id].math    &lt;&lt; '\\n'    &lt;&lt; \"Diem mon Van: \" &lt;&lt; allStudent[id].literature    &lt;&lt; '\\n'    &lt;&lt; \"Diem mon Anh: \" &lt;&lt; allStudent[id].english    &lt;&lt; '\\n';}Bây giờ để in tất cả học sinh trong danh sách ra, ta chỉ cần duyệt các phần tử từ 1 tới number, và gọi hàm printStudentInfo() thôi.void printAllStudent(){    for (int i = 1; i &lt;= number; i ++)        printStudentInfo(i);}Lọc học sinh theo thông tinĐều đầu tiên khi lọc học sinh theo thông tin là phải hỏi người dùng muốn dùng thông tin nào để lọc ra. void searchStudent(){    cout &lt;&lt; \"Ban muon tim kiem hoc sinh theo thong tin nao?\\n\";    cout &lt;&lt; \"1: Ten\\n\";    cout &lt;&lt; \"2: Lop\\n\";    cout &lt;&lt; \"3: Dia chi\\n\";    cout &lt;&lt; \"4: Diem Toan\\n\";    cout &lt;&lt; \"5: Diem Van\\n\";    cout &lt;&lt; \"6: Diem Anh\\n\";    int byWhat = getIntRange(1, 6);Ok, giờ nảy sinh ra một vấn đề như thế này: 3 thông tin đầu tiên sẽ là dữ liệu kiểu string, trong khi ba thông tin sau là dữ liệu kiểu double. Đối với dữ liệu kiểu số, ta còn phải hỗ trợ khả năng tìm kiếm các học sinh có giá trị lớn hơn, nhỏ hơn, vân vân… chứ không chỉ là các học sinh có điểm số bằng một mức nào đó. Ta sẽ viết riêng việc tìm kiếm theo các giá trị string và việc tìm kiếm các giá trị số thành hai chương trình con riêng - searchStudentByString() và searchStudentByScore().Đối với việc tìm kiếm học sinh theo string, ta chỉ cần đọc vào một giá trị tìm kiếm data nữa.    if (byWhat &lt;= 3) // Ba thông tin kiểu string    {        cout &lt;&lt; \"Nhap gia tri can tim: \";        string data; getline(cin, data); getline(cin, data);        searchStudentByString(byWhat, data);    }Đối với việc tìm kiếm học sinh theo điểm số, ngoài giá trị so sánh data, ta còn phải đọc thêm một giá trị compare, là lựa chọn của người dùng về phép so sánh.    else // Ba thông tin kiểu số    {        cout &lt;&lt; \"Nhap gia tri can tim: \";        double data; cin &gt;&gt; data;        cout &lt;&lt; \"Ban muon so sanh nhu the nao?\\n\";        cout &lt;&lt; \"1: =\\n\";        cout &lt;&lt; \"2: &gt;\\n\";        cout &lt;&lt; \"3: &lt;\\n\";        cout &lt;&lt; \"4: &gt;=\\n\";        cout &lt;&lt; \"5: &lt;=\\n\";        int compare = getIntRange(1, 5);        searchStudentByScore(byWhat, data, compare);    }}Toàn bộ nội dung của hàm searchStudent() như sauvoid searchStudent(){    cout &lt;&lt; \"Ban muon tim kiem hoc sinh theo thong tin nao?\\n\";    cout &lt;&lt; \"1: Ten\\n\";    cout &lt;&lt; \"2: Lop\\n\";    cout &lt;&lt; \"3: Dia chi\\n\";    cout &lt;&lt; \"4: Diem Toan\\n\";    cout &lt;&lt; \"5: Diem Van\\n\";    cout &lt;&lt; \"6: Diem Anh\\n\";    int byWhat = getIntRange(1, 6);    if (byWhat &lt;= 3) // Ba thông tin kiểu string    {        cout &lt;&lt; \"Nhap gia tri can tim: \";        string data; getline(cin, data); getline(cin, data);        searchStudentByString(byWhat, data);    }    else // Ba thông tin kiểu số    {        cout &lt;&lt; \"Nhap gia tri can tim: \";        double data; cin &gt;&gt; data;        cout &lt;&lt; \"Ban muon so sanh nhu the nao?\\n\";        cout &lt;&lt; \"1: =\\n\";        cout &lt;&lt; \"2: &gt;\\n\";        cout &lt;&lt; \"3: &lt;\\n\";        cout &lt;&lt; \"4: &gt;=\\n\";        cout &lt;&lt; \"5: &lt;=\\n\";        int compare = getIntRange(1, 5);        searchStudentByScore(byWhat, data, compare);    }}Tìm kiếm học sinh theo stringViệc tìm kiếm học sinh theo string khá là đơn giản - ta chỉ cần duyệt qua tất cả học sinh, lấy giá trị phù hợp theo yêu cầu byWhat được đưa ra, và so sánh với giá trị yêu cầu value.  Nếu bằng nhau, ta in ra thông tin của học sinh.void searchStudentByString(int byWhat, string value){    for (int i = 1; i &lt;= number; i ++)    {        // Lấy dữ liệu phù hợp        string data;        switch(byWhat)        {            case 1: // Tìm theo tên                data = allStudent[i].name;                break;            case 2: // Tìm theo lớp                data = allStudent[i].inClass;                break;            case 3: // Tìm theo địa chỉ                data = allStudent[i].address;                break;        }        // So sánh với yêu cầu        if (data == value)            printStudentInfo(i);    }}Tìm kiếm học sinh theo điểm sốViệc tìm kiếm học sinh theo điểm số về cơ bản là giống với tìm kiếm bằng string, nhưng ta cần thêm một bước trung gian là thực hiện phép so sánh phù hợp với giá trị compare nhập vào. Ta sẽ đặt biến bool check là kết quả của việc kiểm tra, và nếu check bằng true, ta in ra thông tin của học sinh.void searchStudentByScore(int byWhat, double value, int compare){    for (int i = 1; i &lt;= number; i ++)    {        // Lấy dữ liệu phù hợp        double data;        switch(byWhat)        {            case 4: // Tìm theo điểm môn Toán                data = allStudent[i].math;                break;            case 5: // Tìm theo điểm môn Văn                data = allStudent[i].literature;                break;            case 6: // Tìm theo điểm môn Anh                data = allStudent[i].english;                break;        }        bool check;        // So sánh phù hợp với phép toán        switch (compare)        {            case 1: // =                check = (data == value);                break;            case 2: // &gt;                check = (data &gt; value);                break;            case 3: // &lt;                check = (data &lt; value);                break;            case 4: // &gt;=                check = (data &gt;= value);                break;            case 5: // &lt;=                check = (data &lt;= value);                break;        }        // Kiểm tra kết quả        if (check)            printStudentInfo(i);    }}Lưu thông tin học sinh vào fileNhư đã nói ở bài trước, việc lưu thông tin vào file có thể được lưu vào file đang được mở ra, hoặc lưu vào file mới. Do đó trước khi bắt đầu lưu, ta cần kiểm tra xem hiện tại đang có file mở ra hay không, và nếu có thì phải hỏi ý kiến người dùng trước khi lưu.void saveFile(){    if (strcmp(currentFile, \"\") != 0) // Nếu như có file hiện tại đang được mở    {        cout &lt;&lt; \"Ban muon luu vao file cu, hay tao file moi?\\n\";        cout &lt;&lt; \"1: File cu\\n\";        cout &lt;&lt; \"2: File moi\\n\";        int input = getIntRange(1, 2);        if (input == 2)        {            cout &lt;&lt; \"Hay nhap ten file ban muon tao moi: \";            cin &gt;&gt; currentFile;        }    }Nếu như không có file nào được mở cả, thì ta chỉ đơn giản hỏi người dùng tên của file muốn lưu ra.    else    {        cout &lt;&lt; \"Hay nhap ten file ban muon tao moi: \";        cin &gt;&gt; currentFile;    }Ok, giờ file mục tiêu đã có, việc còn lại là viết các thông tin ra theo đúng tiêu chuẩn đã quy định ở bài trước. Nhớ phải mã hóa các dấu cách như đã quy định bằng hàm encode() ở bài trước nhé.    // Mở file    ofstream output;    output.open(currentFile);    // Viết ra file phù hợp với tiêu chuẩn    output &lt;&lt; number &lt;&lt; '\\n';    for (int i = 1; i &lt;= number; i ++)    {        output &lt;&lt; encode(allStudent[i].name) &lt;&lt; '\\n';        output &lt;&lt; encode(allStudent[i].inClass) &lt;&lt; '\\n';        output &lt;&lt; encode(allStudent[i].address) &lt;&lt; '\\n';        output &lt;&lt; allStudent[i].math &lt;&lt; '\\n';        output &lt;&lt; allStudent[i].literature &lt;&lt; '\\n';        output &lt;&lt; allStudent[i].english &lt;&lt; '\\n';    }    // Đóng file    output.close();}Toàn bộ nội dung của chương trình con saveFile() như sauvoid saveFile(){    if (strcmp(currentFile, \"\") != 0) // Nếu như có file hiện tại đang được mở    {        cout &lt;&lt; \"Ban muon luu vao file cu, hay tao file moi?\\n\";        cout &lt;&lt; \"1: File cu\\n\";        cout &lt;&lt; \"2: File moi\\n\";        int input = getIntRange(1, 2);        if (input == 2)        {            cout &lt;&lt; \"Hay nhap ten file ban muon tao moi: \";            cin &gt;&gt; currentFile;        }    }    else    {        cout &lt;&lt; \"Hay nhap ten file ban muon tao moi: \";        cin &gt;&gt; currentFile;    }    // Mở file    ofstream output;    output.open(currentFile);    // Viết ra file phù hợp với tiêu chuẩn    output &lt;&lt; number &lt;&lt; '\\n';    for (int i = 1; i &lt;= number; i ++)    {        output &lt;&lt; encode(allStudent[i].name) &lt;&lt; '\\n';        output &lt;&lt; encode(allStudent[i].inClass) &lt;&lt; '\\n';        output &lt;&lt; encode(allStudent[i].address) &lt;&lt; '\\n';        output &lt;&lt; allStudent[i].math &lt;&lt; '\\n';        output &lt;&lt; allStudent[i].literature &lt;&lt; '\\n';        output &lt;&lt; allStudent[i].english &lt;&lt; '\\n';    }    // Đóng file    output.close();}Đóng file hiện tại và kết thúc chương trìnhChức năng cuối cùng ta phải làm cho chương trình, đó là đóng file hiện tại lại và chuyển về trạng thái ban đầu (isEditing bằng false).Phép lịch sự tối thiểu bao giờ cũng phải là hỏi người dùng có muốn lưu trữ file hiện tại không, phòng ngừa việc ấn nhấm mà tắt đi không lưu lại.void exitFile(){    cout &lt;&lt; \"Ban co muon luu file hien tai?\\n\";    cout &lt;&lt; \"1: Yes\\n\";    cout &lt;&lt; \"0: No\\n\";    int input = getIntRange(0, 1);    if (input == 1)        saveFile();Sau khi đã đảm bao file được lưu rồi, ta chỉ cần chuyển isEditing về false, là kết thúc phiên làm việc với file.    // Đóng file    output.close();}Đó, vậy là chương trình của chúng ta đã hoàn tất!Bình luậnTrong lập trình thực tế, chúng ta sẽ muốn lưu trữ các thông tin như trong ví dụ này bằng các cơ sở dữ liệu, với khả năng hỗ trợ tìm kiếm trực quan và hiệu quả hơn. Nhưng để phục vụ mục đích của bài viết là luyện tập tổng hợp, bài thực hành sử dụng cách đọc và viết ra file mà ta đã biết.Chương trình sau khi hoàn thành cũng rất dài, tới gần 400 dòng. Trong lập trình thực tế ta sẽ muốn tránh việc viết một file quá dài dòng như thế này, mà thay vào đó là viết chương trình ra thành các module nhỏ, và gọi các module nhỏ trong một file lớn. Điều này giúp cho việc bảo trì chương trình dễ dàng hơn. Đó cũng chính là một chức năng quan trọng của việc lập trình hướng đối tượng - Object Oriented Programming - mà chúng ta sẽ bắt đầu đề cập tới kể từ bài viết tiếp theo.Tới đây là kết thúc bài thực hành tổng hợp rồi. Các bạn có thể xem code mẫu và download chương trình hoàn trình trên repository GitHub của nhóm Cowboy Coder.Phần sau: [C++ Cơ bản] Phần 21: Lập trình hướng đối tượng - Object Oriented Programming",
              url: "/article/c-co-ban-phan-20-bai-thuc-hanh-tong-hop-chuong-trinh-quan-ly-hoc-sinh-tiep"
            }
            ,

            {
              title: "[C++ Cơ bản] Phần 19: Bài thực hành tổng hợp - Chương trình quản lý học sinh",
              author: "Admin Tổng Quản",
              category: ["article"],
              tag: ["cpp-cơ-bản", "programming"],
              content: "Phần trước: [C++ Cơ bản] Phần 18: Cấu trúc dữ liệu - struct và classHọc hành là phải vừa “học” lại vừa “hành”. Trong bài viết này và bài viết sau, chúng ta sẽ tổng hợp lại các kiến thức đã học vào trong một bài viết thực hành lớn - phần mềm quản lý học sinh. Sau khi hoàn thành xong bài thực hành này, bạn có thể đem sản phẩm vào sử dụng trong thực tế - vẫn còn xa lắm mới tới được một chương trình với giao diện đẹp đẽ, nhưng cũng khá tốt rồi.Yêu cầu của bài thực hànhTrong bài viết này, chúng ta sẽ viết một chương trình quản lý học sinh có các khả năng sau:  Đọc và lưu trữ dữ liệu của học sinh từ một file text. Thông tin của học sinh bao gồm tên, lớp, địa chỉ và điểm số 3 môn Toán, Văn, Anh.  Cho phép thực hiện các hành động thêm học sinh mới và chỉnh sửa hoặc xóa học sinh cũ.  Cho phép liệt kê tất cả học sinh, hoặc lọc học sinh theo tên, lớp, địa chỉ hoặc điểm số.Khi ta chạy chương trình quản lý học sinh, phần mềm sẽ yêu cầu ta lựa chọn mở một file cũ, hoặc tạo một file mới, hoặc kết thúc chương trình bằng cách nhập lệnh vào màn hình console.Khi ta đã mở file hoặc tạo file, chương trình sẽ cho phép người dùng in ra toàn bộ học sinh, lọc lấy một số học sinh, thêm, chỉnh sửa, xóa thông tin học sinh, hoặc kết thúc công việc và đóng file.Khi lọc học sinh theo thông tin dạng chữ, ta sẽ lấy các học sinh có thông tin trùng với giá trị nhập vào. Khi lọc theo thông tin dạng số, ta có thể lựa chọn lấy các giá trị bằng, lớn hơn, nhỏ hơn,…Các bạn có thể download chương trình đã hoàn thành tại đây để chạy thử.Ok, với các thông tin đã có, chúng ta sẽ bắt tay vào thực hành!Cấu trúc dữ liệu StudentĐể có thể lưu trữ dữ liệu của học sinh, ta cần có cấu trúc dữ liệu để biểu diễn học sinh. Ta sẽ sử dụng struct để tạo ra kiểu dữ liệu Student bao gồm các biến  string name - Tên của học sinh  string inClass - Lớp của học sinh. Ta sử dụng inClass thay vì class, do class là từ khóa của C++.  string address - Địa chỉ  double math, literature, english - Điểm số 3 bộ môn Toán, Văn, AnhHãy nhớ khai báo sử dụng thư viện string trước khi sử dụng class string.struct Student{    string name, inClass, address;    double math, literature, english;};Sau khi ta đã có cấu trúc dữ liệu Student, ta có thể khai báo một mảng Student để lưu trữ các học sinh đang được xử lý. Ở đây ta gọi mảng Student là allStudent[] với \\( 10 ^ 5 \\) phần tử.Student allStudent[100000];Ta cũng cần một biến int number, là số lượng học sinh đang được xử lý. Các học sinh được đọc ra từ file sẽ được lưu trữ trong các phần tử mảng allStudent[], từ 1 tới number.Cấu trúc của file đầu vào.Ta cần phải quy định bố cục nội dung của file đầu vào, để chương trình có thể xử lý được file. Dưới đây là bố cục được sử dụng trong bài viết.  Dòng đầu tiên chứa một số kiểu int, là số lượng học sinh được lưu trữ trong file.  Các nhóm dòng tiếp theo lưu trữ thông tin về học sinh. Trong mỗi nhóm dòng, mỗi dòng lần lượt sẽ là giá trị của các biến name, inClass, address, math, literature và english của học sinh.  Do khi ta đọc vào một string, C++ lấy các kí tự dấu cách làm ngắt từ, nên các string kí tự có nhiều từ sẽ bị cắt ra làm nhiều string. Để giải quyết vần đề này, ta sẽ lưu lại vào file các dấu cách trong các giá trị string bằng kí tự $ (Ví dụ Trần$Minh$Hiếu thay vì Trần Minh Hiếu).Ví dụ về một file đúng chuẩn1Trần$Minh$HiếuKT22The$Internet8.05.07.0Biểu diễn bố cục của chương trình trong hàm mainĐầu tiên, vì chương trình chạy liên tục cho tới khi ta ra lệnh dừng, nên ta sẽ đặt tất cả nội dung của chương trình trong một vòng lặp vô hạn, chỉ được thoát ra khi ta ra lệnh.Chương trình của chúng ta có 2 trạng thái - khi chưa mở file nào ra, và khi đã mở file để chỉnh sửa. Ta sẽ quy định trạng thái của chương trình bằng biến bool global isEditing - true nếu chương trình đang chỉnh sửa file, false nếu ngược lại.Khi chưa mở file nào ra, ta có 3 lựa chọn là tạo file mới, mở file cũ, hoặc kết thúc chương trình. Ta sẽ yêu cầu người dùng nhập vào số 1, 2 hoặc 0, tương ứng với lệnh cần thực hiện.Vấn đề nảy sinh ra: Làm sao để chắc chắn người dùng sẽ nhập vào đúng 3 giá trị này? Ta sẽ viết một hàm getIntRange(), bắt người dùng phải nhập vào một giá trị int cho tới khi giá trị này nằm đúng trong khoảng đã cho. Vòng lặp vô hạn sẽ có tác dụng ở đây:int getIntRange(int low, int high){    int input;    while(true)    {        cin &gt;&gt; input;        if (input &lt; low || input &gt; high)            cout &lt;&lt; \"Gia tri khong hop le, xin hay nhap lai!\\n\";        else            break;    }    return input;}Khi đó ta sẽ biểu diễn trạng thái lúc chưa chỉnh sửa file nào như sau:int main(){    int input;    while (true)    {        if (!isEditing) // Nếu như chưa có file nào được mở        {            cout &lt;&lt; \"Hien chua co file nao duoc mo, ban muon lam gi?\\n\";            cout &lt;&lt; \"1: Tao file moi\\n\";            cout &lt;&lt; \"2: Mo file cu\\n\";            cout &lt;&lt; \"0: Ket thuc chuong trinh\\n\";            input = getIntRange(0, 2);            switch(input)            {                case 1: // Tạo file mới                    newFile();                    break;                case 2: // Mở file cũ                    openFile();                    break;                case 0: // Kết thúc chương trình                    return 0;            }        }Các chương trình con newFile() và openFile() sẽ được chúng ta thêm vào về sau.Khi chương trình đang mở file để chỉnh sửa, ta cũng sẽ sử dụng cấu trúc tương tự để rẽ hướng chương trình:        else        {            cout &lt;&lt; \"Ban muon lam gi voi file?\\n\";            cout &lt;&lt; \"1: In ra tat ca hoc sinh\\n\";            cout &lt;&lt; \"2: Loc hoc sinh theo thong tin\\n\";            cout &lt;&lt; \"3: Them hoc sinh moi\\n\";            cout &lt;&lt; \"4: Chinh sua thong tin hoc sinh\\n\";            cout &lt;&lt; \"5: Xoa thong tin hoc sinh\\n\";            cout &lt;&lt; \"6: Luu\\n\";            cout &lt;&lt; \"7: Dong file hien tai\\n\";            input = getIntRange(1, 7);            switch(input)            {                case 1: // In ra tất cả học sinh                    printAllStudent();                    break;                case 2: // Lọc học sinh theo thông tin                    searchStudent();                    break;                case 3: // Thêm học sinh mới                    addStudent();                    break;                case 4: // Chỉnh sửa thông tin học sinh                    editStudent();                    break;                case 5: // Xóa thông tin học sinh                    deleteStudent();                    break;                case 6: // Lưu                    saveFile();                    break;                case 7:                    exitFile();                    break;            }        }    }Toàn bộ chương trình con main() sẽ có bố cục như sauint main(){    int input;    while (true)    {        if (!isEditing) // Nếu như chưa có file nào được mở        {            cout &lt;&lt; \"Hien chua co file nao duoc mo, ban muon lam gi?\\n\";            cout &lt;&lt; \"1: Tao file moi\\n\";            cout &lt;&lt; \"2: Mo file cu\\n\";            cout &lt;&lt; \"0: Ket thuc chuong trinh\\n\";            input = getIntRange(0, 2);            switch(input)            {                case 1: // Tạo file mới                    newFile();                    break;                case 2: // Mở file cũ                    openFile();                    break;                case 0: // Kết thúc chương trình                    return 0;            }        }        else        {            cout &lt;&lt; \"Ban muon lam gi voi file?\\n\";            cout &lt;&lt; \"1: In ra tat ca hoc sinh\\n\";            cout &lt;&lt; \"2: Loc hoc sinh theo thong tin\\n\";            cout &lt;&lt; \"3: Them hoc sinh moi\\n\";            cout &lt;&lt; \"4: Chinh sua thong tin hoc sinh\\n\";            cout &lt;&lt; \"5: Xoa thong tin hoc sinh\\n\";            cout &lt;&lt; \"6: Luu\\n\";            cout &lt;&lt; \"7: Dong file hien tai\\n\";            input = getIntRange(1, 7);            switch(input)            {                case 1: // In ra tất cả học sinh                    printAllStudent();                    break;                case 2: // Lọc học sinh theo thông tin                    searchStudent();                    break;                case 3: // Thêm học sinh mới                    addStudent();                    break;                case 4: // Chỉnh sửa thông tin học sinh                    editStudent();                    break;                case 5: // Xóa thông tin học sinh                    deleteStudent();                    break;                case 6: // Lưu                    saveFile();                    break;                case 7:                    exitFile();                    break;            }        }    }    return 0;}Tạo file mớiNhư trong các chương trình soạn thảo văn bản hay vẽ tranh, chương trình đều cung cấp cho chúng ta khả năng lưu vào file đang mở, hoặc lưu vào một file mới. Ta sẽ cần phải lưu lại tên của file đang mở, để tiện dùng sau này.Do hàm ofstream.open() chỉ chấp nhận kiểu biểu diễn string bằng mảng char mà không chấp nhận class string, nên ta sẽ tạo một biến global kiểu mảng char currentFile[100] để lưu tên file.Khi ta ra lệnh tạo file mới, thực chất ta chỉ cần làm ba việc: gán giá trị number = 0 (tức là chưa có một học sinh nào trong danh sách cả), gán currentFile[] thành string rỗng (dữ liệu chưa được lưu vào file nào) và chuyển trạng thái isEditing thành true.void newFile(){    // Chưa có học sinh nào trong danh sách    number = 0;    // File chưa được lưu, do đó không có tên file    strcpy(currentFile, \"\");    // Thông báo đã có file đang được chỉnh sửa    isEditing = true;}Đọc dữ liệu từ fileDo dữ liệu trong file mã hóa các dấu cách, nên ta cần phải giải mã chúng khi đọc file.Ta sẽ viết hai hàm decode() và encode() để giải mã và mã hóa string - chỉ cần duyệt qua toàn bộ string, và thay các kí tự $ bằng dấu cách.string decode(string s){    for(int i = 0; i &lt; s.size(); i ++)        if (s[i] == '$')            s[i] = ' ';    return s;}string encode(string s){    for(int i = 0; i &lt; s.size(); i ++)        if (s[i] == ' ')            s[i] = '$';    return s;}Ok, có mã hóa và giải mã rồi, giờ ta sẽ bắt tay vào viết hàm void openFile().char currentFile[100];void openFile(){    // Lưu tên file lại để dùng về sau    cout &lt;&lt; \"Hay nhap vao ten file: \";    cin &gt;&gt; currentFile;    // Mở file    ifstream input;    input.open(currentFile);Sau khi đã mở file ra, ta sẽ đọc file theo đúng bố cục đã trình bày ở trên.    // Đọc dữ liệu    input &gt;&gt; number;    for (int i = 1; i &lt;= number; i ++)    {        input &gt;&gt; allStudent[i].name;        allStudent[i].name = decode(allStudent[i].name);        input &gt;&gt; allStudent[i].inClass;        allStudent[i].inClass = decode(allStudent[i].inClass);        input &gt;&gt; allStudent[i].address;        allStudent[i].address = decode(allStudent[i].address);        input &gt;&gt; allStudent[i].math;        input &gt;&gt; allStudent[i].literature;        input &gt;&gt; allStudent[i].english;    }Cuối cùng, ta đóng stream input lại, và chuyển trạng thái isEditing thành true.    // Đóng file    input.close();    // Thông báo đã có file đang được chỉnh sửa    isEditing = true;}Toàn bộ nội dung của chương trình con openFile() như sau:void openFile(){    // Lưu tên file lại để dùng về sau    cout &lt;&lt; \"Hay nhap vao ten file: \";    cin &gt;&gt; currentFile;    // Mở file    ifstream input;    input.open(currentFile);    // Đọc dữ liệu    input &gt;&gt; number;    for (int i = 1; i &lt;= number; i ++)    {        input &gt;&gt; allStudent[i].name;        allStudent[i].name = decode(allStudent[i].name);        input &gt;&gt; allStudent[i].inClass;        allStudent[i].inClass = decode(allStudent[i].inClass);        input &gt;&gt; allStudent[i].address;        allStudent[i].address = decode(allStudent[i].address);        input &gt;&gt; allStudent[i].math;        input &gt;&gt; allStudent[i].literature;        input &gt;&gt; allStudent[i].english;    }    // Đóng file    input.close();    // Thông báo đã có file đang được chỉnh sửa    isEditing = true;}Thêm học sinh và chỉnh sửa thông tinQuá trình thêm học sinh bao gồm việc nhập thông tin học sinh mới vào danh sách.Quá trình chỉnh sửa thông tin học sinh bao gồm việc chỉ định học sinh nào sẽ bị chỉnh sửa, và nhập thông tin mới trong học sinh.Vậy nên chả có lý do gì ta lại không dùng chung một chương trình con để nhập dữ liệu chung cho hai thao tác này cả. Việc thêm học sinh thì cũng chỉ là việc chỉnh sửa học sinh thứ number + 1 thôi mà :)) Cụ thể ở đây ta sẽ viết một hàm inputStudentInfo(int id), cho phép nhập dữ liệu để lưu trữ vào phần tử vị trí id của mảng allStudent[].Ở trên chúng ta được biết rằng C++ sử dụng kí tự dấu cách để phân cách string, nên ta phải tránh việc lưu tên học sinh có dấu cách bằng việc mã hóa. Nhưng khi đưa tới người dùng sử dụng, ta lại nhất thiết cần phải có dấu cách để có thể nhập thông tin trực quan.Để giải quyết vấn đề này, ta sẽ sử dụng hàm getline() của thư viện fstream. Hàm này nhận hai tham số, một luồng input để lấy dữ liệu và một biến kiểu class string, và hàm này sẽ đọc nốt tất cả thông tin còn lại trên dòng của input để gán vào string. Lệnhgetline(cin, s);có nghĩa là ta sẽ nhập hết dữ liệu còn lại trên dòng hiện tại ở cin, và gán vào biến s.void inputStudentInfo(int id){    string temp; getline(cin, temp);    cout &lt;&lt; \"Ten cua hoc sinh?\\n\";    getline(cin, allStudent[id].name);Tại sao ta lại cần phải đọc vào biến temp trước? Vì ở trên dòng input cuối cùng, trước dòng có tên học sinh, vẫn còn một kí hiệu xuống dòng '\\n' nữa. Ta phải thêm một dòng getline() vào temp để quét nốt dòng này, trước khi xuống tới tên. Đối với lớp và địa chỉ thì lại không cần nữa, vì các dòng getline() đã lấy hết dòng trước hộ rồi.    getline(cin, allStudent[id].inClass);    cout &lt;&lt; \"Dia chi?\\n\";    getline(cin, allStudent[id].address);Cuối cùng, ta nhập vào điểm 3 môn như bình thường.    cout &lt;&lt; \"Diem mon Toan?\\n\"; cin &gt;&gt; allStudent[id].math;    cout &lt;&lt; \"Diem mon Van?\\n\"; cin &gt;&gt; allStudent[id].literature;    cout &lt;&lt; \"Diem mon Anh?\\n\"; cin &gt;&gt; allStudent[id].english;}Toàn bộ nội dung hàm inputStudentInfo() như sau:void inputStudentInfo(int id){    string temp; getline(cin, temp);    cout &lt;&lt; \"Ten cua hoc sinh?\\n\";    getline(cin, allStudent[id].name);    cout &lt;&lt; \"Lop?\\n\";    getline(cin, allStudent[id].inClass);    cout &lt;&lt; \"Dia chi?\\n\";    getline(cin, allStudent[id].address);    cout &lt;&lt; \"Diem mon Toan?\\n\"; cin &gt;&gt; allStudent[id].math;    cout &lt;&lt; \"Diem mon Van?\\n\"; cin &gt;&gt; allStudent[id].literature;    cout &lt;&lt; \"Diem mon Anh?\\n\"; cin &gt;&gt; allStudent[id].english;}Sau khi đã có hàm này, ta chỉ cần viết hai hàm addNewStudent() và editStudent() rất ngắn gọn. Chú ý editStudent() còn có một đoạn kiểm tra xem mã số học sinh nhập vào có hợp lệ hay không.void addStudent(){    number ++;    inputStudentInfo(number);}void editStudent(){    int id;    cout &lt;&lt; \"Hay nhap ma so hoc sinh: \";    cin &gt;&gt; id;    if (id &lt; 1 || id &gt; number)    {        cout &lt;&lt; \"Ma so hoc sinh khong hop le!\\n\";        return;    }    inputStudentInfo(id);}Xóa thông tin học sinhHàm xóa thông tin học sinh ta viết trong main() là deleteStudent(). Để xóa thông tin học sinh, ta cần phải nhập vào mã số học sinh cần xóa. Đoạn này giống như với editStudent().void deleteStudent(){    int id;    cout &lt;&lt; \"Hay nhap ma so hoc sinh: \";    cin &gt;&gt; id;    if (id &lt; 1 || id &gt; number)    {        cout &lt;&lt; \"Ma so hoc sinh khong hop le!\\n\";        return;    }Khi đã có mã số học sinh cần xóa hợp lệ, ta sẽ xóa thông tin của học sinh đó đi, bằng cách dồn các học sinh ở sau về phía trước, gán đè lên giá trị của người bị xóa.    // Đẩy các học sinh phía sau về đúng chỗ    for (int i = id + 1; i &lt;= number; i ++)        allStudent[i - 1] = allStudent[i];    number --; // Bớt đi một học sinh}Toàn bộ nội dung của hàm deleteStudent() như sauvoid deleteStudent(){    int id;    cout &lt;&lt; \"Hay nhap ma so hoc sinh: \";    cin &gt;&gt; id;    if (id &lt; 1 || id &gt; number)    {        cout &lt;&lt; \"Ma so hoc sinh khong hop le!\\n\";        return;    }    // Đẩy các học sinh phía sau về đúng chỗ    for (int i = id + 1; i &lt;= number; i ++)        allStudent[i - 1] = allStudent[i];    number --; // Bớt đi một học sinh}Ok, chúng ta đã hoàn thành xong việc thêm, sửa và xóa thông tin học sinh. Bài thực hành sẽ tiếp tục ở phần sau, với việc tìm kiếm học sinh theo thông tin, và lưu lại dữ liệu lên file.Phần sau: [C++ Cơ bản] Phần 20: Bài thực hành tổng hợp - Chương trình quản lý học sinh (tiếp)",
              url: "/article/c-co-ban-phan-19-bai-thuc-hanh-tong-hop-chuong-trinh-quan-ly-hoc-sinh"
            }
            ,

            {
              title: "[Lập trình thi đấu cơ bản] Phần 3: Kiểm tra và soát lỗi bài làm",
              author: "Nam Phương Đại Hiệp",
              category: ["article"],
              tag: ["competitive-programming", "cp"],
              content: "Phần trước: [Lập trình thi đấu cơ bản] Phần 2: Giải một bài toán như thế nào?Như đã nói ở phần trước, cho dù bạn có một chiến lược làm bài hiệu quả và hoàn hảo thế nào thì cũng khó có thể tránh khỏi những “bug” trong quá trình code. Vì vậy, việc hạn chế và khắc phục những lỗi trong chương trình là một điều hết sức quan trọng trong lập trình thi đấu. Bài viết này sẽ đề cập tới vấn đề kiểm thử và soát lỗi trong chương trình.Bạn có biết testing là cả một nghệ thuật? Trong nhiều cuộc thi ACM, việc bạn nộp mà không AC sẽ mang đến hậu quả là bạn sẽ bị thua thiệt về penalty. Do đó, nếu không muốn trở thành spammer thì hãy cố gắng hạn chế việc nộp bài càng nhiều càng tốt.Bời vì VNOI đã có một bài hướng dẫn cách viết trình test bài chất lượng là Tự code, tự chấm, tự sướng - Bí kíp thi offline. Nên ở đây, mình sẽ không hướng dẫn lại các bạn cách viết code để test nữa mà sẽ nói về một số nguyên tắc và kinh nghiệm thu thập được trong quá trình “stress testing” của mình.  Đối với những bài tập có dạng “multiple testcases”, tức là một test bao gồm rất nhiều test nhỏ, thì bạn nên tạo một bộ test có nhiều test giống nhau. Nếu như cùng một test giống nhau mà ra nhiều kết quả, thì chứng tỏ việc khởi tạo cho mỗi test của bạn là chưa tốt. Đó là một lỗi hay gặp, tuy nhiên để phát hiện thì không hề là một điều đơn giản. Do đó, hạn chế chúng là một điều cần thiết.  Cố gắng nghĩ ra những test hiểm nhất mà người ra đề có thể cho. Nhất là với những bài ACM, bạn sẽ có lúc rơi vào trường hợp cực kì cay cú khi bài đã pass qua 99 test mà vẫn vướng lại một test. Đó chắc chắn là một test hiểm, kiểu như các trường hợp đơn giản như \\( N = 0 \\), \\( N = 1 \\), là những ý được ẩn trong đề. Hay thậm chí với những bài liên quan đến lí thuyết đồ thị thì mới có những test hiểm hết sức đỉnh cao. Với những bài đó, chỉ cái việc đơn đồ thị hay đa đồ thị cũng là một vấn đề lớn. Cho nên, bạn nên nắm vững chúng nếu không muốn rơi vào những trường hợp khó khăn. Thông thường những trường hợp như vậy sẽ được giải quyết bằng câu lệnh if. Ví dụ như:if (N == 0) {    cout &lt;&lt; \"-1\";    exit(0);}  Luôn thử với test lớn nhất. Hãy cố gắng sinh ra test lớn nhất, để đảm bảo chương trình của bạn luôn đảm bảo mọi yêu cầu về thời gian, bộ nhớ cũng như độ chính xác với test lớn nhất của chương trình.  Các tình huống hiếm gặp. Đôi khi ở một số trang online judge như UVa Online Judge hay Codechef bạn gặp những lỗi khá vô duyên như xuất dữ liệu dư khoảng trắng hay tab gì đấy. Cho nên hay thử tất cả những trường hợp bạn có thể nghĩ ra cho đến khi AC :).  Cuối cùng, có lẽ là trường hợp bất khả kháng. Đó là stress testing. Khi mà bạn đã thử tất cả mọi cách, mọi test có thể nghĩ ra mà bạn vẫn không tìm ra test nào sai cả. Thì bạn hãy tự viết một chương trình bruteforce hay tìm những bài đã AC. Sinh hàng tá test random để so sánh hai chương trình đến khi tìm được test sai thì thôi.",
              url: "/article/lap-trinh-thi-dau-co-ban-phan-3-kiem-tra-va-soat-loi"
            }
            ,

            {
              title: "[C++ Cơ bản] Phần 18: Cấu trúc dữ liệu - struct và class",
              author: "Admin Tổng Quản",
              category: ["article"],
              tag: ["cpp-cơ-bản", "programming"],
              content: "Phần trước: [C++ Cơ bản] Phần 17: Tham chiếu và con trỏ. Tác dụng của con trỏ.Bài toán đặt ra từ bài viết về vòng lặp và mảng, đó là lưu trữ thông tin của cư dân thành phố Hà Nội. Ta có thể thiết kế một vài mảng string name[] - tên, string phoneNumber[] - số điện thoại, string address[] - địa chỉ, vân vân…Vấn đề phát sinh là khi ta cần gán giá trị của một người người vào một biến, ta sẽ phải thực hiện nhiều dòng lệnh gánname[x] = name[y];phoneNumber[x] = phoneNumber[y];address[x] = address[y];...Rất dài và rất dễ gây sai sót trong quá trình viết lệnh. Truyền thông tin của một người vào trong hàm cũng sẽ nảy sinh nhiều phức tạp tương tự.Phương án để giải quyết vấn đề này là tự định nghĩa một kiểu cấu trúc dữ liệu person với khả năng  Lưu trữ các thông tin cá nhân của đối tượng trên biến đó và cho phép truy cập hoặc thay đổi các thông tin.  Dễ dàng gán giá trị vào các biến như các kiểu dữ liệu thông thường.Trong C++, chúng ta có hai cách để tự định nghĩa cấu trúc dữ liệu.structĐể khai báo một kiểu cấu trúc dữ liệu mới với struct, ta sử dụng cú phápstruct tên_của_cấu_trúc{   định nghĩa các biến thành phần và hàm của cấu trúc dữ liệu;} [khai báo biến thuộc cấu trúc dữ liệu này];  Tên của cấu trúc dữ liệu chính là tên của kiểu dữ liệu ta đang tạo ra - giống như int, float là tên của các kiểu dữ liệu nguyên thủy.  Định nghĩa các biến thành phần và hàm giống như ta định nghĩa biến và hàm trong chương trình.  Việc khai báo biến ngay sau khi định nghĩa cấu trúc dữ liệu là không bắt buộc, ta có thể khai báo về sau.Ví dụ: Để tạo cấu trúc dữ liệu person như bài toán yêu cầu ở trênstruct person{    string name, phoneNumber, address;};Sau khi định nghĩa xong kiểu dữ liệu person, ta có thể sử dụng nó như các kiểu dữ liệu thông thường.person peopleOfHanoi[100000];Truy cập vào các biến thành phần của structĐể truy cập vào các biến thành phần của một dữ liệu kiểu struct, ta sử dụng toán tử ..Ví dụ minh họa:#include &lt;iostream&gt;using namespace std;struct person{    string name, phoneNumber, address;};int main(){    person admin;    // Gán giá trị vào biến thành phần    admin.name = \"Admin Tong Quan\";    admin.phoneNumber = \"113\";    admin.address = \"The Internet\";    // In ra giá trị của biến thành phần    cout &lt;&lt; admin.name &lt;&lt; '\\n';    cout &lt;&lt; admin.phoneNumber &lt;&lt; '\\n';    cout &lt;&lt; admin.address &lt;&lt; '\\n';    return 0;}OutputAdmin Tong Quan113The InternetChú ý: C++ chỉ hỗ trợ output cho các kiểu dữ liệu nguyên thủy như int, float, char, vân vân… Muốn có thể output ra kiểu dữ liệu tự tạo, ta cần phải tự viết hàm in ra cho mình, không được sử dụng cout trực tiếp.Hàm trong structGiả sử ta muốn mỗi đối tượng của cấu trúc dữ liệu có khả năng triển khai một hàm printData() có khả năng in các giá trị của cấu trúc dữ liệu đó. Ta có thể định nghĩa hàm ở trong struct như các hàm hay chương trình con bình thường của chương trình.struct people{    string name, phoneNumber, address;    void printAddress()    {        cout &lt;&lt; name &lt;&lt; '\\n' &lt;&lt; phoneNumber &lt;&lt; '\\n' &lt;&lt; address &lt;&lt; '\\n';    }}Khi đó ta chỉ cần truy cập vào hàm printAddress() của mỗi đối tượng kiểu person để in ra dữ liệu của person đó.#include &lt;iostream&gt;using namespace std;struct person{    string name, phoneNumber, address;    void printData()    {        cout &lt;&lt; name &lt;&lt; '\\n' &lt;&lt; phoneNumber &lt;&lt; '\\n' &lt;&lt; address &lt;&lt; '\\n';    }};int main(){    person admin;    // Gán giá trị vào biến thành phần    admin.name = \"Admin Tong Quan\";    admin.phoneNumber = \"113\";    admin.address = \"The Internet\";    // In ra giá trị của biến thành phần    admin.printData();    return 0;}Hàm khởi tạo cấu trúc dữ liệu (constructor)Như trong ví dụ trên, để khởi tạo cả ba giá trị của cấu trúc person, ta cần tới ba lệnh gán giá trị ở bên ngoài. Để thực hiện việc này một cách gọn gàng hơn, ta cần viết hàm khởi tạo cấu trúc dữ liệu.Hàm khởi tạo cấu trúc dữ liệu có cấu trúctên_cấu_trúc_dữ_liệu(các tham số){    nội dung;}Ví dụ: Đối với cấu trúc person như trên, ta cần khởi tạo giá trị của person từ ba string tên, số điện thoại và địa chỉ.#include &lt;iostream&gt;using namespace std;struct person{    string name, phoneNumber, address;    person(string _name, string _phoneNumber, string _address)    {        name = _name;        phoneNumber = _phoneNumber;        address = _address;    }    void printData()    {        cout &lt;&lt; name &lt;&lt; '\\n' &lt;&lt; phoneNumber &lt;&lt; '\\n' &lt;&lt; address &lt;&lt; '\\n';    }};int main(){    person admin = person(\"Admin Tong Quan\", \"113\", \"The Internet\");    // In ra giá trị của biến thành phần    admin.printData();    return 0;}Như ở ví dụ trên, ta có thể nhanh chóng khai báo một giá trị person mới, bằng việc cung cấp 3 giá trị tham số vào hàm khởi tạo.Nếu như hàm khởi tạo không có tham số, nó sẽ được sử dụng như là hàm khởi tạo mặc định của cấu trúc dữ liệu. Khi ta khai báoperson admin;Việc khai báo này cũng tương đương việc gọi lệnhperson admin = person();Con trỏ và cấu trúc dữ liệuNhư các cấu trúc dữ liệu khác, cấu trúc dữ liệu định nghĩa bởi struct cũng được cung cấp cho một ô bộ nhớ, và địa chỉ của ô bộ nhớ này có thể truy cập bằng một biến kiểu con trỏ.Để truy cập vào các biến và hàm của cấu trúc dữ liệu thông qua con trỏ, ta sử dụng toán tử -&gt; thay vì toán tử .. Ví dụ:person admin = person(\"Admin Tong Quan\", \"113\", \"The Internet\");person *pointer = &amp;admin; // Gán địa chỉ bộ nhớ của admin cho pointerpointer-&gt;printData();Hành động này cũng tương tự như việc sử dụng cú pháp(*pointer).printData();Cấp phát bộ nhớ độngTrong các bài viết trước, ta khai báo các biến cần được sử dụng trong chương trình, trước khi bắt đầu chương trình. Điều này xác định số lượng biến có thể được sử dụng trong chương trỉnh.Trong thực tế, có những lúc ta cần phải yêu cầu thêm biến tùy vào hoàn cảnh của chương trình. Bằng cách sử dụng con trỏ, ta có thể yêu cầu tạo thêm biến mới để sử dụng về sau.Ví dụ: Ta cần xây dựng một danh sách int linh động có hai chương trình con sau  put(int x): Chèn một giá trị x vào cuối danh sách.  printAll(): In ra tất cả các giá trị trong danh sách.Ta sẽ xây dựng một cấu trúc danh sách móc nối (Linked List) cho bài toán này: Mỗi một phần tử trong danh sách sẽ lưu trữ hai giá trị: value là giá trị được lưu trữ trong phần tử này, và next là con trỏ tới phần tử tiếp theo. Đối với phần tử cuối cùng của danh sách, next sẽ bằng NULL.struct LinkedListItem{    int value;    LinkedListItem *next;}Chú ý một điều: Các biến dạng con trỏ trong cấu trúc dữ liệu không được khởi tạo trước. Mỗi lần gọi một con trỏ thì một biến mới sẽ được tạo ra, và biến mới đó lại có con trỏ mới, tiếp tục tạo thành vòng vô hạn và gây tràn bộ nhớ. Để phòng tránh việc này, ta cần phải viết hàm khởi tạo cho cấu trúc LinkedListItem.LinkedListItem(){    value = 0;    next = NULL;}Khi ta cần phải chèn thêm giá trị mới vào danh sách, ta bắt đầu từ phần tử đầu tiên, và đi theo next để đi tới phần tử cuối cùng. Tại đây ta cần phải tạo một phần tử LinkedListItem mới, với giá trị value bằng giá trị cần chèn, và gán con trỏ của nó cho next.Để tạo ra một giá trị mới và trả lại con trỏ của nó, ta sử dụng từ khóa new.void put(int x){    if (next != NULL) // Nếu chưa phải phần tử cuối cùng    {        next-&gt;put(x); // Đẩy việc chèn phần tử cho phần tử tiếp theo        return;    }    next = new LinkedListItem();    next-&gt;value = x;}Để in ra tất cả các giá trị trong danh sách, ta cũng bắt đầu đi từ phần tử đầu tiên, in ra value của nó, và di chuyển tiếp tới phần tử tiếp theo trong danh sách.void printAll(){    cout &lt;&lt; value &lt;&lt; '\\n';    if (next != NULL)        next-&gt;printAll();}Ok, hai chương trình con cần thiết đã hoàn thành xong, nhưng giờ lại nảy sinh ra vấn đề: Cả hai chương trình này đều yêu cầu có phần tử đầu tiên. Lúc ban đầu chưa có phần tử nào thì ta làm như thế nào?Giải pháp là ta sử dụng thêm một cấu trúc dữ liệu nữa - LinkedList. Cấu trúc này sẽ lưu trữ con trỏ của phần tử đầu tiên - NULL nếu chưa có phần tử nào. Khi ta cần chèn vào một phần tử, ta sẽ kiểm tra xem phần tử đầu tiên đã có chưa. Nếu chưa có, ta thực hiện gán giá trị cho phần tử đầu tiên. Nếu có rồi, ta sử dụng hàm put() của phần tử này. Tương tự với việc in các phần tử vậy.struct LinkedList{    LinkedListItem *firstItem;    LinkedList()    {        firstItem = NULL;    }    void put(int x)    {        if (firstItem == NULL)        {            firstItem = new LinkedListItem();            firstItem-&gt;value = x;        }        else            firstItem-&gt;put(x);    }    void printAll()    {        if (firstItem != NULL)            firstItem-&gt;printAll();    }};Vậy là cấu trúc LinkedList đã được hoàn thành và có thể đem vào sử dụng#include &lt;iostream&gt;using namespace std;struct LinkedListItem{    int value;    LinkedListItem *next;    LinkedListItem()    {        value = 0;        next = NULL;    }    void put(int x)    {        if (next != NULL) // Nếu chưa phải phần tử cuối cùng        {            next-&gt;put(x); // Đẩy việc chèn phần tử cho phần tử tiếp theo            return;        }        next = new LinkedListItem();        next-&gt;value = x;    }    void printAll()    {        cout &lt;&lt; value &lt;&lt; '\\n';        if (next != NULL)            next-&gt;printAll();    }};struct LinkedList{    LinkedListItem *firstItem;    LinkedList()    {        firstItem = NULL;    }    void put(int x)    {        if (firstItem == NULL)        {            firstItem = new LinkedListItem();            firstItem-&gt;value = x;        }        else            firstItem-&gt;put(x);    }    void printAll()    {        if (firstItem != NULL)            firstItem-&gt;printAll();    }};int main(){    LinkedList list;    list.put(1);    list.put(2);    list.printAll();    list.put(5);    list.printAll();    return 0;}Output12125ClassĐể khai báo cấu trúc với class, ta sử dụng cú phápclass tên_của_class{    định nghĩa các biến và hàm của class;} [Khai báo một số biến kiểu class này];Nó có khác gì so với struct?Thật ra là có, ở một số điểm sau:  Quyền truy cập các biến và hàm của struct mặc định là public - tất cả mọi thứ đều có thể truy cập được. Của class là private - giới hạn trong nội bộ class. Điều này có ý nghĩa gì, ta sẽ học trong các bài sau.  Về mặt ngữ nghĩa của mã nguồn: struct thường được gắn liền với các kiểu dữ liệu Plain Old Data (POD) - kiểu dữ liệu chỉ bao gồm các biến dữ liệu được gom lại trong cùng một cấu trúc. Trong khi đó class được gắn liền với việc lập trình hướng đối tượng và các kiểu dữ liệu phức tạp hơn, có bao gồm các hàm và chương trình con trong đó.class cũng có hàm bên trong cấu trúc dữ liệu, con trỏ, cấp phát bộ nhớ động, tất cả mọi thứ mà struct có. Các template trong thư viện STL của C++ được triển khai như là các class. Class cũng là thuật ngữ trong lập trình hướng đối tượng.Do đó, ở trong các bài viết sau về Lập trình hướng đối tượng với C++, chúng ta sẽ đi sâu hơn về class, và sử dụng class cho mọi trường hợp thay vì struct.Phần sau: [C++ Cơ bản] Phần 19: Bài thực hành tổng hợp - Chương trình quản lý học sinh",
              url: "/article/c-co-ban-phan-18-cau-truc-du-lieu-struct-va-class"
            }
            ,

            {
              title: "[Lập trình thi đấu cơ bản] Phần 3: Testing và Debugging",
              author: "Nam Phương Đại Hiệp",
              category: ["article"],
              tag: ["competitive programing", "cp"],
              content: "Ở phần trước, chúng ta đã bàn về cách để làm sao giải một bài toán cho hợp lí và hiệu quả. Tuy nhiên, như đã nói cho dù bạn có là thần thánh phương nào thì những lỗi trong chương trình mà bạn viết ra là khó có thể tránh khỏi. Vì vậy, ở phần này chúng ta sẽ bàn về cách …",
              url: "/article/lap-trinh-thi-dau-co-ban-phan-3-testing-va-debugging"
            }
            ,

            {
              title: "[C++ Cơ bản] Phần 17: Tham chiếu và con trỏ. Tác dụng của con trỏ.",
              author: "Admin Tổng Quản",
              category: ["article"],
              tag: ["cpp-cơ-bản", "programming"],
              content: "Phần trước: [C++ Cơ bản] Phần 16: Các giá trị kiểu kí tự. Xâu kí tự.Trong bài viết về hàm và chương trình con, chúng ta đã biết tới hai kiểu tham số là tham số truyền biến và tham số truyền con trỏ. Bài viết này sẽ giải thích rõ hơn về hai khái niệm tham chiếu và con trỏ - bản chất của hai loại tham số trên.Định nghĩaCác biến thông thường khi được khai báo sẽ copy giá trị được khởi tạo, và trở thành một biến riêng biệt. Bất cứ hành động nào xảy ra trên biến mới đều không liên quan tới biến cũ nữa. Ví dụ đoạn code sau#include &lt;iostream&gt;using namespace std;int main(){    int a = 10;    int b = a;    b = 20;    cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b;    return 0;}sẽ cho ra output10 20Tham chiếu (reference) là một biến được chỉ định đại diện cho một biến hiện đã tồn tại - toàn bộ các thao tác ta làm với biến mới, thực chất là thực hiện trên biến cũ. Thật lòng mà nói, cách dịch “tham chiếu” khá là tối nghĩa so với từ gốc tiếng Anh, nhưng vì nhiều tài liệu sử dụng cách dịch này nên bài viết sẽ áp dụng đồng bộ.Để khai báo một biến là biến tham chiếu, ta đặt toán tử &amp; trước tên biến khi khai báo. Ví dụint &amp;a = b; /* Biến a là tham chiếu tới biến b */Giả sử ban đầu nếu biến b có giá trị là 10, biến a cũng sẽ có giá trị là 10. Nếu biến a bị gán giá trị 20, giá trị của b cũng trở thành 20.#include &lt;iostream&gt;using namespace std;int main(){    int a = 10;    int &amp;b = a;    b = 20;    cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b;    return 0;}Output20 20Con trỏ (pointer) là biến có kiểu số nguyên thập lục phân, lưu trữ lại địa chỉ ô bộ nhớ của một biến khác.Để khai báo một biến là kiểu con trỏ, ta đặt toán tử * trước tên biến. Để lấy giá trị địa chỉ con trỏ bộ nhớ của một biến, ta đặt toán tử &amp; trước tên biến đó. Ví dụ#include &lt;iostream&gt;using namespace std;int main(){    int a = 10;    int *b = &amp;a;    cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b;    return 0;}Output10 0x6afef8Giá trị thứ hai sẽ khác biệt sau mỗi lần chạy, do chương trình sẽ sử dụng ô nhớ khác nhau cho biến vào các thời điểm khác nhau.Chức năng của biến tham chiếu ta đã thấy trong bài viết về hàm, cũng như trong ví dụ trên - đó là khả năng thực hiện thay đổi trực tiếp lên biến gốc. Bài viết sẽ tập trung hơn tới chức năng của con trỏ bộ nhớ.Thực hiện thay đổi trực tiếp lên ô bộ nhớTa cũng có thể sử dụng con trỏ bộ nhớ để thực hiện thay đổi trực tiếp lên giá trị của biến trong ô nhớ, tương tự như biến tham chiếu. Toán tử * khi được đặt trước một biến dạng con trỏ, sẽ trả lại tham chiếu trực tiếp lên biến của ô nhớ đó, mà ta có thể thực hiện thay đổi lên được#include &lt;iostream&gt;using namespace std;int main(){    int a = 10;    int *b = &amp;a;    *b = 20; // Đặt giá trị của biến trong ô nhớ mà b biểu diễn bằng 20    cout &lt;&lt; a;    return 0;}Output20Truyền mảng vào làm tham số của chương trình con bằng con trỏĐối với một mảng, nếu ta viết tên của mảng đó mà không có ngoặc vuông, nó sẽ trả lại địa chỉ ô nhớ của phần tử đầu tiên.#include &lt;iostream&gt;using namespace std;int a[10];int main(){    cout &lt;&lt; a;    return 0;}Output trả lại sẽ là một giá trị con trỏ.Hãy nhớ lại kiến thức của bài mảng: Các biến trong mảng được lưu trữ tại các địa chỉ ô nhớ liên tiếp, phần tử đầu tiên ở vị trí đầu tiên, phần tử thứ hai ở vị trí thứ hai,… Lợi dụng điều này, ta có thể sử dụng tham số là biến dạng con trỏ, để truyền mảng làm tham số chương trình con.Đối với một biến dạng con trỏ, đặt một giá trị x trong ngoặc vuông phía sau tên biến sẽ trả lại tham chiếu tới biến cách nó x ô nhớ, giống hệt như sử dụng mảng.Ví dụ: Hàm số getMax(int, int*) sau đây nhận hai tham số - giá trị thứ nhất là số lượng phần tử trong mảng, giá trị thứ hai là mảng cần xét - để tìm ra giá trị lớn nhất trong mảng.#include &lt;iostream&gt;using namespace std;int a[] = {1, 2, 3, 4, 5};int getMax(int n, int* a){    int answer = a[1];    for (int i = 2; i &lt;= n; i ++)        if (answer &lt; a[i])            answer = a[i];    return answer;}int main(){    cout &lt;&lt; getMax(5, a);    return 0;}Output5Hãy để ý cách hàm getMax() duyệt qua các phần tử, giống như duyệt qua mảng.Chú ý: Còn nhớ hàm fstream.open() chứ? Tham số đầu tiên - tên file cần mở - là một biến có kiểu dữ liệu con trỏ của biến char (char*), hay nói cách khác là một mảng các phần tử kiểu char - một string. Bài viết trước đã giải thích về cơ chế biểu diễn string bằng mảng char của ngôn ngữ C, bạn có thể tham khảo lại.Cộng trừ lên con trỏBởi vì con trỏ có bản chất là kiểu giá trị số nguyên, nên ta có thể thực hiện phép cộng trừ lên con trỏ tương tự như với số nguyên. Hãy áp dụng các tính chất sắp đặt vị trí ô bộ nhớ của các cấu trúc dữ liệu như mảng để có thể áp dụng hiệu quả nhất.Con trỏ NULLNULL là một giá trị con trỏ hằng số đặc biệt - nó có nghĩa là con trỏ hiện thời đang không được chỉ tới đâu cả. Ta có thể gán giá trị này cho các biến kiểu con trỏ. Ví dụ:char *pointer = NULL;",
              url: "/article/c-co-ban-phan-17-tham-chieu-va-con-tro-tac-dung-cua-con-tro"
            }
            ,

            {
              title: "[SPOJ] BYTESH1 - Filchs Dilemna",
              author: "houtaru",
              category: ["spoj"],
              tag: ["spoj", "dp"],
              content: "Link đề bài : http://vnoi.info/problems/show/BYTESH1/Đề bài :Cho 2 loại gạch : 1x2, hình chữ L (gồm 3 ô vuông). đếm số cách xếp gạch để lấp đầy hình chữ nhật 2xN ô.Input :  Dòng đầu là số T (1 &lt;= T &lt;= 100)  T dòng tiếp theo gồm 1 số N (1 &lt;= N &lt;= 10 ^ 6)Output :  Gồm T dòng : mỗi dòng là kết quả của bài toán lấy phần dư cho 10^4.Solution : http://kaitect.com/53CCode : http://kaitect.com/54H",
              url: "/spoj/spoj-bytesh1-filchs-dilemna"
            }
            ,

            {
              title: "[Lập trình thi đấu cơ bản] Phần 2: Giải một bài toán như thế nào?",
              author: "Nam Phương Đại Hiệp",
              category: ["article"],
              tag: ["competive-programing", "cp"],
              content: "Phần trước: [Lập trình thi đấu cơ bản] Phần 1: Học như thế nào để thi đấu?Như chúng ta đã biết, mục tiêu của lập trình thi đấu chính là giải những bài toán được đưa ra một cách hoàn hảo nhất. Vì vậy hôm nay mình sẽ nói về những nguyên tắc cơ bản khi giải một bài toán trong lập trình thi đấu.Hiểu và nắm rõ bài toán được đưa raThông thường, một bài toán trong lập trình sẽ được chia ra thành một số phần như sau:  Background: Đây thường là một đoạn văn được đưa vào để cho bài toán thêm màu mè và cũng thường chả liên quan tới bài toán, nhưng đôi khi chúng lại là nguyên nhân chính khiến cho người đọc bị nhiễu thông tin, hay hiểu sai đề. Do đó, bạn cần tỉnh táo để tóm tắt và nắm bắt chính xác cái mà đề bài yêu cầu ta phải làm.  Yêu cầu đề bài: Đây là phần chúng ta nên tập trung quan tâm nhiều nhất. Bời vì nó chính là cái chúng ta cần giải quyết trong những phút tiếp theo. Thông thường đề bài sẽ chia phần này với phần background ở trên thành những phần riêng biệt để thí sinh dễ phân biệt. Tuy nhiên, người ta cũng có thể đưa ra yêu cầu một cách gián tiếp. Khi đó, những yêu cầu được ẩn dưới câu chuyện được đưa ra và ta phải tinh ý để không bỏ sót một chi tiết nào trong đó.  Dữ liệu vào/ra: Là phần rất quan trọng. Chúng cho ta biết dữ liệu vào được bố trí như thế nào và phải xuất ra kết quả ra sao mới đúng. Và thêm nữa đó là giới hạn hoặc mô tả các subtask của dữ liệu vào để ta biết cần phải giải quyết bằng cách nào là hợp lí.  Ví dụ: Đây sẽ là phần ta hay nghiên cứu nhất trên đề. Nó là minh họa cho bài toán, cho yêu cầu đặt ra. Cho nên, hiểu rõ các ví dụ, cũng như giải thích được chúng là một lợi thế rất lớn.Bạn có thể xem một bài toán mẫu ở đây: http://vn.spoj.com/problems/QBSELECT/Triển khai các ý tưởngCông việc tiếp theo sau khi đã hiểu được bài toán muốn nói gì chắc chắn là phải bắt tay vào việc nghĩ bài.Đầu tiên, ta phải nhận xét được bài toán đề ra có những đặc điểm gì và chia chúng ra thành những bài toán nhỏ. Giai đoạn này phần nhiều dựa vào kinh nghiệm cũng như sự nhạy bén của bạn. Vì suy nghĩ đúng hướng thì sẽ tiết kiệm được rất nhiều thời gian cũng như trở ngại khi bắt đầu code. Do đó, bạn nên cố gắng làm càng nhiều bài tập càng tốt và rút được càng nhiều kinh nghiệm từ chúng.Một điều phải nhớ, đó là thuật toán bạn đưa ra phải chạy tốt trong thời gian cho phép. Vì máy tính hiện đại có thể chạy được tầm khoảng 100000000 (\\( 10 ^ 8 \\)) phép tính trên một giây, nên những thuật toán \\( O(N^2) \\) với \\( N \\) khoảng 1000000 (\\( 10 ^ 5 \\)) là không chấp nhận được, phải tìm thuật toán có thời gian chạy từ \\( O(NlogN) \\) trở xuống là hợp lí. Tương tự như vậy, hãy ước lượng cho đúng thuật toán của mình để có thể ăn được thật nhiều test. Vì độ phức tạp tính toán là một vấn đề phức tạp, nên chúng ta sẽ không bàn hơn ở đây.CodingVâng, đây có lẽ vừa là phần hứng thú nhất cũng là phần khó chịu nhất. Bạn phải code thật không ngoan và khoa học nếu không muốn dính phải bug và ngồi loay hoay để debug. Tuy nhiên nói vậy chứ trong khi code khó lòng có ai đủ tỉnh táo để làm một phát ăn ngay được. Do đó, có một số số nguyên tắc để giúp code của bạn trong sáng và dễ “gỡ bug” hơn:  Đặt tên biến, function theo một hệ thống nhất định: Hãy cố gắng để quản lí các biến, function của mình một cách hiệu quả. Sao cho để nhìn vào chúng, bạn biết được chúng có chức năng gì cũng như giá trị của nó. Đừng bao giờ đặt tên xong mà chúng ta không biết chúng là gì. Điều đó thật sự tệ hại.  Hiểu rõ những gì mình đã code, đang code và sắp code. Ví dụ, khi đang code function solve() thì hãy suy nghĩ về function output(). Phải làm sao để chúng đồng nhất và kết quả được lưu như thế nào để lúc xuất ra được hiệu quả.  Hiểu rõ những cấu trúc mình đang sử dụng: Điều này khá quan trọng nhất là với những bạn hay code bằng C++. C++ cung cấp khá nhiều cấu trúc dữ liệu trừu tượng, do đó đôi khi lúc sử dụng chúng chúng ta tạo ra bug mà không hề hay biết. Và những cấu trúc đó thì lại vô cùng khó debug. Nên tốt nhất ta phải hiều những gì ta đang làm là chắc ăn nhất.  Sử dụng comment hợp lí: Comment là một công cụ giúp người lập trình chú thích lại những dòng code của mình. Vì vậy, hãy sử dụng chúng hợp lí thay vì lạm dụng chúng.  Phong cách code khoa học: Không cần phải nói nhiều, hãy nhìn hai đoạn code có cùng một chức năng dưới đây thì các bạn sẽ hiểu vì sao cần có điều này.int n, x, ans = 0;int main() {  freopen(\"in.txt\", \"r\", stdin);    cin &gt;&gt; n;  for (int i = 1; i &lt;= n; i++)    for (int j = 1; j &lt;= n; j++)      cin &gt;&gt; x, ans = max(x, ans);    cout &lt;&lt; ans;}int n, a[100][100], ans = 0;//global variableint main() {  freopen(\"in.txt\",\"r\",stdin); cin &gt;&gt; n; //input data  for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) cin&gt;&gt;a[i][j];//input data, too  for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++)//iterate through matrix  if(ans&lt;a[i][j]) ans=a[i][j]; cout&lt;&lt;ans;//find max: if ans less than a[i][j], ans will be a[i][j].}",
              url: "/article/lap-trinh-thi-dau-co-ban-phan-2-giai-mot-bai-toan-nhu-the-nao"
            }
            ,

            {
              title: "Làm sao để không thi tốt mà vẫn sống",
              author: "Admin Tổng Quản",
              category: ["article"],
              tag: ["programming", "kinh-nghiem-song"],
              content: "Bài viết gốc: How to not perform well on life and survive được viết bởi I_love_Hoang_Yen, nick Codeforces của anh Thanh Trung Nguyen, founder của cộng đồng Lập trình VNOI, hay còn được mọi người biết tới với biệt danh RR. Bản dịch đã được sự cho phép của anh Thanh Trung Nguyen và của bạn Phạm Cao Nguyên (natsukagami).Ngày hôm qua đọc blog của ErdemKizez, mình lại nhớ về mình ngày trước. Mình không thể nào ngủ được khi nghĩ về những thất bại của mình trong thi cử và trong cuộc sống. Nhưng mình nghĩ mình đã sống sót qua cái tao đoạn ấy, nên mình quyết định viết bài blog này…BackstoryKhi mình bắt đầu đi học (hồi 5-6 tuổi), mình khác biệt so với lũ trẻ xung quanh: mình làm mấy trò dị dị như nhớ số điện thoại hay là làm toán… Cộng thêm một việc nữa, ấy là mình là thằng bé con nhất trong lớp. Vậy nên tất nhiên mình trở thành mục tiêu của bọn bắt nạt. Mình vẫn nhớ cái cảm giác tệ hại khi bị bắt nạt, và còn tệ hơn nữa khi nghe giáo viên nói với mẹ mình về chuyện ấy: “Nhìn con bé con đáng yêu ấy xem, làm sao mà con bé ấy có thể bắt nạt ai được chứ.”Lên lớp 2, có một chuyện thần kì đã xảy ra: mình được điểm cao nhất ở trong lớp. Tự nhiên chuyện bắt nạt dừng lại hẳn. Mình nhận ra rằng khi mình trở thành học sinh số một ở trong lớp và được thầy cô để mắt tới, mình sẽ không còn bị bắt nạt nữa. Thế là mình quyết định sẽ luôn trở thành số một ở trong lớp… Mọi chuyện diễn ra được vài năm cho tới khi có môn Lịch sử và Địa lý.Rồi mình lên lớp 8, nhà trường một số học sinh giỏi để tham dự cuộc thi Tin cấp Thành phố. Thế là bọn mình được dạy code bằng Pascal. Mình như được khai sáng vậy: “Wow, mình có thể làm cho máy tính chạy chương trình, rồi làm mấy cái input output ngầu ngầu như kiểu ASCII Art vậy :-O”. Thế là mình bắt đầu luyện code xuyên ngày đên, và giành được một số giải thưởng trong cuộc thi cấp Thành phố.Cấp 3 và kì thi Quốc giaMình đỗ được vào một trường Trung học Phổ thông tốt. Bài thi đầu vào lấy hai môn Toán và Văn học, nhưng mình vẫn đỗ được! Nếu xét về mặt Lập trình thi đấu, trường của mình có thể gọi là trường tốt nhất ở Việt Nam, vì từ đây nhà trường đã đào tạo được nhiều học sinh giành huy chương vàng IOI như ll931110, skyvn97, natsukagami, vân vân…Mình vẫn code suốt ngày khi lên cấp 3, nhưng giờ mình đã có nhiều bạn bè từ các đội tuyển Tin Quốc gia khác để nói chuyện về lập trình và thuật toán. Hồi đó mọi người còn xài Yahoo ấy.Bọn mình cũng có một OJ tiếng Việt là VOJ. Vì mình code suốt ngày nên mình trở thành số một ở khối 11 lúc đó và trở nên khá nổi tiếng. Mọi người bắt đầu nói rằng mình sẽ đi IOI. Mình cũng đứng ở top 4 trong kì thi Quốc gia Vòng 1, đứng đầu nhiều kì thi online khác, nên mình cũng tự tin lắm.Trước khi kể chuyện tiếp, mình sẽ giải thích thêm về cơ chế thi chọn đội tuyển Quốc tế của Việt Nam vào thời đó (về sau đã có sự thay đổi). Có hai vòng thi:  Vòng 1 là kì thi Quốc gia. Top 30 người đứng đầu sẽ thi vòng 2.          1 ngày thi, 3 tiếng      3 bài      Không có chấm thử      Không có time limit. Bạn phải tự đoán xem code của bạn có đủ nhanh hay không.      Điểm được tính theo số test bạn làm đúng. Chú ý là cách tính điểm này khác với IOI. Nếu bạn cày tham lam và đúng được 99% test, bạn sẽ được 99% số điểm.        Vòng 2 là vòng chọn đội đi thi Quốc tế (IOI). Top 4 sẽ được đi thi IOI.          2 ngày thi, 5 tiếng mỗi ngày      3 bài mỗi ngày      Không có chấm thử      Tất nhiên là lại không có time limit rồi. Bạn phải tự đoán xem code của bạn có đủ nhanh hay không.      Điểm được tính theo số lượng test đúng.      Ở ngày thi đầu tiên của vòng 2, mình đọc đề bài 1 rất nhanh và phát hiện ra đây chỉ là một bài toán Dijkstra đơn giản. Thế là mình đâm đầu vào code ngay (sau đó thằng ngồi bên cạnh mình có đăng online như thế này “Vãi chưởng, hôm nay ngồi cạnh phải cái thằng code nhanh và khỏe ngay từ lúc đầu, sợ vãi.”). Sau khi mình code xong rồi, tất nhiên là ra kết quả sai. Mình vẽ đồ thị ra giấy mà vẫn không hiểu tại sao lại có thể ra được cái output kia. Có một thằng ở trong phòng thi hỏi giám thị xem liệu đường đi có thể thăm lại đỉnh xuất phát và đỉnh kết thúc lần nữa không. Giám thị không biết, nhưng mình thì kiểu “WTF?”, rồi nhận ra rằng nếu như đường đi có thể thăm lại đỉnh xuất phát, thì có thể cho ra output đúng. Nhưng mình lại không biết xử lý đỉnh kết thúc như thế nào. Thế là bài làm của mình thành ra đánh cược 50:50. Hai bài còn lại thì khá là dễ và không có gì đặc biệt. Sau khi thi xong, mình hỏi lại các bạn tham dự thì có vẻ mình là người duy nhất không xử lý thăm lại đỉnh kết thúc. F*ck.Thế là ngày hai mình bị tâm lý, rồi 3 bài đều khó hơn nhiều ngày thứ nhất. Mình giải được bài thứ nhất sau 1 tiếng đồng hồ. Sau khi đọc hai bài còn lại, mình nhận xét rằng bài thứ 3 là không thể làm được. Thế là mình dành cả 4 tiếng để code bài 2. Bài quá rắc rồi, code của mình thì đầy bug. Thi xong mình lại hỏi mọi người, và tất cả mọi người đều giải được bài 3 (sau khi giản lược đi thì bài toán trở thành một bài cây DFS đơn giản) và không có ai giải được bài 2.Và thế là tất nhiên, mình không được đi IOI. Nhưng mình vẫn còn 1 năm nữa.Lớp 12Năm này mình còn thảm hơn năm trước.Mọi chuyện bắt đầu từ vòng 1. Mình làm xong hai bài đầu rất nhanh và có nhiều thời gian cho bài 3. Mình nghĩ rất là lâu về bài toán DP chữ số này và cảm giác thấy nó rất lạ lùng. Nếu như bạn đọc được tiếng Việt, đây chính là bài toán đó. Mình không giải được bài này, và cuối cùng phát hiện ra 9 người đã làm được và có điểm tuyệt đối. Đang hoảng loạn thì mình nhận ra bài 2 mình còn bị tràn số nguyên nữa.Nhưng mà rồi cuối cùng mình vẫn gặp may, là người đứng thứ 30 vào được vòng 2. (Có tầm khoảng 10 người cùng điểm với mình, nên mình thật ra ở vị trí tầm 20-30).Ở ngày thi đầu tiên, có 3 bài toán khá là dễ. Bài thứ hai có số lượng phép tính vào khoảng \\( 10 ^ 9 \\) và chạy phải mất 5s, nên mình dành rất nhiều thời gian tối ưu hóa code ở đây (nhớ rằng là bọn mình không biết time limit là bao nhiêu). Cuối cùng mình biết được là người ta đã đặt time limit của bài này thành 10s, nên không có ai bị TLE cả. Nhưng bài thứ nhất thì bị đặt vào tầm 0.5s nên tất cả mọi người đều bị TLE, trừ một hai bạn sử dụng heap thay vì segment tree: cùng độ phức tạp nhưng hằng số thấp hơn một chút.Vào ngày thi thứ hai, mình nghĩ rằng vì mọi người đều điểm sàn sàn nhau sau ngày một rồi, nên mình phải cố để giải được hơn mọi người một bài trong ngày hôm nay. Rồi mình nghĩ mình lại gặp may mắn khi mình đọc bài thứ nhất của ngày hai: bài này có vẻ giống như một bài trên VOJ mà chỉ có mình giải được trước đó. (Đối với các bạn đọc người Việt, đó chính là bài này). Mình biết rằng ở trong bài tập này thì đồ thị là DAG chứ không phải là cây, và hàm chí phí là max thay vì là sum, nhưng mình nghĩ rằng mình có thể chỉnh sửa lại thuật một chút là có thể dùng được cho bài này. Gần 3,5 tiếng sau, mình vẫn không có thuật toán chạy được. Mình bắt đầu cảm thấy sợ hãi và chuyển sang hai bài còn lại. Bài thứ hai có vẻ là không khả thi, còn bài thứ 3 có vẻ khá là rõ ràng nhưng khó cài đặt, nên mình bắt đầu triển khai bài này. Mình code kịp thời gian còn lại, nhưng lại không có thời gian để test (và contest này không có chấm thử). Mình tin rằng lúc đó code của mình có rất nhiều bug. Sau khi thi xong, mình biết được là không có ai giải được bài 1 và 2. Tất cả mọi người giải được bài 3, một số thì viết solution cho các trường hợp nhỏ của bài 2. Không ai đụng tới bài 1 cả.Và thế là mình lại trượt IOI, và tất cả đều là lỗi của mình. Lập trình là thứ duy nhất mình giỏi, là thứ duy nhất khiến mình hạnh phúc, và mình đã thất bại.ACM ở trường đại họcMình học đại học tại trường NTU ở Singapore. ktuan cũng học ở đây. ktuan là huyền thoại trong giới Lập trình thi đấu ở Việt Nam: người Việt Nam duy nhất đạt được nick đỏ (mọi người đang ở rating tầm 2500 thì anh ấy đã đạt tới trên 3000 rồi), người Việt Nam duy nhất từng đi Google Code Jam Final tới vài lần, và về nhì ở Facebook Hacker Cup Finals.Dù sao thì, một hai tháng trước khi mình nhập học, anh ktuan có hỏi mình xem liệu mình có muốn tham dự đội ACM ICPC của anh ấy không. Anh ấy rất nghiêm túc về chuyện giành được huy chương ICPC nên muốn bắt đầu training ngay lập tức. Mình vừa mới thất bại trong kì thi chọn học sinh thi IOI, nên mình muốn nghỉ ngơi và từ chối lời đề nghị của anh ấy. Tất nhiên, đấy là cái “không” ngu nhất của mình và mình vẫn còn hối hận tới tận ngày hôm nay.Đội của ktuan chỉ về thứ #17 năm đó.Năm tiếp theo mình tham dự ICPC WF với người bạn thân nhất của mình là ConanKudo, cho dù mình bị dính bug ở vòng Regional khi khai báo mảng: mình tính nhầm 20 * 30 = 60, nên mảng của mình bị quá bé. Ở vòng WF mình rất sợ bị dính bug ngu và sai thuật toán thêm nữa. Nhưng tất nhiên ở vòng này mình vẫn dính phải nhiều lỗi sai, bao gồm: hiểu sai đề, tràn số nguyên, cài đặt \\( O(2N * N ^ 2) \\) thay vì \\( O(2N * N) \\) và bị TLE, tối ưu hóa sai và bị WA thêm. Tất cả chỗ sai đó, chỉ trong bài dễ nhất của contest. Bạn có thể xem mình đã bị dính bao nhiêu WA ở bài C tại đây: Bảng điểm World Final 2012. Nhìn vào top 20 và bạn sẽ nhanh chóng tìm ra người bị dính +7. Các thành viên trong đội mình cũng không thi tốt trong ngày hôm dó và bọn mình chỉ có thể giải được 3 bài dễ (B, C, D) sau 3 tiếng thi đấu. Mình cảm thấy tuyệt vọng tới phát khóc - bọn mình tới tận vòng WF để mang huy chương về, và giờ thì mình làm mọi thứ ra thế này đây.Thật thần kì là ConnanKudo đã giúp mình bình tĩnh lại và bọn mình giải được thêm 3 bài nữa trong 1,5 tiếng tiếp theo. “OMG có thể bọn mình giải được thêm 1 bài nữa là sẽ được huy chương!”. Nhưng bọn mình không có đủ thời gian để cài đặt bài implementation I và chỉ có một số ý tưởng cho bài A. Bọn mình quyết định code A luôn, thay những cái chỗ mình không thể giải được bằng sinh random và duyệt cận. Và tất nhiên là bọn mình không giải được bài đó.Một lần nữa mình lại cảm thấy thật tồi tệ. Tới thời điểm hiện tại mình đã thất bại ở mọi thứ: không được đi IOI, không được huy chương ở ICPC WF.Rồi vài tháng sau bạn gái đầu tiên chia tay mình.Mình không thể chịu đựng nổi được. Trong vài tháng trời mình cảm thấy mọi thứ như địa ngục. mình cố gắng không để cảm xúc ảnh hưởng tới cuộc sống, nhưng nhiều lúc kể cả mình cũng nhận ra mình đang cư xử như thằng điên. Năm đó mình đi thi Regional ACM cùng với một thằng bạn nữa là technolt, và tất nhiên mình lại tạch Regional. Thế là cộng thêm với tình hình tâm lý của mình, mình phá hỏng mất tình bạn với technolt và nhiều người nữa. Lúc đó mình cảm giác như mình chẳng có ai làm bạn vậy. Có một thời gian dài mình ngủ tới 1 hay 2 giờ chiều, đi như một con zombie ra ăn trưa, về nhà, hầu như chả làm gì, đi ăn tối, lại hầu như chả làm gì tới 4 giờ sáng.Ở tuần cuối cùng của tháng 11 năm 2012, mình cảm giác rằng đời mình đã chạm tới đáy. Thật sự rất thảm não. Nhưng không còn đường nào để đời mình trở nên tệ hơn nữa, nên mình nghĩ rằng có thể nó sẽ bắt đầu tốt lên chăng.Mình bắt đầu hẹn hò với Hoang Yen từ đầu năm 2013 và điều này đã làm thay đổi cuộc đời mình. Nhưng mỗi lần đăng nhập vào Codeforces, mình lại nhớ lại tất cả những thất bại của mình, nên vào một lúc nào đó tầm giữa năm 2013 mình quyết định rằng mình ghét tài khoản cũ R_R_ tới nỗi mình quyết định lập ra tài khoản mới này. (Mình biết là rất sai trái khi có 2 tài khoản, và mình vẫn dùng cả hai lúc này lúc khác, nên mình vẫn cảm thấy rất tệ.)Kì thi ACM cuốiVào một lúc nào đó giữa dòng đời xô đẩy, flashmt có nói với mình rằng một đội mà không thể thắng được vòng Regional không nên hy vọng tới huy chương ở ICPC WF. Điều đó khá là đúng và đội mình năm 2012 yếu tới mức bọn mình là đội cuối cùng vào được vòng WF ở khu vực. Nên mình quyết định sẽ tham dự ICPC WF một lần cuối với flashmt.Mình lại quay lại luyện tập, nhưng có một vấn đề lớn: flashmt và mình học ở trường đại học khác nhau. Nên mình quyết định mình sẽ học bán thời gian ở NUS (National Unviersity of Singapore) để có thể thi đấu một lần cuối với flashmt. Bọn mình tìm được thêm một người từng giành huy chương IMO vào đội và tiến tới WF.Mình luyện tập ròng rã trong hai năm cùng với flashmt dưới dự chỉ dạy của cao thủ lập trình thi đấu giỏi nhất Việt Nam hiện giờ là RR_PPAP. Mình lại tìm lại được tình yêu với contest thêm lần nữa. Tất nhiên, bọn mình không được huy chương ACM ICPC WF, nhưng mình cảm thấy nó cũng OK. Hai năm rèn luyện đã dạy mình nhiều thứ, bao gồm cả việc đối mặt với thất bại. Mình nhận ra rằng quãng thời gian luyện tập cho kì thi đem lại nhiều niềm vui hơn so với huy chương.Giờ đây mình không còn tham gia contest nữa - Mình sẽ làm đám cưới cuối năm nay (“Hú hú” - người dịch) nên mình lúc nào cũng bận rộn. Nhưng mình đã bị mất rank đỏ trong contest vừa rồi và mình nhất định phải quay lại để lấy lại nó. Contest đã trở thành một phần không thể thiếu trong cuộc đời mình rồi.Bonus: Comment của natsukagamiMình sẽ không viết cái comment này như là một lời hồi đáp cho bài viết của anh I_love_Hoang_Yen, nhưng là để bổ sung thêm cho bài viết của anh ấy, dưới góc nhìn của mình. Mình sẽ gọi anh ấy là RR (biệt danh của ảnh, anh ấy dùng ở mọi nơi, tất nhiên là trừ Codeforces rồi…).Từ những câu chuyện mà bọn mình (các thành viên nhỏ tuổi hơn trong đội) đã dành nhiều đêm nghe anh kể trên Discord (yeah, bọn mình cũng có cả server Discord nữa), mình cho là anh ấy đã quên kể câu chuyện về RR_PPAP, một người bạn cực kì thân của anh ấy. Chắc chắn bạn cũng có thể thấy điều đó qua cái username rồi. Nhưng quan trọng hơn, RR_PPAP (đúng như qua lời kể của RR) là người đã đánh thức anh ấy khỏi những thất bại ở vòng chọn học sinh đi thi IOI hay ở vòng thi ACM WF lần đầu tiên. RR_PPAP, một con người kì lạ học môn Toán tìm tới Lập trình Thi đấu chỉ đề giải mấy bài toán khó cho vui, đã thay đổi cách suy nghĩ của RR về việc luyện tập để phát triển trong bộ môn này. Trước đó, RR (và chắc là nhiều học sinh trong cộng đồng Lập trình Thi đấu Việt Nam hồi ấy) chỉ muốn nhắm tới việc giải hết tất cả các bài tập trên VOJ. Tất nhiên là khi mà các bài khó đã hết dần, để đứng đầu tiếp thì phải làm các bài tập dễ và nhàm hơn. Đây là một sai lầm mà tất cả mọi người đều mắc phải, thay vì tiếp tục kiếm tìm các bài tập hay. RR lúc nào cũng cảnh báo bọn mình về việc này - về cách mà anh ấy tập trung quá nhiều vào code và code thay vì giải những bài toán thật sự yêu cầu suy nghĩ thật sự.Đáng buồn là khi anh ấy nhận ra sai lầm của mình, cơ hội IOI của anh ấy đã không còn nữa, và anh giờ chỉ còn kì thi ACM-ICPC cuối cùng, và rồi câu chuyện tiếp tục giống như mọi người đã biết. Nhưng như là một người đàn anh, anh ấy luôn giúp đỡ các khóa dưới không đi theo vết xe đổ của mình. Mình cho rằng những huy chương vàng IOI mà Việt Nam đã giành được trong (ít nhất là) hai năm vừa qua, phần nào là nhờ những bài học của anh RR đã in sâu trong trí óc bọn mình. Mình cho rằng đây là một điều rất quý giá, khi bạn thất bại thì bạn nên biết là vì sao, và kể cả nếu như bạn không còn cơ hội để sửa đổi, bạn vẫn có nghĩa vụ phải giúp những người khác không đi vào cùng vết xe đổ của bạn nữa.Nhưng câu chuyện của anh RR không kết thúc ở đây. “Contest đã trở thành một phần không thể thiếu trong cuộc đời mình rồi.” - câu nói đó còn có ý nghĩa hơn khi bạn nhìn vào những gì mà RR đã làm cho cộng đồng lập trình thi đấu của Việt Nam. Anh ấy xây dựng nên forum VNOI dành cho dân lập trình thi đấu của Việt Nam - nhưng mà người ta không thích forum nữa, nên là trang dừng hoạt động chỉ sau vài tháng. Không chịu bỏ cuộc, anh ấy lập ra và tổ chức nhóm VNOI trên Facebook - một nơi “hợp thời” hơn chăng? - và biến nó thành một cộng đồng chia sẻ nổi tiếng. RR cũng là người xây dựng nên VNOI Wiki - trang web cung cấp các bản dịch và bài viết về giải thuật, cấu trúc dữ liệu và chiến lược thi đấu bằng tiếng Việt. Với những người không có vốn tiếng Anh dày dặn (mà phần lớn học sinh Việt Nam thì không có vốn tiếng Anh dày dặn), đây là nguồn thông tin tuyệt vời nhất để có thể bắt đầu sự nghiệp thi đấu. Trong một vài năm qua, mình cho rằng cộng đồng ở Việt Nam đã hoàn toàn thay đổi - không còn là một nhóm thi đua trên VOJ nữa, mà là một ngôi nhà lớn nơi mọi người chia sẻ và giảng dạy lẫn nhau, như một gia đình.“Làm sao để không thi tốt mà vẫn sống”? Mình muốn đổi tên thành Làm sao để không thi tốt mà vẫn sống một cách BADASS. RR lúc nào cũng nói là anh ấy muốn thay đổi thế giới, thì đó, mình thấy anh ấy làm khá được mà.",
              url: "/article/lam-sao-de-khong-thi-tot-ma-van-song"
            }
            ,

            {
              title: "[C++ Cơ bản] Phần 16: Các giá trị kiểu kí tự. Xâu kí tự.",
              author: "Admin Tổng Quản",
              category: ["article"],
              tag: ["cpp-cơ-bản", "programming"],
              content: "Phần trước: [C++ Cơ bản] Phần 15: Các giá trị kiểu số. Thư viện toán học cmath.Biểu diễn giá trị kiểu charCác giá trị kiểu char sẽ được đặt trong dấu ngoặc đơn ''. Nếu như giá trị kiểu char có tiền tố L, giá trị đó thuộc kiểu wchar_t. Nếu không có thì giá trị mặc định thuộc kiểu char.Bên trong ngoặc đơn có thể là kí tự được biểu diễn (ví dụ 'x'), một kí tự đặc biệt (ví dụ '\\n'), hoặc một kí tự thuộc chuẩn UCS (mà bạn tạm thời chưa cần phải quan tâm vội).Kí tự đặc biệtMuốn thể hiện kí tự thường thì sử dụng ''. Vậy nếu muốn thể hiện kí tự ngoặc đơn ' thì làm như thế nào?Để thể hiện một số kí tự đặc biệt, ta sử dụng escape sequence - dịch thô ra là “dãy kí tự thoát”, nhưng ở đây sẽ sử dụng cách gọi gốc. Escape sequence bắt đầu bằng kí tự \\, tiếp theo là một hoặc nhiều kí tự khác. Các escape sequence mang ý nghĩa đặc biệt.Ví dụ cho một số escape sequence:            Escape sequence        Ý nghĩa                \\\\        Kí tự \\                \\'        Kí tự ngoặc đơn '                \\\"        Kí tự ngoặc kép \"                \\?        Dấu hỏi ?                \\n        Kí tự xuống dòng                \\b        Backspace (Kí tự xóa)    endl và '\\n'“Khoan khoan khoan, sao lại có thêm một kí tự xuống dòng ở kia?”Tuy cùng có khả năng xuống dòng cho output, tuy nhiên endl và '\\n' lại có chức năng khác nhau.endl khi được đẩy vào output sẽ output ra kí tự xuống dòng ('\\n') và giải phóng buffer (flush).'\\n' thì chỉ là kí tự xuống dòng.Trong lập trình thi đấu, việc flush buffer nhiều cũng sẽ làm giảm tốc độ của chương trình đi. Vậy nên đối với các bạn tham gia lập trình thi đấu, mình khuyến cáo sử dụng '\\n' thay cho endl.Ví dụ:#include &lt;iostream&gt;using namespace std;int main(){    cout &lt;&lt; 10 &lt;&lt; '\\n' &lt;&lt; 20;    return 0;}Output1020StringString hay còn gọi là xâu kí tự, chuỗi kí tự, vân vân… là một tập hợp kí tự. Chúng hình thành nên câu, từ, đoạn văn, vân vân…Để biểu diễn một string, ta đặt một chuỗi kí tự trong ngoặc kép \"\". Dòng chữ \"Hello world!\" mặc định của chương trình CodeBlocks cũng là một string.C++ hỗ trợ hai phương pháp biểu diễn dữ liệu string - phương pháp biểu diễn bằng mảng char của C, và class string mới trong C++.Phương pháp mảng charNgôn ngữ C sử dụng mảng các giá trị kiểu char để biểu diễn một string. Mảng này bao gồm các kí tự của string, cộng thêm với một kí tự kết thúc null '\\0'.Ví dụ: Ta có thể khai báo string hello như sauchar hello[] = \"Hello World\";Việc khai báo này cũng tương đương với đoạn code sau:char hello[] = {'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd', '\\0'};Ta có thể in ra string hello bằng các lệnh in dữ liệu thông thường.cout &lt;&lt; hello;C++ cung cấp thư viện cstring để thực hiện các thao tác phức tạp hơn với kiểu dữ liệu string được biểu diễn bằng mảng char. Một số hàm quan trọng của thư viện này là:            Hàm        Chức năng                strcpy(s1, s2)        Gán giá trị của string s2 cho s1                strcat(s1, s2)        Gắn string s2 vào cuối s1                strlen(s1)        Trả về độ dài của string s1                strcmp(s1, s2)         Trả về 0 nếu string s1 bằng s2. Trả về một giá trị số nguyên bé hơn 0 nếu s1 nhỏ hơn s2, và lớn hơn 0 nếu s1 lớn hơn s2.                strchr(s1, ch)        Trả lại con trỏ bộ nhớ của vị trí đầu tiên trong string s1 có sự xuất hiện của kí tự ch                strstr(s1, s2)        Trả lại con trỏ bộ nhớ của vị trí đầu tiên trong string s1 có sự xuất hiện của string s2    Chú ý: Một string s1 được gọi là bé hơn string s2, nếu như kí tự đầu tiên khác nhau giữa hai string từ trái qua ở string s1 có giá trị nhỏ hơn ở string s2 - hiểu nôm na thì s1 có thứ tự trong từ điển đứng trước s2.Ví dụ:  String \"abcabc\" có thứ tự từ điển đứng trước \"acb\"  String \"abc\" có thứ tự từ điển đứng trước \"abcabc\" Chi tiết đầy đủ về các hàm của thư viện này có thể được tìm thấy ở đây.Class stringC++ cũng cung cấp class/kiểu dữ liệu string để quản lý xâu kí tự. Để sử dụng class này, ta cần phải khai báo thư viện string.Ưu điểm của class string là khả năng sử dụng các toán tử - ta có thể sử dụng toán tử + để ghép hai string lại với nhau, hay sử dụng các toán tử so sánh để so sánh các đối tượng string với nhau, thay vì phải sử dụng hàm như phương pháp mảng char.string ngang hàng với kiểu dữ liệu xâu kí tự mảng char về nhiều mặt - giá trị của hai kiểu dữ liệu có thể được gán cho nhau, và chúng có thể được đặt chung trong một phép toán. Chú ý rằng mảng char không thể được áp dụng các toán tử với nhau như string, mà phải có giá trị kiểu string trong phép toán.Ví dụ: Chương trình sau đây yêu cầu bạn nhập tên của mình vào, và in ra một câu chào hỏi.#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main(){    cout &lt;&lt; \"Hay nhap ten cua ban: \";    string name;    cin &gt;&gt; name;    cout &lt;&lt; \"Xin chao \" + name &lt;&lt; \"!\";    return 0;}Để truy cập vào kí tự của một đối tượng class string, ta cũng sử dụng ngoặc vuông như đối với mảng char. Ví dụ ViDu[3] là kí tự thứ 4 của string ViDu.Thư viện cstring không thể áp dụng lên các đối tượng class string, thay vào đó bản thân đối tượng string có những hàm để hỗ trợ cho chính bản thân mình.Lấy ví dụ với biến string s = \"Hello\", một số hàm quan trọng của string bao gồm:            Hàm        Chức năng        Ví dụ                đối_tượng.size() và đối_tượng.length()        Trả về độ dài của đối tượng        s.size() trả về 5                đối_tượng.clear()        Xóa hết nội dung của string                        đối_tượng.empty()        Kiểm tra xem string có phải là string rỗng không (string độ dài bằng 0)        s.empty() trả về false                đối_tượng.substr(int, int)        Trả về string con của string đối tượng. Tham số đầu tiên là chỉ số bắt đầu của string con cần lấy, tham số thứ hai là độ dài cần lấy.        s.substr(1, 3) trả về \"ell\"    Các bạn có thể tham khảo danh sách đẩy đủ các hàm của class string trên trang C++ Reference.Chú ý: Kiến thức về class, object và lập trình hướng đối tượng sẽ được giải thích rõ ràng trong các bài viết sau.Phần sau: [C++ Cơ bản] Phần 17: Tham chiếu và con trỏ. Tác dụng của con trỏ.",
              url: "/article/c-co-ban-phan-16-cac-gia-tri-kieu-ki-tu-xau-ki-tu"
            }
            ,

            {
              title: "[Lập trình thi đấu cơ bản] Phần 1: Học như thế nào để thi đấu?",
              author: "Nam Phương Đại Hiệp",
              category: ["article"],
              tag: ["competitve-programing", "cp"],
              content: "Phần trước: [Lập trình thi đấu cơ bản] Phần 0: Giới thiệu về lập trình thi đấuCũng như nhiều lĩnh vực khác, để trở thành một pro trong cộng đồng lập trình thi đấu, thì có một từ khóa mà bạn phải luôn nhớ. Đó là “practice anh more practice” hay nói khác đi là phải siêng năng luyện tập và giải bài tập một cách hiệu quả. Vậy làm sao để hiệu quả? Không đơn giản là thấy bài nào cũng làm, bài nào cũng giải một cách vô tội vạ. Mà chúng ta phải có một cách trainning thật sự khoa học. Hôm nay, mình sẽ chia sẻ cho các bạn một số nguyên tắc mà mình đút kết được trong quá trình luyện tập của mình.Lập trình phải học một cách chủ độngVâng, đó là điều cực kì quan trọng. Đa số cộng đồng lập trình thi đấu hiện nay đang là sinh viên hay học sinh phổ thông. Vì vậy việc học trong một khuôn khổ, theo một giáo trình nhất định đôi khi khiến bạn chán nản. Bạn nên tự tìm cho mình một động lực để phấn đấu, để không bị tuột mood khi gặp phải một vấn đề nan giải. Chẳng hạn như bạn hãy tập lên kế hoạch, định hướng trước những gì mình sẽ học và học như hế nào. Như thế bạn sẽ chủ động hơn trong việc học tập của mình và giúp công việc học tập trở nên hiệu quả hơn.Học từ đâu?Học từ những người đi trướcCó một điều bạn luôn phải nhớ, cho dù bạn có là một người uyên bác đến đâu, kiến thức mênh mong như thế nào mà không biết kết hợp chúng để giải quyết vấn đề thì mọi thứ đó cũng điều vô nghĩa cả. Bời vì bạn thiếu một thứ, đó là kinh nghiệm. Kinh nghiệm là thứ không phải tự nhiên mà có, mà nó là thứ phải hun đút theo thời gian. Vì vậy những người đàn anh, những người đi trước là nơi tuyệt vời nhất để học hỏi và rèn luyện kinh nghiệm của mình. Nên đừng tự tin quá cao vào bản thân, hãy làm quen và học hỏi các bậc tiền bối, tham gia vào các hội nhóm liên quan đến lập trình thi đấu để được thưởng lãm những skill khủng mà không phải lúc nào ta cũng nhìn thấy.Học từ internetCái này thì quá rõ ràng, không khó để hiểu tại sao đa số các CPer thường chọn internet để làm điểm định cư lí tưởng. Internet là một kho kiến thức khổng lồ. Hầu như tất cả các thuật toán, giải thuật mới hay cũ điều có ở đây. Đó là một nguồn tham khảo đầy hấp dẫn. Tuy nhiên, điều đó cũng cực kì nguy hiểm, bởi vì nhiều khi bạn sẽ gặp phải những trang web viết lung tung, không chính xác. Chính vì vậy, khi tham khảo các nguồn tài liệu trên internet, bạn cần phải chọn lọc một cách kĩ càng. Mình sẽ liệt kê một số trang web uy tín và được cộng đồng CPer đánh giá cao:  Codeforces: Đây là một trang chuyên tổ chức contest cực kì uy tín. Song song với đó là những blog chia sẻ thú vị đáng để bạn để tâm.  Topcoder: Lại là một trang tổ chức contest, những nó có phần hấp dẫn hơn codeforces. Vì những người đạt thành tích cao trong các contest sẽ có cơ hội được tham dự Topcoder Open được tổ chức hằng năm, và để săn những giải thưởng khủng tại đây.  Google Code Jam: Ngay cái tên cũng đã nói lên giá trị của nó. Đây là cuộc thi được tổ chức hằng năm bỏi Google. Những coder hàng đầu thường tham dự để tìm kiếm một chiếc vé đến Google Code Jam World Final. Đặt biệt, những coder có thành tích cao trong các cuộc thi của GCJ sẽ được ưu ái hơn những người khác nếu muốn ứng tuyển vào một vị trí mơ ước tại Google.  Spoj và VN Spoj: Chính xác hơn thì đây là nơi lưu trữ bài tập cực khủng, từ vấn bài tập kinh điển, đến hiện đại bạn đều hoàn toàn có thể tìm thấy ở đây. Do vậy, không khó hiểu khi đây là điểm hẹn hò lí tưởng cho những người đam mê lập tình thi đấu.  Ngoài ra, còn rất nhiều trang khác như Hackerrank, Hackerearth, … Các bạn nên tự tìm hiểu để trao dồi hơn khả năng của mình và khám phá những trang đó.Các kĩ năng cần có của một lập trình viên thi đấuThuật toánĐể thi đấu lập trình, bạn cần thuật toán (tất nhiên). Nhưng học những thuật toán nào cho đủ, và học ở đâu?Nhóm VNOI đã tập hợp lại các kiến thức về thuật toán một cách đầy đủ thành một thư viện, gọi là VNOI Wiki. Đây là nguồn tài liệu quý giá, giúp cho các bạn có thể tiếp cận với kiến thức về thuật toán từ con số không.Ngoài ra, các bạn cũng có thể đọc cuốn ebook Giải thuật và Lập trình của thầy Lê Minh Hoàng. Đây được ví như cuốn Sách giáo khoa dành cho các đội tuyển tin trên cả nước, với hướng dẫn tường tận cụ thể cho các thuật toán, đi kèm cùng với chứng minh và bài tập thực hành.Code nhanh và chính xácĐúng vậy, kĩ năng code nhanh là cực kì cần thiết trong lập trình thi đấu. Trong các kì thi ACM, khi mà điểm của các đội bằng nhau thì người ta sẽ xếp hạng dựa trên penalty - tức là thời gian hoàn thành problems của các đội. Đội nào có penalty nhỏ hơn sẽ là đội giành chiến thắng. Vì vậy, code nhanh và chính xác là hết sức quan trọng. Nếu có được kĩ năng ấy thì bạn đã có một lợi thế lớn trong lập trình thi đấu. Các bạn có thể kiểm tra khả năng typing của mình và luyện tập ở các trang web nổi tiếng như: 10fastfingers.com, typingtest.com, …Nắm vững một ngôn ngữ lập trìnhCó rất nhiều ngôn ngữ được sử dụng trong các cuộc thi lập trình trên toàn thế giới. Tuy nhiên, ở Việt Nam đối với học sinh thì thường có hai lựa chọn là Pascal và C++, đối với sinh viên thì lại là C++ hoặc Java. Do đó, lựa chọn cho mình một ngôn ngữ chủ yếu và nắm vững nó là một điều bắt buộc phải làm nếu muốn đạt được những kết quả như ý.Tại Cowboy Coder, chúng mình cung cấp series bài viết C++ Cơ bản, giúp các bạn có thể tiếp cận với một trong những ngôn ngữ phổ biến của bộ môn Lập trình thi đấu từ cơ bản.Quản lí thời gian trong kì thiĐây là một kĩ năng cực kì quan trọng. Thời gian luôn luôn là một áp lực vô hình đáng sợ. Nếu không muốn bị nó đè bẹp thì hãy tập cho mình một cách quản lí thời gian trong cuộc thi thật tốt. Hãy phân bổ hợp lí để lấy được càng nhiều điểm có thể.Chiến thuật làm bàiCũng như thời gian, chiến thuật cũng quan trọng không kém. Nguời xưa có câu: “Biết người, biết ta. Trăm trận, trăm thắng.” Khi đọc một bài toán, đầu tiên hãy cố gắng lấy được càng nhiều điểm càng tốt của bài toán đó. Hãy giải từng subtask một trước tiên. Tránh tình trạng lao đầu vào tìm thuật toán tối ưu đến hết giờ vẫn chưa ra. Trong khi ít nhất ta có thể có được phần nhiều số điểm của bài ở những subtask dễ hơn. Các bạn hãy hết sức lưu ý điều này, bời vì trong các kì thi lớn có tính cạnh tranh cao, đôi khi khẳng cách giữa có huy chương và không có huy chương là những điểm số cực kì nhỏ.Bài viết phần một kết thúc ở đây. Trong phần hai, chúng ta sẽ bàn về quy trình giải một bài toán trong lập tình thi đấu.",
              url: "/article/lap-trinh-thi-dau-co-ban-phan-1-hoc-nhu-the-nao-de-thi-dau"
            }
            ,

            {
              title: "AIM Tech Round 4",
              author: "Admin Tổng Quản",
              category: ["codeforces"],
              tag: ["codeforces"],
              content: "Vào lúc 23:35 ngày 24/8/2017 theo giờ Việt Nam, AIM Tech Round 4 sẽ được tổ chức dành cho cả hai Division. Contest có 5 bài và diễn ra trong 2.5 tiếng đồng hồ.Contest này được ra đề và tổ chức bởi AIM Tech - một tập đoàn công nghệ của Nga.Đề bài Div. 2 sẽ được dịch trực tiếp bởi thành viên của nhóm Cowboy Coder tại đây.Tham khảo Solution tại đây",
              url: "/codeforces/aim-tech-round-4"
            }
            ,

            {
              title: "[C++ Cơ bản] Phần 15: Các giá trị kiểu số. Thư viện toán học cmath.",
              author: "Admin Tổng Quản",
              category: ["article"],
              tag: ["cpp-cơ-bản", "programming"],
              content: "Phần trước: [C++ Cơ bản] Phần 14: Mảng - ArrayChúng ta đã sử dụng rất nhiều giá trị số trong series này, nhưng bài viết này sẽ cung cấp cho bạn những kiến thức cụ thể hơn về giá trị kiểu số, cũng như về thư viện toán học cmath của C++.Biểu diễn giá trị sốCác kiểu số nguyênXét ví dụ sau:#include &lt;iostream&gt;using namespace std;int main(){    cout &lt;&lt; 300000 * 200000 &lt;&lt; endl;    cout &lt;&lt; 300000ll * 200000 &lt;&lt; endl;    return 0;}Output-12954214460000000000Tại sao cũng cùng là biểu thức đó, mà biểu thức trên lại sai trong khi biểu thức dưới lại đúng?Hãy nhớ lại về giới hạn của int: int có thể biểu diễn được các số tới \\( 2 ^ {31} - 1 \\). Phép tính ở trên đã bị tràn giới hạn, và cho ra kết quả sai.Trong phép toán ở dưới, số 300000ll có thêm một phần hậu tố (đuôi) ll nữa. Phần hậu tố này khai báo rằng giá trị 300000 ở đây thuộc kiểu long long int, thay vì là int như mặc định.Ngoài hậu tố ll, chúng ta còn sử dụng thêm u để chỉ định một giá trị nào đó là unsigned (không có dấu).10 /* int */10ll /* long long int */10u /* unsigned int */10ull /* unsigned long long int */Ta cũng có thể biểu diễn một số dưới dạng bát phân hoặc thập lục phân, bằng cách thêm một phần tiền tố phía trước giá trị của số đó. 0 là tiền tố của số bát phân, 0x hoặc 0X là tiền tố của số thập lục phân.cout &lt;&lt; 072 &lt;&lt; endl; /* Bát phân */cout &lt;&lt; 0xA &lt;&lt; endl; /* Thập lục phân */Output5810Đối với các bạn học về xử lý hình ảnh, số thập lục phân là một kiểu số rất quan trọng, vì nó liên quan tới Hex Color Code (biểu diễn màu sắc bằng mã thập lục phân).Các kiểu số thựcMặc định tất cả các số thực trong C++ đều mang kiểu dữ liệu double. Nếu như muốn định nghĩa một giá trị kiểu float, ta phải thêm phần hậu tố f vào sau giá trị.Một số thực trong C++ có thể được biểu diễn bằng hai cách: cách biểu diễn thập phân và cách biểu diễn nhân lũy thừa của 10.Đối với kiểu biểu diện thập phân, giá trị số bắt buộc phải có dấu chấm thập phân (chú ý là dấu chấm, không phải dấu phẩy như cách biểu diễn toán học của Việt Nam).Nếu phần nguyên hoặc phần thập phân bị bỏ trống, giá trị của nó bằng 0.Ví dụ:10.0 /* biểu diễn đúng, giá trị kiểu double */10.0f /* biểu diễn đúng, giá trị kiểu float */.01 /* biểu diễn đúng, giá trị kiểu double và bằng 0.01 */21f /* biểu diễn sai, không có dấu chấm và phần thập phân */21.f /* biểu diễn đúng, giá trị kiểu float và bằng 21.0 */Đối với kiểu biểu diễn nhân lũy thừa của 10, giá trị số bắt buộc phải có phần nguyên hoặc phần thập phân. Phần nhân lũy thừa của 10 sử dụng hậu tố e hoăc E, đi liền là số mũ của 10.Ví dụ:314e-3 /* biểu diễn đúng, giá trị bằng 3.14 */.01E2 /* biểu diễn đúng, giá trị bằng 1 */e10 /* biểu diễn sai, thiếu cả phần nguyên và phần thập phân. */Thư viện toán học cmathCác toán tử cung cấp cho chúng ta những công cụ cơ bản để thực hiện phép toán với các dữ liệu kiểu số, nhưng để thực hiện các công việc phức tạp hơn, ta sẽ cần tới các hàm được định nghĩa trong thư viện cmath - thư viện toán học của C++.Để sử dụng thư viện ````cmath```, ta cần khai báo sử dụng nó trong mã nguồn của chương trình#include &lt;cmath&gt;Sau khi khai báo thư viện, ta có thể sử dụng các hàm được cài đặt trong thư viện. Một số hàm quan trọng của thư viện này là            Hàm        Chức năng        Ví dụ                double cos(double)        Hàm tính cos. Nhận vào một giá trị kiểu double là số đo của góc (tính theo radian) và trả lại giá trị cos của góc đó kiểu double.        cos(0) trả lại giá trị 1                double sin(double) và double tan(double)        Tương tự như hàm tính cos, hai hàm này tính giá trị sin và tan của góc.                        double log(double)        Hàm tính \\(ln\\) của một số thực.        log(1) trả lại giá trị 0                double pow(double, double)        Hàm tính lũy thừa của một số. Tham số thứ nhất là số cần được lũy thừa, tham số thứ hai là số mũ.        pow(2, 4) trả lại 16                double sqrt(double)        Hàm tính căn bậc hai của một số thực.        sqrt(4) trả lại 2                int abs(int)        Hàm tính giá trị tuyệt đối của một số nguyên.        abs(-10) trả lại 10                double floor(double)        Hàm tính phần nguyên của một số thực - số nguyên lớn nhất nhỏ hơn số đã cho.        floor(2.4) trả lại 2floor(-2.4) trả lại 3    Để biết tất cả các hàm có sẵn trong thư viện cmath, bạn có thể xem tại đây.Sinh số ngẫu nhiênBạn muốn đỏ đen một chút với bạn bè? Trong C++, có tới hai cách để bạn sinh ra số ngẫu nhiên. Cách thứ nhất là sử dụng thư viện random, một thư viện chuyên dụng cho việc sinh ra giá trị ngẫu nhiên. Thư viện này khá là phức tạp, mình sẽ không nói tới trong bài viết này.Cách thứ hai đơn giản hơn là sử dụng hàm srand() và rand() của thư viện cstdlib. cstdlib là thư viện công cụ phổ biến của C++, bao gồm các hàm hỗ trợ việc quản lý bộ nhớ động, sinh số ngẫu nhiên, giao tiếp với môi trường lập trình, vân vân…Hàm rand() không thực sự sinh ra một số ngẫu nhiên - nó sử dụng một số nguyên gọi là seed (hạt giống), cùng với một vài phép toán khác để sinh ra các số trông có vẻ không hề có quy luật. Nếu như chạy chương trình với seed giống nhau, các giá trị của hàm rand() trả lại cũng sẽ giống nhau.Nếu bạn muốn biết thêm về cơ chế random với seed, cũng như các cơ chế sinh random khác, đoạn video sau sẽ cung cấp lời giải thích rõ ràng hơn cho bạn.        Ok, vậy ta cần phải liên tục thay đổi seed sau mỗi lần chạy, để chương trình không sinh ra các số giống nhau. Giải pháp là sử dụng thời điểm chạy chương trình làm seed!Máy tính sử dụng một giá trị số nguyên để đếm số giây đã trôi qua kể từ thời điểm Unix Time (nửa đêm ngày 1 tháng 1 năm 1970 theo múi giờ UTC, còn được gọi là epoch time). Ta có thể lấy giá trị này bằng hàm time() của thư viện ctime.Hàm time() có một tham số mang kiểu giá trị con trỏ số nguyên, sẽ trả lại số giây đã trôi qua kể từ Unix Time, và nếu như con trỏ không phải là giá trị NULL, hàm này sẽ gán giá trị đó cho ô bộ nhớ của con trỏ. Ở đây ta không cần chức năng gán giá trị, nên ta chỉ cần gọi hàm time(NULL).Để đặt seed cho hàm rand(), ta sử dụng hàm srand().Chương trình sau sẽ in ra 10 số ngẫu nhiên, sử dụng hàm rand()#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;using namespace std;int main(){    srand(time(NULL));    for(int i = 1; i &lt;= 10; i ++)        cout &lt;&lt; rand() &lt;&lt; endl;    return 0;}Phần sau: [C++ Cơ bản] Phần 16: Các giá trị kiểu kí tự. Xâu kí tự.",
              url: "/article/c-co-ban-phan-15-cac-gia-tri-kieu-so-thu-vien-toan-hoc-lesscmathgreater"
            }
            ,

            {
              title: "[C++ Cơ bản] Phần 14: Mảng - Array",
              author: "Admin Tổng Quản",
              category: ["article"],
              tag: ["cpp-cơ-bản", "programming"],
              content: "Phần trước: [C++ Cơ bản] Phần 13: Vòng lặpTrong phần trước, chúng ta đã đặt ra bài toán Lưu trữ thông tin cá nhân của người dân thành phố Hà Nội, và đúc kết ra rằng phải sử dụng các vòng lặp mới có thể duyệt qua và xử lý hết số lượng thông tin như vậy.Tương tự, ta cũng không thể tự tay tạo ra từng biến để lưu trữ thông tin của người dân Hà Nội được - ta sẽ phải tạo tới hơn 7 triệu biến, ai có tưng đấy thời gian cơ chứ? Bài viết này sẽ đề cập tới mảng - một cách để khai báo nhiều biến có cùng kiểu giá trị.Định nghĩa mảngMảng (array) là một cấu trúc dữ liệu có kích cỡ cố định, dùng để lưu trữ nhiều đối tượng có cùng kiểu dữ liệu. Thay vì phải tạo ra từng biến person1, person2, person3, vân vân, ta chỉ cần tạo ra một mảng people và truy cập vào từng phần tử people[0], people[1], people[2],…Các biến trong array được lưu trữ tại các địa chỉ ô nhớ liên tiếp - phần tử đầu tiên ở vị trí đầu tiên, phần tử thứ hai ở vị trí thứ hai,… Thông tin này sẽ có ích khi ta học tới con trỏ bộ nhớ, còn giờ tạm thời hãy ghi nhớ lại điều đó đã.Khai báo mảngViệc khai báo mảng cũng giống như việc khai báo biến, tuy nhiên ta cần phải cung cấp thêm kích cỡ các chiều (số lượng phần tử) của mảng vào trong ngoặc vuông đặt sau tên mảng.Ví dụ:int array1[100];int x, array2[100]; /* có thể khai báo mảng cùng với các biến khác */int arrayTwoD[100][100]; /* mảng hai chiều */Chiều của mảng là gì? Ta có thể hình dung mảng nhiều chiều là mảng chứa các mảng - mảng hai chiều là mảng với các phần tử là mảng 1 chiều, mảng 3 chiều là mảng với các phần tử là mảng 2 chiều, vân vân… Ví dụ thực tế của mảng nhiều chiều là một bảng dữ liệu, bao gồm các hàng và cột giống như mảng hai chiều.Truy cập vào phần tử của mảngĐể có thể truy cập vào phần tử của mảng, ta gọi tên của mảng kèm theo với chỉ số nằm trong ngoặc nhọn đặt sau tên của mảng.Ví dụarray1[0] = 0; /* đặt phần tử đầu tiên của mảng array1 bằng 0 */array2[4] ++; /* tăng phần tử thứ 5 của mảng array2 lên 1 */cout &lt;&lt; arrayTwoD[2][3]; /* in ra phần tử ở ví trí (2, 3) của mảng hai chiều arrayTwoD */Chỉ số của các phần tử trong mảng bắt đầu từ số 0 - một mảng có n phần tử sẽ có các chỉ số 0, 1, 2,… tới n - 1. Để thuận tiện hơn, ta sẽ hình dung chỉ số của phần tử là số phần tử nằm giữa phần tử đó, với phần tử đầu tiên.Khởi tạo giá trị cho phần tử của mảngKhi khai báo mảng, các phần tử của mảng chưa được khởi tạo giá trị.Để khai báo mảng với giá trị khởi tạo cho các phần tử, ta gán mảng bằng các giá trị khởi tạo trong ngoặc nhọn, phân cách bởi dấu phẩy. Ví dụdouble arr[5] = {1, 2.0, 3.0, 3.14, 2.23};Ta cũng có thể khai báo mảng mà không có số lượng phần tử, nếu như ta đã khởi tạo giá trị cho các phần tử trong mảng. Khi đó số lượng phần tử của mảng sẽ bằng số lượng giá trị đã được khởi tạo.double arr[] = {1, 2.0, 3.0, 3.14, 2.23}; /* mảng có 5 phần tử */Để khởi tạo giá trị cho mảng nhiều chiều, ta cũng đặt mảng giá trị khởi tạo của các phần tử trong ngoặc nhọn. Ví dụ về việc khởi tạo mảng 2 chiều:int arr[][] = {{1, 2, 3},{2, 3, 4}};Bài tập áp dụng: Quy hoạch độngQuy hoạch động (Dynamic Programming, gọi tắt là DP) là một phương pháp giải quyết các vấn đề trong toán học, tin học và kinh tế, bằng cách chia nhỏ vấn đề ra và tính toán các kết quả của trường hợp lớn hơn bằng kết quả của các trường hợp nhỏ hơn. Mảng là một công cụ đắc lực để giải các bài toán DP, và ta sẽ áp dụng nó ở trong ví dụ kế tiếp.Các bạn cũng có thể tìm kiếm các bài toán quy hoạch động khác thông qua tag dp trên trang Cowboy Coder.Đề bàiCho một dãy số nguyên \\(A\\) có \\(n\\) phần tử (\\(n &lt;= 1000\\)). Hãy tìm số lượng phần tử lớn nhất trên dãy \\(A\\), sao cho khi giữ nguyên thứ tự của các phần tử này như trên dãy số gốc, thì phần tử sau lớn hơn phần tử trước. Các phần tử không nhất thiết phải kề nhau.Bài toán này còn được gọi là bài toán dãy con tăng dài nhất (Longest Increasing Subsequence - LIS)InputĐọc từ file INPUT.TXT. Dòng đầu tiên của file là một số \\(n\\) - số lượng phần tử của dãy số \\(A\\).Dòng tiếp theo có \\(n\\) số nguyên là các phần tử của dãy số \\(A\\).\\(n \\le 10 ^ 3 \\), các số thuộc dãy \\(A\\) thuộc kiểu int.OutputViết ra file OUTPUT.TXT một số nguyên duy nhất là số lượng phần tử lớn nhất tìm được.Ví dụINPUT.TXT51 3 2 4 5OUTPUT.TXT4Cách giảiTa định nghĩa hàm số \\( f(i) \\) là số lượng phần tử lớn nhất có thể lựa chọn được, nếu ta lấy phần tử thứ \\( i \\) là phần tử cuối cùng được chọn. Kết quả của bài toán sẽ là giá trị lớn nhất của các \\( f(x) \\) từ 1 tới n.Khi ta lấy phần tử thứ \\( x \\) làm phần tử cuối cùng, có hai trường hợp xảy ra  Nếu chỉ có phần tử \\(x\\) được chọn, độ dài của dãy sẽ là 1  Nếu như có phần tử \\(y\\) được chọn ở vị trí áp chót trước phần tử \\(x\\), độ dài của dãy \\(x\\) sẽ bằng \\(f(y) + 1\\) (do có thêm phần tử \\(x\\))Vậy với mỗi phần tử \\( x \\), ta đặt \\( f(x) = 1 \\), và duyệt qua các phần tử \\( i \\) từ 1 tới \\( x - 1 \\). Nếu \\( a[i] &lt; a[x] \\) và \\( f(i) + 1 &gt; f(x) \\), ta cập nhật giá trị của \\( f(x) \\) bằng giá trị mới.f[x] = 1;for (int i = 1; i &lt; x; i ++)        if (a[i] &lt; a[x] &amp;&amp; f[i] + 1 &gt; f[x])            f[x] = f[i] + 1;Code mẫu#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;int n, a[1003], f[1003], answer = 0;int main(){    // Mở file input và output    ifstream input; input.open(\"INPUT.TXT\");    ofstream output; output.open(\"OUTPUT.TXT\");    // Đọc vào dữ liệu đề bài    input &gt;&gt; n;    for (int i = 1; i &lt;= n; i ++)        input &gt;&gt; a[i];    // Tính toán mảng f[]    for (int x = 1; x &lt;= n; x ++)    {        f[x] = 1;        for (int i = 1; i &lt; x; i ++)            if (a[i] &lt; a[x] &amp;&amp; f[i] + 1 &gt; f[x])                f[x] = f[i] + 1;        // Nếu như f[x] lớn hơn đáp án, ta cập nhật đáp án        if (f[x] &gt; answer)            answer = f[x];    }    // In ra đáp án    output &lt;&lt; answer;    return 0;}Bài toán này còn có cách giải nhanh hơn, nhưng trong khuôn khổ của bài viết này, chúng ta sẽ chỉ tìm hiểu cách làm này.Phần sau: [C++ Cơ bản] Phần 15: Các giá trị kiểu số. Thư viện toán học cmath.",
              url: "/article/c-co-ban-phan-14-mang-array"
            }
            ,

            {
              title: "[Lập trình thi đấu cơ bản] Phần 0: Giới thiệu về lập trình thi đấu",
              author: "Nam Phương Đại Hiệp",
              category: ["article"],
              tag: ["competitive-programming", "cp"],
              content: "Nhằm mục đích giúp cho các bạn newbie có thể tiếp cận với Lập trình thi đấu, bắt đầu từ số này, Cowboy Coder xin hân hạnh mang đến cho các bạn series bài viết “Lập trình thi đấu cơ bản”. Series cung cấp những nguồn tài liệu quan trọng, những phương pháp luyện tập lập trình thi đấu phổ biến, và ý nghĩa thiết thực của bộ môn này, nhằm mục đích giúp các bạn tiếp cận dễ dàng hơn với bộ môn cũng như cộng đồng Competitive Programming (CP) Việt Nam. Series bài viết nhắm tới các bạn chưa từng một lần nghe đến cụm từ “lập trình thi đấu”.Ban quản trị Cowboy Coder sẽ cố gắng dùng kinh nghiệm của mình để truyền đạt thông tin một cách dễ hiểu nhất. Tuy nhiên, đôi khi không tránh khỏi sơ suất, chúng mình rất mong các bạn thông cảm và để lại góp ý cho nhóm. Mọi thắc mắc các bạn cũng có thể comment dưới các bài viết.Cowboy Coder hi vọng rằng series này sẽ trở nên thiết thực và nhận được sự ủng hộ từ các bạn.Lập trình thi đấu là gì?Như chúng ta đã biết, việc học lập trình có thể giúp chúng ta tạo sản phẩm, những phần mềm phục vụ đắc lực cho công việc cũng như giải trí. Tuy nhiên, ngoài mục đích đó ra, một khía cạnh khác cũng khá quan trọng của việc học lập trình đó là khả năng giải quyết những bài toán khó và phức tạp trong một thời gian cực ngắn. Điều mà con người chưa bao giờ làm được. Từ đó, bộ môn lập trình thi đấu (hay competitive programing) ra đời. Chúng ta có thể xem nó như một môn thể thao trí tuệ, khi mà các vận động viên phải thi đấu với nhau bằng việc giải quyết các bài toán được đưa ra. Người giỏi nhất sẽ là người giải nhanh nhất và đáp ứng được yêu cầu của bài toán đưa ra và đó sẽ là người chiến thắng.Lập trình thi đấu cho ta những lợi ích gì?Bạn có thể tìm thấy câu trả lời ở post trước Lợi và hại của việc tập trung vào lập trình thi đấu.Ngoài ra, nếu bạn là một bậc thầy trong lập trình thi đấu thì bạn có lẽ còn có được nhiều điều hơn thế. Ví dụ nếu bạn giành được huy chương IOI (sẽ giải thích đây là cái gì dưới) thì bạn sẽ có cơ hội lớn vào học những trường đại học danh giá trên thế giới. Hoặc giành được huy chương ở ACM-ICPC thì sẽ là một cơ hội việc làm rộng mở với đãi ngộ tốt.Hay đơn giản là kiếm tiền từ những contest online với giá trị giải thưởng có khi cả nghìn Trump.Một số thuật ngữ hay dùng trong lập trình thi đấu  Problem: Là những bài toán mà bạn sẽ giải quyết. Problem trong lập trình thi đấu thường chia thành hai dạng chính là ACM và OI. ACM là dạng bài tập chỉ có đúng hoặc sai, tức là solution của bạn phải pass tất cả các test mới được tính là đúng. Còn OI là dạng bài tập tính điểm theo từng test, điểm của bạn sẽ tùy thuộc vào số test đúng sai của bạn.  Online judge: Là những hệ thống chấm bài trực tuyến, địa chỉ training hàng đầu cho những người muốn theo đuổi lập trình thi đấu.  IOI: International Olympiad in Informatics - Là cuộc thi lập trình quốc tế dành cho học sinh phổ thông.  ACM - ICPC: ACM International Collegiate Programming Contest - Là cuộc thi lập trình thi đấu dành cho sinh viên đại học. Đây là đích đến mơ ước của những ai đam mêm lập trình thi đấu.   AC: Accepted - nghĩa là bài của bạn đã pass toàn bộ tất cả các test đồng nghĩa với việc hoàn thành yêu cầu của bài toán.  WA: Wrong Answer - nghĩa là bài của bạn cho kết quả sai. Hãy nhớ rằng ví dụ bài có 100 test, cho dù bạn pass 99 test nhưng chỉ sai một test thì cũng nhận về kết quả là WA.  TLE: Time Limit Exceed - nghĩa là bài của bạn đã chạy vượt quá thời gian cho phép trong yêu cầu của bài toán.  MLE: Memory Limit Exceed - nghĩa là bài của bạn đã dùng nhiều hơn bộ nhớ mà bài toán cho phép.  Submit: Là hành động nộp solution của bạn lên máy chấm để chạy và cho kết quả.  Debug: Đôi khi chương trình của bạn gặp một vài vấn đề khiến nó không thể AC, do đó ta cần phải rà soát và sửa lỗi. Qúa trình này gọi là debug.  Testing: Quá trình kiểm thử chương trình.",
              url: "/article/lap-trinh-thi-dau-co-ban-phan-1-gioi-thieu-ve-lap-trinh-thi-dau"
            }
            ,

            {
              title: "[C++ Cơ bản] Phần 13: Vòng lặp",
              author: "Admin Tổng Quản",
              category: ["article"],
              tag: ["cpp-cơ-bản", "programming"],
              content: "Phần trước: [C++ Cơ bản] Phần 12: Câu lệnh điều kiệnBài toán được đặt ra: Hãy viết các số từ 1 tới 5.Chắc chắn bạn sẽ làm trâu từ 1 tới 5 rồi, có gì to tát đâu nhỉ.Thế bây giờ bảo bạn in ra các số từ 1 tới 1 triệu, liệu bạn có thể làm được trâu không?Tính tới năm 2015, dân số của Thủ đô Hà Nội là 7,58 triệu người. Nếu lưu trữ tên, họ, địa chỉ, số điện thoại, nguyên quán, vân vân… của tất cả dân Hà Nội trong một hệ thống, bạn hoàn toàn không thể dùng sức người để xử lý không được.Để có thể yêu cầu máy tính thực hiện một công việc lặp đi lặp lại, ta sử dụng vòng lặp. Vòng lặp cho phép ta chạy một hoặc nhiều lệnh liên tục, cho tới khi nào một điều kiện đặt ra được thỏa mãn. C++ có 3 kiểu vòng lặp mà bài viết này sẽ đề cập tới.Vòng lặp forVòng lặp for có cú phápfor (lệnh khởi tạo; điều kiện kiểm tra; lệnh biến đổi) // chú ý không có dấu chấm phẩy ở sau for{    nội dung thực hiện;}Chương trình sẽ thực hiện vòng lặp for theo thứ tự sau:  Đầu tiên, lệnh khởi tạo sẽ được gọi. Thường đây là nơi để ta khai báo các giá trị được sử dụng trong vòng lặp - ví dụ như một biến int có chức năng đếm số lần lặp, nhằm kết thúc vòng lặp sau một số lần nhất định.  Tiếp theo, nếu điều kiện kiểm tra được thỏa mãn, phần nội dung thực hiện sẽ được triển khai. Nếu như không, vòng lặp sẽ được kết thúc. Ví dụ về điều kiện triển khai là việc biến đếm số lần lặp nhỏ hơn một số lần nhất định.  Sau khi phần nội dung thực hiện xong một lần, lệnh biến đổi sẽ được triển khai. Điều kiện kiểm tra sẽ lại được kiểm tra, và vòng lặp sẽ tiếp tục nếu như điều kiện vẫn còn đúng. Lệnh biến đổi có thể là việc tăng giá trị của biến đếm, thay đổi điều kiện trong vòng lặp, vân vân…Nếu như phần nội dung chỉ bao gồm một lệnh, ta không cần phải sử dụng ngoặc nhọn, giống như đối với từ khóa if.Ví dụ: Đây là vòng lặp nhằm in ra các giá trị số nguyên từ 1 tới 1000000for (int i = 1; i &lt;= 1000000; i \\+\\+)cout &lt;&lt; i &lt;&lt; endl;Một ví dụ khác: Đây là vòng lặp nhằm in ra các giá trị số lẻ từ 1 tới 100for (int i = 1; i &lt;= 100; i \\+\\+){if (i % 2 == 1)cout &lt;&lt; i &lt;&lt; endl;}Hoặcfor (int i = 1; i &lt;= 100; i \\+= 2)cout &lt;&lt; i &lt;&lt; endl;Thông thường, ta sẽ hay thấy vòng lặp for được sử dụng để duyệt qua các giá trị trong một khoảng, hoặc thực hiện một công việc cho đủ một số lần nhất định, cho dù thực tế với cấu trúc của for thì ta có thể cài đặt bất cứ cấu trúc lặp nào.Biến trong vòng forKhi ta khai báo biến trong các lệnh khởi tạo và biến đổi của vòng lặp for, các biến này cũng sẽ giống như biến local của một chương trình con - chúng chỉ tồn tại bên trong vòng for, và ta không thể truy cập vào chúng từ bên ngoài. Quy tắc đặt tên của chúng cũng giống như đối với biến local.Khi tham gia lập trình nhiều, các bạn có thể sẽ thắc mắc tại sao tên biến đếm trong vòng lặp for thường được đặt là i, mà không phải là các từ có nghĩa hơn. i ở đây viết tắt cho index - chỉ số, ám chỉ số lần lặp hoặc phần tử hiện đang được lặp. Đây là một quy chuẩn bất thành văn của lập trình viên trên thế giới. Bạn không cần phải tuân thủ quy chuẩn này, nhưng nó giúp code của bạn dễ đọc và chuyên nghiệp hơn.Lồng vòng lặp vào nhauGiả sử bạn muốn in ra bảng cửu chương. Ta sẽ cần phải thực hiện hai vòng lặp lồng nhau:  Đầu tiên, ta duyệt thừa số đầu tiên từ 1 tới 9  Với mỗi thừa số được duyệt, ta phải duyệt thừa số thứ 2 cũng từ 1 tới 9, và in ra tích của chúng.Cũng giống như các lệnh if có thể lồng vào nhau, các vòng lặp nói chung cũng có thể được lồng vào nhau. Chương trình in ra bảng cửu chương sẽ như sau:\\#include &lt;iostream&gt;using namespace std;int main(){for (int i = 1; i &lt;= 9; i \\+\\+)for (int j = 1; j &lt;= 9; j \\+\\+)cout &lt;&lt; i &lt;&lt; \" \\* \" &lt;&lt; j &lt;&lt; \" = \" &lt;&lt; i \\* j &lt;&lt; endl;return 0;}Biến đếm trong vòng lặp thường được đặt là i. Khi tên biến i bị lấy mất, ta thường sử dụng tiếp các chữ cái tiếp theo của bảng chữ cái tiếng Anh - j, k, vân vân… Đây cũng chỉ là một quy chuẩn bất thành văn mà bạn được khuyến khích làm theo.Khi viết code, ta cũng thường hay thấy các dòng lệnh được viết lùi sang phải bằng kí tự tab. Điều này giúp cho các khối lệnh trở nên rõ ràng hơn, giúp code đẹp và dễ đọc hơn.Bỏ trống nội dung các phần của vòng lặp forNếu như ta bỏ trống hai phần lệnh khởi tạo và lệnh biến đổi, sẽ không có chuyện gì xảy ra khi vòng lặp cần phải gọi hai lệnh này cả.Nếu như ta bỏ trống phần điều kiện biến đổi, điều kiện biến đổi được mặc định là đúng, và vòng lặp sẽ không bao giờ tự kết thúc (người dùng phải sử dụng các lệnh khác để kết thúc vòng lặp).Ví dụ: Vòng lặp sau đây không có khởi tạo, điều kiện hay biến đổi gì, và sẽ diễn ra vô tận vì điều kiện được mặc định là đúng.for (;;){cout &lt;&lt; \"Help! I am an infinity loop!\" &lt;&lt; endl;}Vòng lặp whileCú pháp của vòng lặp while làwhile (điều kiện kiểm tra) // không có dấu chấm phẩy ở đây{    nội dung thực hiện;}Vòng lặp này kiểm tra điều kiện đã cho, và chừng nào điều kiện này còn đúng, thì nội dung của vòng lặp còn được chạy. Điều đó có nghĩa là vòng lặp while sẽ tương tự như vòng lặpfor (; điều kiện kiểm tra;){    nội dung thực hiện;}Ví dụ: Viết ra các số nguyên chia hết cho 6, bắt đầu từ một số x được nhập bởi người dùng, và không vượt quá 100int x; cin &gt;&gt; x;while (x &lt;= 100){if (x % 6 == 0)cout &lt;&lt; x &lt;&lt; endl;x \\+\\+;}Chú ý rằng nếu như điều kiện bị sai ngay từ đầu, vòng lặp sẽ hoàn toàn không được chạy. Hãy thử nhập vào một giá trị lớn hơn 100 và xem chuyện gì sẽ xảy ra.Tương tự như vòng lặp for, vòng lặp while cũng có thể lồng vào các vòng lặp khác hoặc các khối lệnh khác bên trong nội dung của nó.Vòng lặp while thường sẽ được sử dụng khi ta muốn lặp đi lặp lại một hành động nào đó, cho tới khi một điều kiện nào đó được thỏa mãn - cho dù tương tự như vòng lặp for, while cũng có thể sử dụng để viết bất cứ kiểu vòng lặp nào.Vòng lặp do - whileVòng lặp do - while có cấu trúcdo{    nội dung vòng lặp;}while (điều kiện kiểm tra); // chú ý có dấu chấm phẩy ở đâyTương tư như vòng lặp while, vòng lặp do - while sẽ thực hiện phần nội dung cho tới khi nào điều kiện kiểm tra bị sai. Tuy nhiên khác với while, do - while sẽ thực hiện lần lặp đầu tiên trước khi kiểm tra lần đầu tiên. Điều này có nghĩa là cho dù điều kiện bị sai ngay từ đầu, vòng lặp vẫn sẽ được chạy một lần.Ví dụ: Hãy thay đoạn code in ra các số nguyên chia hết cho 6 trong ví dụ trên thànhdo{if (x % 6 == 0)cout &lt;&lt; x &lt;&lt; endl;x \\+\\+;}while (x &lt;= 100);Sau đó nhập vào một giá trị lớn hơn 100 mà chia hết cho 6 (ví dụ: 123). Ta thấy giá trị vẫn sẽ được in ra 1 lần, cho dù nó có lớn hơn 100.Vòng lặp vô hạnNếu như vòng lặp luôn luôn thỏa mãn điều kiện kiểm tra, nó sẽ không bao giờ có thể kết thúc, và sẽ diễn ra tới vô hạn :D Cách đơn giản nhất để có vòng lặp vô hạn là sử dụng for(;;) như hướng dẫn như trên, hoặc sử dụng while(true) (dịch sang tiếng Việt: chừng nào giá trị true còn đúng).\\#include &lt;iostream&gt;using namespace std;int main(){while (true){cout &lt;&lt; \"This is an infinity loop!\";}return 0;}Vòng lặp vô hạn sẽ khiến cho chương trình luôn dừng lại ở một chỗ, lặp đi lặp lại liên tục. Điều này có thể tốt hoặc xấu.Về mặt tích cực, đây là cơ sở cho các hệ điều hành - bản thân chúng là một vòng lặp vô hạn nơi chương trình luôn được tính toán - hoặc các ứng dụng. Có thể giải thích đơn giản vòng lặp của ứng dụng làwhile (true){    tính_toán_trong_ứng _dụng();    vẽ_ra_hình_ảnh_ứng_dụng();}Nếu như điều kiện kiểm tra của vòng lặp quá phức tạp và bạn cảm thấy việc đặt nó trong một biểu thức bool là không thể, thì ta có thể đặt vòng lặp là vô hạn, và kiểm tra điều kiện ở bên trong.while (true){    tính toán một tí;    if (điều kiện thứ nhất)        kết thúc vòng lặp;    tính toán thêm nữa;    if (điều kiện thứ hai)        kết thúc vòng lặp;    …;}Về mặt tiêu cực, nếu bạn không yêu cầu vòng lặp vô hạn, chương trình của bạn sẽ đơn giản dừng lại ở đó và không chạy tiếp được nữa ¯\\(ツ)/¯.Điều khiển vòng lặpĐể có thể điểu khiển diễn biến của vòng lặp, ta sử dụng các từ khóa break, continue và goto.Khi từ khóa break được gọi trong vòng lặp, nó sẽ kết thúc hoàn toàn vòng lặp đó.Ví dụ: In ra các số chia hết cho 6 từ 1 tới 100, nhưng nếu ta tìm được một số chia hết cho 13 trong khoảng này, ta sẽ dừng luôn vòng lặp vì quá xúi quẩy.for (int i = 1; i &lt;= 100; i \\+\\+){if (i % 13 == 0)break;if (i % 6 == 0)cout &lt;&lt; i &lt;&lt; endl;}Output612Khi từ khóa continue được gọi trong vòng lặp, lần lặp hiện tại sẽ bị kết thúc, và nếu như điều kiện kiểm tra được thỏa mãn thì lần lặp kế tiếp sẽ bắt đầu.Ví dụ: Duyệt biến x với các giá trị từ 1 tới 5, và in ra \"Episkey\" với mỗi một số. Nếu x là số chẵn, in ra thêm dòng chữ \"Avada Kedavra\".\\#include &lt;iostream&gt;using namespace std;int main(){for (int i = 1; i &lt;= 5; i \\+\\+){cout &lt;&lt; \"Episkey\" &lt;&lt; endl;if (i % 2 == 1) // nếu i lẻcontinue;cout &lt;&lt; \"Avada Kedavra\" &lt;&lt; endl;}return 0;}OutputEpiskeyEpiskeyAvada KedavraEpiskeyEpiskeyAvada KedavraEpiskeyLệnh goto có cú pháp xấu, khiến cho code trở nên vô cùng khó đọc, và được giới lập trình viên khuyến cáo không nên sử dụng. Vì lý do đó, bài viết này sẽ không nói tới từ khóa này.Còn cách nào khác để điều khiển vòng lặp nữa không?Nếu như vòng lặp được gọi trong một chương trình con, và chương trình con đó được kết thúc bằng lệnh return, vòng lặp cũng sẽ được kết thúc ngay tại đó. Hãy lợi dụng điều này để kết thúc vòng lặp hợp lý, tránh phải duyệt qua các giá trị thừa thãi và làm chậm chương trình.Ví dụ: Số nguyên tố là số tự nhiên lớn hơn 1 chỉ có ước số tự nhiên là 1 và chính nó. Ta sẽ viết hàm kiểm tra xem một số x có phải số nguyên tố không, bằng cách duyệt qua các giá trị i từ 2 tới x - 1, và nếu như x chia hết cho một trong các giá trị i này, hàm sẽ trả lại giá trị false ngay lập tức.\\#include &lt;iostream&gt;using namespace std;bool laSoNguyenTo(int x){if (x &lt; 2)return false;for (int i = 2; i &lt; x; i \\+\\+)if (x % i == 0)return false;return true;}int main(){int x; cin &gt;&gt; x;if (laSoNguyenTo(x))cout &lt;&lt; \"So nguyen to!\";elsecout &lt;&lt; \"Khong phai so nguyen to!\";return 0;}Phần sau: [C++ Cơ bản] Phần 14: Mảng - Array",
              url: "/article/c-co-ban-phan-13-vong-lap"
            }
            ,

            {
              title: "Codeforces Round #429",
              author: "Admin Tổng Quản",
              category: ["codeforces"],
              tag: ["codeforces"],
              content: "Vào lúc 22:05 ngày 18/8/2017 theo giờ Việt Nam, Codeforces Round #429 sẽ được tổ chức dành cho cả hai Division. Contest có 5 bài và diễn ra trong 2 tiếng đồng hồ.Bên tổ chức không có nói contest này xoay quanh chủ đề gì cả, nhưng bọn mình có bổ sung thêm một vài trò để các bạn giải trí trước khi thi :))Trò đó là gì, hãy xem tại link đề bài được dịch trực tiếp bởi thành viên của nhóm Cowboy Coder tại đây.Solution của contest sẽ được update sau khi contest kết thúc.Update: Solution của contesthttp://coginator.com/7cs",
              url: "/codeforces/codeforces-round-429"
            }
            ,

            {
              title: "[SPOJ] VMPIZZA - Pizza",
              author: "CVHvn",
              category: ["spoj"],
              tag: ["Dp", "SPOJ", "data-structure"],
              content: "Link đề bài: http://vnoi.info/problems/show/VMPIZZA/Đề bài:Linh đang sống trên tầng 5 ở East Campus, một trong những kí túc lâu đời nhất của MIT. Một điểm bất tiện của kí túc này là không có thang máy, dẫn đến sự đi lại khó khăn.Sau một buổi làm việc căng thẳng, Linh quyết định đặt pizza thay cho bữa tối. Để thay đổi khẩu vị, cậu đặt N pizza tại N cửa hàng khác nhau. Pizza thứ i được chở đến tại thời điểm ti, cung cấp ai năng lượng nếu ăn ngay. Tuy nhiên, Pizza sẽ mất dần độ nóng hổi cũng như năng lượng theo thời gian: qua mỗi thời điểm, pizza thứ i mất bi năng lượng.Linh biết trước thời điểm và giá trị của N loại pizza, và cậu muốn đạt được càng nhiều năng lượng càng tốt. Mỗi lần, Linh có thể chạy xuống nhận pizza, mang về phòng và ăn hết số pizza trong thời gian không đáng kể. Tuy nhiên, nên nhớ rằng Linh sống ở tầng 5, mỗi chuyến đi sẽ tiêu tốn của cậu B năng lượng. Linh không thích phí phạm đồ ăn (mặc dù đã sống gần 2 năm ở Mỹ), cậu sẽ luôn ăn hết pizza, kể cả khi năng lượng của nó xuống dưới 0 (khi ăn thì Linh sẽ bị cộng thêm một lượng âm năng lượng, hay nói cách khác là bị giảm năng lượng).Xác định lượng năng lượng tối đa Linh sẽ có với chiến thuật chạy tối ưu.Input:Dòng 1: 2 số nguyên N và B.Dòng 2..N + 1: mỗi dòng chứa 3 số nguyênti,ai,bi(1 ≤ ti,ai,bi ≤ 10^5)Output:Một dòng duy nhất: năng lượng tối đa với chiến thuật chạy tối ưu. Kết quả nằm trong phạm vi số nguyên 64-bit (_int64_trên Pascal hoặc_long long_trên C++).Giới hạn:  1≤ N≤ 10^5.  1 ≤B ≤ 10^5.  Trong ít nhất 30% số test, tương ứng với 30% số điểm,N≤ 1000  Trong quá trình thi, bài của bạn chỉ được chấm với 2 test ví dụ. Kết quả sẽ hiện 100 nếu bài của bạn chạy đúng cả 2 test.Solution: http://viahold.com/3ekACode: http://viahold.com/3eno",
              url: "/spoj/spoj-vmpizza-pizza"
            }
            ,

            {
              title: "[SPOJ] TFIELD - VOI 2015 Day 1 - Ruộng bậc thang",
              author: "itsjustwinds",
              category: ["spoj"],
              tag: ["geometry", "spoj"],
              content: "Đề: http://vnoi.info/problems/show/TFIELD/Ở các vùng cao hiếm đất cùng mặt bằng để canh tác, khi tiến hành trồng trọt trên các sườn đồi núi có đất màu, người ta phải bạt tam cấp để tạo thành những vạt đất bằng. Khu vực đất dốc dùng để canh tác như vậy gọi là ruộng bậc thang. Hình ảnh các khu ruộng bậc thang vẫn luôn là một hình ảnh đẹp ở các vùng cao khiến du khách và các nhà nhiếp ảnh đam mê và tốn không ít phim ảnh. Gia đình Hoàng có một khu ruộng bậc thang bao quanh một ngọn đồi được chia thành các khoang bậc thang, mỗi khoang trồng một loại cây. Khi nhìn từ trên cao xuống, ta thấy các khoang bậc thang này có hình dạng của các đa giác lồi lồng nhau. Ngoại trừ khoang chứa đỉnh đồi có biên là một đa giác lồi chứa đỉnh đồi, mỗi khoang còn lại được xác định bởi hai đa giác lồng nhau: đa giác có diện tích lớn hơn được gọi là biên ngoài của khoang còn đa giác có diện tích nhỏ hơn được gọi là biên trong của khoang. Mỗi khoang có màu đặc trưng của loại cây được trồng ở khoang đó. Vốn là một người say mê chụp ảnh, muốn có một bức ảnh đẹp, Hoàng tìm cách thay đổi không quá k loại cây được trồng ở k khoang để khi nhìn từ trên cao xuống sẽ thấy một vùng cùng màu có diện tích lớn nhất. Hoàng đã ghi nhận được danh sách m đa giác lồi mô tả biên ngoài của m khoang và màu tương ứng của chúng. Do sơ xuất, Hoàng đã để các thông tin về các khoang trong danh sách bị xáo trộn, không còn được liệt kê theo đúng trình tự từ khoang trong đến khoang ngoài.Yêu cầu: Cho biết thông tin về danh sách mà Hoàng đã ghi nhận và số nguyên k, hãy tìm cách thay đổi không quá k loại cây được trồng ở k khoang để khi nhìn từ trên cao xuống sẽ thấy một vùng cùng màu có diện tích lớn nhất.Dữ liệu vào:Dòng đầu chứa hai số nguyên dương m, k (k ≤ m);Dòng thứ i trong số m dòng tiếp theo chứa thông tin về khoang thứ i trong danh sách mà Hoàng ghi nhận bao gồm:Đầu tiên là số nguyên ni là số đỉnh của đa giác lồi mô tả biên ngoài của khoang;Tiếp theo là số nguyên ci thể hiện màu của khoang (1 ≤ ci ≤ m);Cuối cùng là ni cặp số nguyên, mỗi số có trị tuyệt đối không quá 10^9, là tọa độ của một đỉnh của đa giác. Các đỉnh của đa giác được liệt kê theo thứ tự ngược chiều kim đồng hồ.Hai số liên tiếp trên cùng dòng được ghi cách nhau bởi dấu cách.Dữ liệu ra:Ghi ra một số thực là diện tích vùng cùng màu lớn nhất sau khi thay đổi không quá k loại cây được trồng ở k khoang (kết quả đưa ra với độ chính xác 1 chữ số sau dấu chấm thập phân).Ràng buộc:  Có 40% số test ứng với 40% số điểm của bài thỏa mãn điều kiện: m ≤ 10; k = 1; các đa giác mô tả biên ngoài của các khoang là hình chữ nhật;  Có 40% số test khác ứng với 40% số điểm của bài thỏa mãn điều kiện: m ≤ 10; các đa giác mô tả biên ngoài của các khoang là tam giác;  Có 20% số test còn lại ứng với 20% số điểm của bài thỏa mãn điều kiện: m, ni ≤ 1000.Ví dụ:Input:3 14 1 0 0 1 0 1 1 0 14 1 -2 -3 5 -3 5 5 -2 53 2 -1 -1 4 -1 -1 4Output:56.0Hướng dẫn:http://viahold.com/3VrSCodehttp://viahold.com/3Vrm",
              url: "/spoj/spoj-tfield-voi-2015-day-1-ruong-bac-thang"
            }
            ,

            {
              title: "[C++ Cơ bản] Phần 12: Câu lệnh điều kiện",
              author: "Admin Tổng Quản",
              category: ["article"],
              tag: ["cpp-cơ-bản", "programming"],
              content: "Phần trước: [C++ Cơ bản] Phần 11: Hàm - Chương trình conKhông cần phải giải thích nhiều về tầm quan trọng của câu lệnh điều kiện - câu lệnh điều kiện trao cho chương trình máy tính sự linh hoạt, vào trường hợp này phải xử lý như thế này, vào trường hợp kia phải xử lý như thế kia, vân vân… Nếu không có câu lệnh điều kiện, sẽ không có những chương trình máy tính hiện đại mà chúng ta sử dụng.Bài viết này sẽ nói về các cách triển khai câu lệnh điều kiện trong C++Toán tử điều kiệnNhư đã nói trong bài viết về toán tử, toán tử điều kiện là cấu trúc có dạnggiá_trị_bool? giá_trị_thứ_nhất : giá_trị_thứ_haiNếu như giá trị bool là true, toán tử này sẽ trả về giá trị thứ nhất. Nếu là false, toán tử sẽ trả lại giá trị thứ hai.Ví dụ: Chương trình sau có một hàm isEven(), trả về true nếu tham số là chẵn và ngược lại. Ta sẽ sử dụng toán tử điều kiện để in ra \"True\" nếu hàm trả về true và \"False\" nếu hàm trả về false.#include &lt;iostream&gt;using namespace std;bool isEven(int x){    return x % 2 == 0;}int main(){    int x; cin &gt;&gt; x;    cout &lt;&lt; (isEven(x)? \"True\" : \"False\");    return 0;}Hãy thử nhập x với các giá trị khác nhau và xem kết quả.Từ khóa ifTrong phần lớn trường hợp, khi điều kiện được thỏa mãn thì ta cần phải thực hiện một hoặc một nhóm các hành động, thay vì trả lại một giá trị nào đó.Ví dụ: Nhà bạn đang nuôi một bé doge. Hằng ngày bé doge sẽ vui chơi, mệt và bị đói. Khi bị đói, bé doge sẽ sủa đòi ăn. Đó là ví dụ về một hành động xảy ra khi điều kiện được thỏa mãn.Để có thể thực hiện một lệnh/nhóm lệnh khi có một điều kiện được thỏa mãn, ta sử dung từ khóa if.Cấu trúc của câu lệnh điều kiện với if làif (biểu thức bool){    nội dung thực hiện;}Nếu biểu thức bool đúng, khối lệnh tiếp theo sau if sẽ được thực hiện.Chú ý câu lệnh if (biểu thức bool) không cần có dấu chấm phẩy kết thúc.Nếu nội dung thực hiện chỉ gồm 1 câu lệnh, ta không bắt buộc phải sử dụng ngoặc nhọn.Ví dụ thực hành: Dưới đây là một chương trình tính toán đơn giản. Bạn cần phải nhập vào hai số a và b, cùng với một kí tự dấu phép tính cộng, trừ, nhân, chia. Chương trình sẽ in ra kết quả của phép tính bạn nhập vào.#include &lt;iostream&gt;using namespace std;int main(){    int a, b;    char dau;    cin &gt;&gt; a &gt;&gt; dau &gt;&gt; b;    if (dau == '+')        cout &lt;&lt; a + b;    if (dau == '-')        cout &lt;&lt; a - b;    if (dau == '*')        cout &lt;&lt; a * b;    if (dau == '/')    {        if (b == 0)            cout &lt;&lt; \"Phep chia cho 0!\";        if (b != 0)            cout &lt;&lt; a / b;    }    if (dau != '+' &amp;&amp; dau != '-' &amp;&amp; dau != '*' &amp;&amp; dau != '/')        cout &lt;&lt; \"Phep tinh khong hop le!\";    return 0;}Như trong ví dụ trên, các câu lệnh if với phép tính cộng, trừ, nhân chỉ cần một lệnh in ra kết quả, do đó phần nội dung điều kiện không cần phải có ngoặc nhọn. Phép chia cần có thêm một lệnh kiểm tra phép tính có bị chia cho 0 hay không, do đó sử dụng nhóm lệnh ngoặc nhọn.Từ ví dụ trên, ta cũng thấy rằng ta có thể lồng nhiều câu lệnh if vào nhau, để có được tính năng mà ta muốn, giống như khả năng phát hiện chia cho 0 trong chương trình trên.Từ khóa elseTiếp túc với câu chuyện về bé doge. Khi đói, bé doge sẽ kêu và đòi ăn. Nhưng nếu không, bé doge sẽ tiếp tục vui chơi thưởng thức cuộc sống. Đó là ví dụ về chức năng của từ khóa else - thực hiện một đoạn lệnh khi biểu thức bool bị sai.Cấu trúc của đoạn lệnh if có sử dụng else làif (biểu thức bool){    nội dung khi đúng;}else{    nội dung khi sai;}Ví dụ: Trong đoạn code dành cho phép chia của chương trình trên, ta có thể sửa lại phần kiểm tra chia cho 0 thànhif (b == 0)    cout &lt;&lt; \"Phep chia cho 0!\";else    cout &lt;&lt; a / b;Từ khóa switchNhà bạn nào nuôi doge rồi chắc cũng biết - doge có rất nhiều nhu cầu, không chỉ có mỗi việc ăn. Khi doge đói, khát, chán, thất tình,… mỗi công việc lại có một hướng xử lý khác nhau. Ta có thể sử dụng nhiều lệnh if để giải quyết từng trường hợp một, hoặc sử dụng từ khóa switch để xử lý với nhiều trường hợp khác nhau.Cấu trúc của cụm lệnh switch làswitch (giá trị cần kiểm tra){    case trường hợp 1:        nội dung;        break; // không bắt buộc    case trường hợp 2:        nội dung;        break; // không bắt buộc    case trường hợp 3:        nội dung;        break; // không bắt buộc    ...    default:        nội dung; // phần default là không bắt buộc}      Giá trị cần kiểm tra: Giá trị này ở đây có thể là một biến, một biểu thức, vân vân… Giá trị này sẽ được so sánh với từng trường hợp một trong nhóm lệnh switch.        Các trường hợp: Mỗi một trường hợp đều bắt đầu bằng dòng case (giá trị):. Nếu như giá trị cần kiểm tra bằng giá trị của trường hợp, phần nội dung của trường hợp này sẽ được triển khai.        break: Từ khóa break khi được sử dụng trong khối lệnh switch mang ý nghĩa thông báo kết thúc phần nội dung của một trường hợp. Phần này là không bắt buộc - nếu không có từ khóa này, các dòng lệnh của các trường hợp về sau sẽ được chạy tiếp (cho dù không thỏa mãn trường hợp về sau) cho tới khi nào tìm thấy một từ khóa break hoặc kết thúc khối lệnh switch.        default: Khi giá trị cần kiểm tra không thỏa mãn trường hợp nào, nội dung ở phần default sẽ được triển khai. Phần này là không bắt buộc.  Ví dụ: Ta có thể chỉnh sửa lại chương trình tính toán đơn giản ở trên bằng nhóm lệnh switch cho biến dau.#include &lt;iostream&gt;using namespace std;int main(){    int a, b;    char dau;    cin &gt;&gt; a &gt;&gt; dau &gt;&gt; b;    switch (dau)    {        case '+':            cout &lt;&lt; a + b;            break;        case '-':            cout &lt;&lt; a - b;            break;        case '*':            cout &lt;&lt; a * b;            break;        case '/':            if (b == 0)                cout &lt;&lt; \"Phep chia cho 0!\";            if (b != 0)                cout &lt;&lt; a / b;        default:            cout &lt;&lt; \"Phep tinh khong hop le!\";    }    return 0;}Trong ví dụ với switch, ta thấy điều tiện lợi nhất là việc không cần hẳn biểu thức bool dài dòng như ví dụ với if để kiểm tra giá trị của dau có khác với tất cả các giá trị cho phép hay không.Tùy vào trường hợp, chúng ta sẽ sử dụng if, else và switch sao cho phù hợp với nhu cầu của chương trình.Phần sau: [C++ Cơ bản] Phần 13: Vòng lặp",
              url: "/article/c-co-ban-phan-12-cau-lenh-dieu-kien"
            }
            ,

            {
              title: "[SPOJ] BALLGMVN - VOI 2014 - Trò Chơi Với Những Viên Bi",
              author: "rknguyen",
              category: ["spoj"],
              tag: ["spoj", "geometry"],
              content: "Link đề gốc:http://vnoi.info/problems/show/BALLGMVN/Đề bài:Trong một hội thi Ballgame, ban tổ chức chuẩn bị một bàn lớn. Trên mặt bàn có n bi xanh đánh số từ 1 đến n và n bi đỏ đánh số từ n + 1 đến 2n. Mỗi trận đấu, các vận động viên sẽ chơi luân phiên nhau. Đến lượt chơi của mình, Hùng cần tìm 3 bi mà vị trí của chúng là thằng hàng hanu và sao cho trong số đó có hai bi đỏ và 1 bi xanh (khi đó ăn được một bi đỏ), hoặc là có hai bi xanh và 1 bi đỏ (khi đó được ăn 1 bi xanh).Yêu cầuCho biết tọa độ trên mặt phẳng tọa độ Đề-các của vị trí và màu của các bi hiện tại trên bàn, bạn hãy giúp Hùng chọn 3 bi để chơi.Input  Dòng đầu ghi số nguyên dương n.  Dòng thứ i trong số n dòng tiếp theo ghi hai số nguyên là hoành độ và tung độ trên mặt phẳng tọa độ Đề-các của vị trí đặt bi xanh với chỉ số i.  Dòng thứ i trong số n dòng cuối cùng ghi hai số nguyên là hoàng độ và tung độ trên mặt phẳng tọa độ Đề-các của vị trí đặt bi đỏ với chỉ số n + i.  Hoàng độ và tung độ không vượt quá 10^6, vị trí các bi là đôi một phân biệt.Giới hạn  30% số test có n &lt;= 2.  30% số test khác có n &lt;= 100.  40% số test còn lại có n &lt;= 1000.OutputGhi ra 3 chỉ số của các viên bi mà Hùng cần chọn, nếu không thể chọn được 3 bi nào, ghi ra -1.Nếu có nhiều đáp án, ghi ra một đáp án bất kì.Ví dụInput:31 12 24 93 36 208 100Output:1 2 4Solution:Tham khảo tại: http://viahold.com/3a1PCode:Tham khảo tại: http://viahold.com/3a0b",
              url: "/spoj/spoj-ballgmvn-voi-2014-tro-choi-voi-nhung-vien-bi"
            }
            ,

            {
              title: "[SPOJ] BAOVE - Bảo vệ",
              author: "Accepted Problems",
              category: ["spoj"],
              tag: ["spoj", "flows"],
              content: "Link đề gốc:http://vnoi.info/problems/show/BAOVE/Đề bài:Một mạng lưới gồm N thành phố, và một số đường một chiều nối các cặp thành phố (giữa hai thành phố có thể có nhiều đường nối một chiều).Quân địch đang tập trung ở thành phố N, định tiến công ta ở thành phố 1, và chúng sẽ tiến công trên tất cả các con đường chưa được bảo vệ để tiến vào thành phố 1. Bộ chỉ huy ta cần xác định số quân ít nhất trên các con đường để chặn địch tiến về thành phố 1.InputDòng đầu ghi N (N ≤ 5000)Các dòng tiếp theo cho đến hết file, mỗi dòng một tả 1 đường gồm u, v, s cho biết có đoạn đường một chiều từ u đến v, và phải cần ít nhất s quân để chặn địch trên đường này. (s ≤ 65000)Có không quá 10000 đường.OutputSố quân ít nhất cần điều độngVí dụInput:1010 7 250506 1 1256410 4 239165 1 6105410 9 509509 1 3555810 2 609413 1 222038 2 28535 7 314223 7 414918 7 272354 8 559658 6 419803 6 477072 3 453203 8 112377 6 387345 6 75613 5 8844Output:79169Solution:Tham khảo tại: http://viahold.com/2y8WCode:Tham khảo tại: http://viahold.com/2y6uCode đã được nộp và AC trên SPOJ, sử dụng bộ dịch của C++11",
              url: "/spoj/spoj-baove-bao-ve"
            }
            ,

            {
              title: "[C++ Cơ bản] Phần 11: Hàm - Chương trình con",
              author: "Admin Tổng Quản",
              category: ["article"],
              tag: ["cpp-cơ-bản", "programming"],
              content: "Phần trước: [C++ Cơ bản] Phần 10: Toán tử (tiếp)Có một bài toán được đặt ra: Cho hai giá trị số a và b. Ta cần phải đảo giá trị của chúng - đặt a bằng b và đặt b bằng a.Ta không thể đặt thẳng giá trị của chúng như vậy được - nếu như ta viếta = b;b = a;thì giá trị của a sẽ bằng giá trị của b lúc ban đầu, và dòng code thứ hai sẽ không có tác dụng gì hết.Giải pháp là sử dụng một biến tạm thời để lưu trữ giá trị cũ của a, để gán về sau cho b.int temp = a;a = b;b = temp;Nhưng nếu ta phải thực hiện công việc tầm 10 lần trong chương trình thì sao? Việc viết ba dòng code này mỗi khi cần đảo giá trị là một điều rất bất hợp lý - code sẽ dài và không trực quan (không có chỗ nào trong 3 dòng code ghi là đây là lệnh để đảo giá trị a và b cả). Hơn nữa, nếu phải sửa một chỗ nào đó trong việc đảo giá trị - ví dụ kiểm tra hai giá trị được đảo có cùng kiểu dữ liệu không chẳng hạn - ta sẽ phải sửa hàng chục lần.Giải pháp là sử dụng hàm (function, hay còn được gọi là chương trình con).Định nghĩa hàmHàm là một nhóm lệnh, yêu cầu chương trình phải hoàn thành một công việc nào gì đó.Hàm có thể được yêu cầu trả lại một giá trị nào đó (ví dụ: hàm tính lũy thừa của một số), hoặc không (hàm trả lại kiểu void - ví dụ như hàm open() của fstream). int main() là một hàm tiêu biểu, trả lại kiểu int là kết quả chạy của chương trình.Người dùng có thể tự định nghĩa hàm mới trong chương trình của mình.Cách định nghĩa hàm mớiCú pháp để định nghĩa hàm mới làkiểu_dữ_liệu_trả_về tên_của_hàm(các_tham_số_của_hàm){    nội_dung_của_hàm;}Kiểu dữ liệu trả vềHàm có thể chỉ thực hiện thao tác lên giá trị mà không trả về kiểu gì cả - khi đó kiểu dữ liệu trả về được đặt là void (không giá trị).Hàm cũng có thể sử dụng để thực hiện phép tính toán và trả lại kết quả - có thể là các kiểu dữ liệu nguyên thủy như int, double, char,… hay các kiểu dữ liệu người dùng định nghĩa (sẽ được nói tới trong các bài sau).Tên của hàmQuy tắc đặt tên của hàm cũng giống như quy tắc đặt tên biến - trừ trong trường hợp overloading (viết đè hàm). Overloading sẽ được giải thích trong các bài viết sau.Các tham số của hàmMột hàm có thể được truyền vào một hoặc nhiều biến tham số để hoạt động. Ví dụ: hàm open() của fstream cần có một xâu kí tự là địa chỉ của file cần mở, và một giá trị bitmask mode không bắt buộc.Các tham số của hàm được định nghĩa theo cú pháp như khai báo biến - kiểu_dữ_liệu tên_biến - và được phân cách nhau bằng dấu phẩy (,).Các tham số giống như biến local của hàm - chúng chỉ tồn tại bên trong hàm, và sẽ không thể truy cập được từ bên ngoài. Nếu như có biến global trùng tên, thì biến tham số của hàm sẽ được sử dụng trong hàm của nó.Ta không được phép đặt tên biến local trùng tên biến tham số của hàm.Hàm không bắt buộc phải có tham số - ví dụ như hàm int main(). Khi đó ta bỏ qua mục này trong ngoặc tròn.Tham số của hàm có 3 dạng - các dạng của tham số sẽ được nói rõ hơn ở phần sau của bài viết.Nội dung của hàmNội dung của hàm là những việc ta cần hàm thực hiện, được biểu diễn trong khối lệnh ngoặc nhọn.Ví dụ: Nội dung của hàm có khả năng in ra giá trị của một sốvoid printNumber(int value){    cout &lt;&lt; value;}Đối với các hàm có giá trị trả về (khác void), ta cần phải sử dụng lệnh return giá_trị; để thông báo kết thúc chương trình và giá trị trả về.Ví dụ: Nội dung của hàm có khả năng trả về tổng của hai sốint tong(int a, int b){    return a + b;}Từ khóa return sẽ thông báo kết thúc hàm ngay lập tức, và trả về giá trị nếu có.Một hàm được định nghĩa trả về một kiểu giá trị khác void mà kết thúc không có return sẽ khiến chương trình bị lỗi undefined behavior. Các bộ dịch không nhất thiết cần phải thông báo lỗi này (nhưng thường sẽ có cảnh báo), và chương trình vẫn có thể được dịch thành công kể cả khi có lỗi này. Khi đó giá trị trả về có thể là bất cứ giá trị nào. Để tránh sai sót, hãy luôn kết thúc các hàm một cách hợp lệ.Từ khóa return cũng có thể sử dụng trong hàm kiểu void để kết thúc hàm đó. Trong trường hợp này, ta không cần có phần giá trị trả về.Ví dụ:void testing(){    cout &lt;&lt; \"Dong nay se duoc in ra!\";    return;    cout &lt;&lt; \"Dong nay se khong duoc in ra, vi chuong trinh con ket thuc roi!\";}Sử dụng hàm đã được định nghĩaSau khi đã định nghĩa hàm, ta có thể sử dụng hàm bằng cách gọi tên của hàm cùng với giá trị của các tham số của nó (nếu có).Ví dụ thứ nhất: Chương trình sau đây gọi ra hàm testing vừa rồi ở trong int main(), để kiểm tra tính năng của từ khóa return#include &lt;iostream&gt;using namespace std;void testing(){    cout &lt;&lt; \"Dong nay se duoc in ra!\";    return;    cout &lt;&lt; \"Dong nay se khong duoc in ra, vi chuong trinh con ket thuc roi!\";}int main(){    testing();    return 0;}OutputDong nay se duoc in ra!Ví dụ thứ hai: Chương trình sau đây sẽ in ra tổng của hai giá trị được tính toán bằng hàm tinhTong()#include &lt;iostream&gt;using namespace std;int tinhTong(int a, int b){    return a + b;}int main(){    cout &lt;&lt; tinhTong(1, 2);    return 0;}Các kiểu tham số của hàmOk, giờ ta có thể áp dụng hàm vào chương trình đảo hai số như đầu bài viết đặt ra! Ta chỉ cần viết một hàm daoSo() như sauvoid daoSo(int a, int b){    int temp = a;    a = b;    b = temp;}Rồi sau đó gọi hàm này ở dưới khi nào cần đảo số:#include &lt;iostream&gt;using namespace std;void daoSo(int a, int b){    int temp = a;    a = b;    b = temp;}int main(){    int a = 10, b = 20;    daoSo(a, b);    cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; \"\\n\";    cout &lt;&lt; \"b = \" &lt;&lt; b;    return 0;}Outputa = 10b = 20Tại sao giá trị của a và b vẫn chưa đảo?Có 3 dạng tham số của hàmTham số truyền giá trịĐây là kiểu tham số mặc định của hàm. Khi ta gọi hàm, chương trình sẽ tạo ra các biến mới, copy giá trị được truyền vào biến, và tất cả các thay đổi sẽ chỉ diễn ra trên các biến mới này. Hàm daoSo() ta vừa viết rơi vào trường hợp này - chỉ có giá trị của hai biến tham số a và b thay đổi, a và b ở bên ngoài vẫn không có gì thay đổi cả.Tham số truyền biếnĐể khai báo một biến tham số truyền biến, ta sử dụng cú pháp khai báo tham sốkiểu_dữ_liệu &amp;tên biến // đặt dấu &amp; ở trước tên biếnKiểu tham số này thực hiện mọi thay đổi trực tiếp lên biến mà không thông qua bản copy nào.Ví dụ, ta viết lại hàm daoSo() như sauvoid daoSo(int &amp;a, int &amp;b){    int temp = a;    a = b;    b = temp;}Cho chạy chương trình với đoạn code sửa đổi, ta được outputa = 20b = 10Hàm đảo số đã thực hiện thay đổi trực tiếp lên hai biến a và b, và nhờ đó mà giá trị của chúng đã được đảo thành công.Khi sử dụng hàm có tham số truyền biến, các tham số này bắt buộc phải là một biến - khác với tham số truyền giá trị chỉ cần truyền giá trị. Do đó nếu hàm có dạngint example(int &amp;a…Thì tham số a chỉ có thể là một biến kiểu int hoặc tương đương. Trong khi đó nếu hàm có dạngint example(int a…Thì tham số a có thể là 1 biến, 1 biểu thức cho ra kiểu int hoặc tương đương, hoăc một giá trị số cụ thể.Tham số truyền con trỏĐể khai báo một biến tham số truyền con trỏ, ta sử dụng cú pháp khai báo tham sốkiểu_dữ_liệu *tên biến // đặt dấu * ở trước tên biếnKiểu dữ liệu này sẽ truyền giá trị địa chỉ ô nhớ của biến vào hàm.Kiểu tham số này, cùng với những kiến thức về con trỏ, sẽ được giải thích kĩ hơn ở các bài viết sau.Đệ quyGiả sử ta định nghĩa giai thừa của một số nguyên x như sauĐây là một cách định nghĩa kiểu quy nạp - ta định nghĩa một giá trị cơ sở, và các giá trị quy nạp sẽ được định nghĩa từ các giá trị cơ sở trước nó.Trong chương trình, ta cũng có thể tự gọi một hàm ở ngay bên trong nó - hành động này được gọi là đệ quy. Ví dụ với hàm tính lũy thừa của một số theo định nghĩa trênlong long int giaiThua(int x){    return (x == 0? 1 : giaiThua(x - 1) * x);}Dòng lệnh trên sử dụng toán tử điều kiện - nếu như x bằng 0, giai thừa sẽ trả lại 1. Nếu x khác 0, giai thừa sẽ bằng giai thừa của x - 1 nhân với x.Chú ý rằng hành động đệ quy có thể sinh ra lặp vô hạn. Ví dụ như hàm sauint infinityLoop(int x){    return infinityLoop(x - 1) * x;}Hàm kia sẽ liên tục lấy hàm infinityLoop của x - 1 nhân với x, mà không hề có điểm dừng. Nếu gọi hàm này, chương trình hoặc sẽ không thể chạy được tiếp (do hàm này không bao giờ kết thúc), hoặc sẽ sinh lỗi tràn bộ nhớ (do phải tạo ra vô hạn biến tham số x cho mỗi lần gọi hàm).Giá trị mặc định cho tham sốNhư hàm open của fstream có giá trị mặc định cho mode, ta cũng có thể đặt giá trị mặc định cho các tham số của hàm.kiểu_dữ_liệu tên_biến = giá_trị_mặc địnhGiá trị mặc định sẽ được sử dụng khi không có giá trị nào được truyền vào tham số tương ứng.Ví dụ: Chương trình sau sẽ gọi ra hàm tính tổng hai số mà không truyền hai số vào. Vì đã có giá trị mặc định từ trước, nên phép toán vẫn được thực hiện với hai giá trị mặc định.#include &lt;iostream&gt;using namespace std;int tinhTong(int a = 10, int b = 20){    return a + b;}int main(){    cout &lt;&lt; tinhTong();    return 0;}Output30Phần sau: [C++ Cơ bản] Phần 12: Câu lệnh điều kiện",
              url: "/article/c-co-ban-phan-11-ham-chuong-trinh-con"
            }
            ,

            {
              title: "[SPOJ] PVOI14_3 - TOUR ",
              author: "Nicky.Rio",
              category: ["spoj"],
              tag: ["spoj", "graph"],
              content: "Link gốchttp://vnoi.info/problems/show/PVOI14_3/Đề bàiSau khi xây dựng xong khu du lịch, thầy Minh bắt tay vào khai thác bằng cách tổ chức các hành trình du lịch. Khu du lịch gồm N địa điểm đánh số từ 1 đến N. Hệ thống giao thông trong vùng gồm M tuyến đường 1 chiều khác nhau, tuyến đường thứ j (j = 1, 2, …, M) cho phép đi từ địa điểm uj đến địa điểm vj với chi phí đi lại là số nguyên dương cj. Công ty vừa nhận được một hợp đồng yêu cầu xây dựng một hành trình du lịch xuất phát từ địa điểm du lịch bất kỳ và đi thăm một số địa điểm du lịch sau đó quay về địa điểm xuất phát mà chi phí trung bình là nhỏ nhất. Chi phí trung bình được tính bằng tổng chi phí của các tuyến đường mà hành trình đi qua chia cho số tuyến đường trên hành trình.Yêu cầu: Cho thông tin về hệ thống giao thông, hãy xây dựng một hành trình du lịch với chi phí trung bình là nhỏ nhất.Input  Dòng thứ nhất chứa 2 số nguyên dương N ≤ 103, M≤ 104.   Dòng thứ j trong số M dòng tiếp theo chứa 3 số nguyên dương uj, vj, cj cho biết thông tin về tuyến đường thứ j. Giả thết là u_j khác vj; cj &lt;= 10^9 với j = 1, 2, …, M.OutputGhi ra giá trị tổng chi phí cho số địa điểm trên hành trình tìm được, làm tròn tới đúng 2 chữ số sau dấu phẩy. Ghi ra xâu NO TOUR nếu không tìm được hành trình du lịch thỏa mãn yêu cầu.ExampleInput6 81 2 4 2 4 1 4 3 3 3 1 4 4 1 1 3 5 55 3 1 5 6 7Output2.00Solutionhttp://viahold.com/2H51Code mẫuhttp://viahold.com/2Gek",
              url: "/spoj/spoj-pvoi14_3-tour"
            }
            ,

            {
              title: "Lập trình thi đấu hiệu quả hơn với Codeforces Bookmark!",
              author: "rknguyen",
              category: ["article"],
              tag: ["codeforces", "bookmark", "code-faster"],
              content: "Codeforces Bookmark và lời nói đầu  Ý tưởng: Bắt nguồn từ những screencast của Petr mà mình xem ở Youtube, nên mình muốn tạo ra một công cụ có khả năng tự động chạy bài làm của mình với các test mẫu.  Tại sao mình không làm extension mà lại là bookmark? Vì kiến thức của mình còn hạn hẹp không thể viết được extension cho cả các trình duyệt Firefox và các trình duyệt khác, và thức sự thì bookmark đã có mặt ở các trình duyệt tiên tiến hiện nay nên việc sử dụng bookmark sẽ không khó khăn để có thể sử dụng ở các loại trình duyệt.  Chức năng của Codeforces-Bookmark này?          Tạo file bài tập theo ID của bài tập đó dựa vào template có sẵn do bạn tuỳ chỉnh.      Kiểm tra bài tập của bạn với những test mẫu chỉ trong 1 nốt nhạc.      Hình ảnh khi sử dụngCác bước cài đặt  Tải và cài đặt Ampps  Tải về Ampps tại trang chủ tại đây  Nếu bạn vẫn còn không biết cách cài đặt Ampps thì hãy xem hướng dẫn bên dưới.  Tải về và thiết lập để sử dụng Codeforces Bookmark.  Cài đặt phím tắt để sử dụng nhanh trên CodeBlocks.  Hướng dẫn sử dụng chi tiết và hiệu quả trên Codeblocks.Hướng dẫn cài đặt AmppsMở file cài đặt Ampps lênNhấn vào Next, tiếp tục tick vào dòng chữ I accept the agreement, sau đó tiếp tục nhấn Next cho đến khi nó cài đặt, đợi thành tiến trình chạy xong bỏ tick ở dòng Launch Ampps và bấm FinishVới các bảng hiện lên hỏi sau đó bạn hãy chọn Allow accessLưu ý khi sử dụng Ammps mỗi lần làm bài tậpNếu sau khi cài đặt nó chạy thì hãy tắt nó bằng cách chọn dấu mũi tên lên dưới navbar, sau đó chuột phải vào icon Ampps và chọn QuitSau đó mở Ammps bằng quyền AdminMỗi lần sử dụng hãy mở Ampps bằng quyền Admin mới có thể hoạt động ổn định với Codeforces BookmarkHướng dẫn tải về và thiết lậpBước 1: Vào đây để tải về các file cần thiết về để bắt đầu thiết lập.Bước 2: Vào nơi cài đặt Ampps, đối với  7/8/8.1/10 64bit: C:\\Program Files (x86)\\Ampps  7/8/8.1/10 32bit: C:\\Program Files\\AmppsVào thư mục www tạo một thư mục mới tên là codeforces, sau đó chép toàn bộ trong ZIP đã tải ở trên vào trong thư mục vừa tạo.Bước 3: Mở file config.php sẽ có dạng&lt;?php$CONFIG = Array(    'PATH' =&gt; '',    'DIR_SAVE_TEST' =&gt; 'tests',);?&gt;Ví dụ thư mục bạn lưu trữ các bài tập codeforces là C:\\CodeBlocks\\CodeForces thì bạn sẽ thay thế nó bằng&lt;?php$CONFIG = Array(    'PATH' =&gt; 'C:\\CodeBlocks\\CodeForces',    'DIR_SAVE_TEST' =&gt; 'tests',);?&gt;Sau đó lưu lại.Bước 4: Mở file bookmark.txt, sao chép đoạn mã trong đó.Mở trình duyệt lên và thêm bookmark  Tên: Các bạn có thể đặt theo tên các bạn thích  URL: Dán đoạn mã vừa sao chép ở trên vàoLưu lại.Thiết lập phím tắt để sử dụng nhanh trên CodeBlocksBước 1: Nhìn trên thanh công cụ, chọn Tools -&gt; Configure tools…Nhìn trên bảng vừa hiện ra, chọn Add  Name: check  Executable: $(TARGET_OUTPUT_DIR)$(TARGET_OUTPUT_BASENAME)checkExamTest.exe  Working Directory: $(TARGET_OUTPUT_DIR)Nhấn OK để lưuBước 2:Tiếp tục tại thanh công cụ, chọn Settings -&gt; Editor…Nhìn bên tay trái, kéo xuống chọn Keyboard shortcuts. Nhìn vào commands, chọn dấu + tại Tools rồi nhấn vào check (cái tên nãy đặt cho Tool)Nhìn sang phải, ô New shortcut. Ở đây bạn muốn phím tắt nào thì hãy bấm vào. Ví dụ muốn Ctrl-E thì tại đó bấm vào nút Ctrl và nút E cùng lúc nó sẽ tự nhận.Sau đó bấm Add bên dưới và nhấn vào OK để lưu.Lưu ý: Mỗi lần bạn muốn sử dụng chấm thử test ví dụ hãy bấm F9 (tức là compile &amp; run) file bài tập mà bạn đang làm để nó nhận diện thư mục hiện tại sau đó tắt đi (chỉ cần làm duy nhất 1 lần với file mới, khi chuyển file bài khác thì làm lại).Sau đó mỗi lần code xong bấm phím tắt mà bạn đã cài đặt ở trên để chạy trình chấm. Ở trình chấm mình đã làm phần compile nên các bạn sau khi đã F9 như trên thì sau đó chỉ cần phím tắt để nó compile và chấm luôn. Nếu có lỗi nó sẽ hiện ở màn hình console.Thiết lập Codeblocks mặc địnhNếu bạn không dùng Codeblocks có thể bỏ qua phần này.Tìm đến bất kỳ một bài làm nó đó có đuôi .cpp, chuột phải vào nó và chọn Properties. Ở tab General bấm vào Change và chọn Codeblocks. Nhấn Apply và OK để lưu cài đặt.Sử dụng Codeforces BookmarkHãy chắc chắn là bạn đã mở Ampps với quyền AdminVào trang làm bài tập của Codeforces, nhấn vào bookmark đã tạo ban nãy và đợi nó tạo và mở file đó ở Codeblocks.Muốn chấm bài, trước tiến bấm F9 để nó nhận diện bài đang làm sau đó tắt đi, sau đó mỗi lần muốn chấm thử bài đang làm đó hãy bấm phím tắt mà bạn đã thiết lập. Nó sẽ tự compile và chấm thử test mẫu!Tuỳ biến template codeVào folder codeforces ở bước trên cùng đã có nối, tiếp tục vào thư mục sample, mở file solution.cpp và thay đổi trong đó!Lưu ý: Không thay đổi tên file vì sẽ ảnh hưởng đến Codeforces Bookmark!Kết thúc  Nếu có vấn đề gì xảy ra khi sử dụng các bạn hãy bình luận ở bên dưới để mình biết nhé!  Ngoài ra nếu các bạn thấy hay thì hãy bấm Like để theo dõi các bài viết của bọn mình và share để nhiều người biết đến bọn mình hơn nhé!  Mọi sự ủng hộ từ các bạn là động lực rất lớn để nhóm mình ra thêm nhiều bài viết hay - bổ ích và các lời giải bài tập trên SPOJ và Codeforces nhanh chóng hơn!",
              url: "/article/lap-trinh-thi-dau-hieu-qua-hon-voi-codeforces-bookmark"
            }
            ,

            {
              title: "[SPOJ] NK05MNIM - Bốc sỏi",
              author: "Accepted Problems",
              category: ["spoj"],
              tag: ["spoj", "game-theory"],
              content: "Link đề gốc:http://vnoi.info/problems/show/NK05MNIM/Đề bài:Hai bạn Nam và Mai cùng chơi một trò chơi với n đống sỏi. Luật chơi như sau:  Hai bạn sẽ lần lượt đi. Bạn Mai là người đi trước  Trong mỗi lượt đi, bạn đi sẽ được quyền bốc một số sỏi bất kỳ từ một đống nhất định và phải bốc tối thiểu là 1 viên sỏi.  Bạn nào bốc phải viên sỏi cuối cùng là người thua cuộcBạn hãy giúp Mai xác định xem bạn ấy có thể thắng được trong trò chơi hay khôngDữ liệu vàoDòng đầu tiên chứa một nguyên t là số bộ test. Các dòng sau là t bộ test.Mỗi bộ test bao gồm:  Dòng đầu tiên chứa một số nguyên n (n&lt;=100) là số đống sỏi  Dòng thứ hai gồm n số nguyên a1, a2, a3,… , an, ngăn cách nhau bởi một khoảng trắng. Số nguyên ai cho biết số lượng viên sỏi có trong đống thứ i (1&lt;=ai&lt;=100)Kết qủaVới mỗi bộ test, in ra 1 nếu bạn Mai thắng, -1 nếu bạn Mai thuaVí dụ:Input2430 4 19 7531 4 5Output1-1SolutionTham khảo tại: http://viahold.com/1uglCodeTham khảo tại: http://viahold.com/1uSb",
              url: "/spoj/spoj-nk05mnim-boc-soi"
            }
            ,

            {
              title: "[SPOJ] APIO10A - Commando",
              author: "houtaru",
              category: ["spoj"],
              tag: ["spoj", "dp", "geometry"],
              content: "Link đề bài : http://www.vnoi.info/problems/show/APIO10A/Đề bài :Cho 1 dãy N số nguyên. Một hàm số bậc 2 : f(x) = a * x ^ 2 + b * x + c. Phân dãy trên thành các đoạn liên tiếp sao cho tổng các hàm f trên các dãy là lớn nhất (giá trị f của 1 dãy là f(x) với x là tổng của dãy đó).Input format :  Dòng đầu là số test case T  Mỗi test case gồm 3 dòng :          Dòng đầu là số nguyên dương N - số phần tử của dãy.      Dòng 2 là 3 số nguyên a, b, c.      Dòng còn lại gồm n số x1, x2, …, xn là n phần tử của dãy.      Output format :  Mỗi test case gồm 1 dòng, là kết quả của bài toán.Giới hạn :T&lt;=3n ≤ 1, 000, 000,−5 ≤ a ≤ −1            b      ≤ 10, 000, 000                  c      ≤ 10, 000, 000      1 ≤ xi ≤ 100.Input:34 -1 10 -20 2 2 3 4 5-1 10 -201 2 3 4 58-2 4 3100 12 3 4 5 2 4 2Output:913-19884Solution: http://viahold.com/1uCjCode: http://viahold.com/1tt2",
              url: "/spoj/spoj-apio10a-commando"
            }
            ,

            {
              title: "[SPOJ] QTREE3 - Query on a tree again!",
              author: "CVHvn",
              category: ["spoj"],
              tag: ["dfs", "spoj", "heavy-light-decomposition", "data-structure"],
              content: "Link đề bài : http://vnoi.info/problems/show/QTREE3/Đề bài:Cho một cây (đồ thị vô hướng phi chu trình) có N nút. Các nút của cây được đánh số từ 1 đến N. Ban đầu, mỗi nút đều có màu trắng.Bạn phải thực hiện các thao tác có dạng sau:  0 i: đổi màu nút thứ i (từ đen thành trắng, hoặc từ trắng thành đen)  1 v: tìm chỉ số của nút đen đầu tiên trên đường đi từ nút 1 đến nút v. Nếu không tồn tại, hãy trả về -1.Input :  Dòng thứ nhất gồm hai số nguyên N và Q.  N-1 dòng sau, mỗi dòng gồm hai số nguyên a b mô tả một cạnh nối giữa nút a và nút b.  Q dòng sau chứa các thao tác dạng “0 i” hoặc “1 v” (1 ≤ i, v ≤ N).Output :Với mỗi thao tác dạng “1 v”, in ra một số nguyên là kết quả.Giới hạn :Có 12 test:  Trong 1\\/3 số test, N=5000, Q=400000.  Trong 1\\/3 số test tiếp theo, N=10000, Q=300000.  Trong 1\\/3 số test tiếp theo, N=100000, Q=100000.Solution:http://viahold.com/1mJACode:http://viahold.com/1mJm",
              url: "/spoj/qtree3-query-on-a-tree-again"
            }
            ,

            {
              title: "[C++ Cơ bản] Phần 10: Toán tử (tiếp)",
              author: "Admin Tổng Quản",
              category: ["article"],
              tag: ["cpp-cơ-bản", "programming"],
              content: "Phần trước: [C++ Cơ bản] Phần 9: Toán tửToán tử trên bitNhư đã giải thích trong các phần trước, dữ liệu trên máy tính được lưu trữ dưới dạng dãy bit nhị phân. Các toán tử trên bit cho phép người dùng có thể thực hiện thay đổi trực tiếp trên dãy bit của giá trị.Trong các ví dụ sau đây, ta sử dụng hai biến int x = 12 và int y = 6. Để dễ quan sát, dãy bit biểu diễn của hai giá trị này sẽ được rút ngắn lại thành 1100 và 110.            Toán tử        Ý nghĩa        Ví dụ                &amp; (AND)        Trên dãy bit kết quả, ví trị nào mà cả hai dãy bit đều có giá trị là 1 sẽ mang giá trị là 1, ngược lại mang giá trị 0.        x &amp; y cho kết quả bằng 4 (100, do cả hai dãy bit chỉ có chung bit 1 ở vị trí thứ 3 từ phải qua).                | (OR)        Trên dãy bit kết quả, vị trí nào mà một trong hai dãy bit có giá trị là 1 thì sẽ mang giá trị là 1, ngược lại mang giá trị 0.        x | y cho kết quả bằng 14 (1110, do cả hai dãy bit có bit 1 ở các vị trị 4, 3, 2 từ phải qua).                ^ (XOR)        Trên dãy bit kết quả, vị trí nào mà chỉ một trong hai dãy bit có giá trị bằng 1 thì sẽ mang giá trị là 1, ngược lại mang giá trị 0 (phép cộng không nhớ trên hệ nhị phân).        x ^ y cho kết quả bằng 10 (1010, do vị trí thứ 3 từ trái qua của hai giá trị có chung bit 1).                ~ (NOT)        Đảo toàn bộ dãy bit.        ~ x cho kết quả bằng -13 (111…1110011‬).                &lt;&lt;        Phép dịch bit sang trái. Tất cả các bit của giá trị ở bên trái toán tử sẽ được đẩy sang trái một số bit được chỉ định ở bên phải, các vị trí mới sẽ mang giá trị bằng 0.        x &lt;&lt; 2 cho kết quả bằng 48 (110000).                &gt;&gt;        Phép dịch bit sang phải. Tất cả các bit của giá trị ở bên trái toán tử sẽ được đẩy sang phải một số bit được chỉ định ở bên phải, các vị trí mới sẽ mang giá trị bằng 0.        x &gt;&gt; 2 cho kết quả bằng 3 (11).    Tại sao kiến thức này lại quan trọng?Các phép tính trên bit có vẻ rất lạ đời và không giống như những phép toán phổ thông, nhưng chúng lại rất quan trọng trong lập trình thực tế vì một vài lý do sau:  Thứ nhất, các dãy bit có thể được sử dụng để lưu trữ các giá trị cài đặt. Một giá trị int có tất cả 32 bit, điều này có nghĩa là ta có thể lưu trữ giá trị của 32 giá trị true/false khác nhau, thay vì sử dụng nhiều giá trị bool. Vì lý do đó, các dãy bit có thể được truyền vào các hàm và chương trình con để tùy chỉnh cho hàm và chương trình con đó. Lệnh fstream.open() được đề cập trong các bài trước sử dụng mode là một giá trị bitmask, sử dụng phép toán bit để cài đặt cho hàm.  Thứ hai, các phép toán trên bit có vận tốc cao hơn rất nhiều so với các phép toán bình thường - do chúng trực tiếp xử lý trên bit, thay vì đi qua các bước trung gian. Các phép tính &lt;&lt; và &gt;&gt; có thể được sử dụng thay thế phép nhân lũy thừa của 2 và chia lũy thừa của 2 (bạn đọc tự chứng minh tính đúng đắn ở đây). Nếu ta muốn xét một số là số lẻ hay số chẵn, thay vì kiểm tra bằng phép toán x % 2 == 0 (phép tính mod là một trong những phép tính chậm nhất của chương trình), ta có thể kiểm tra x &amp; 1 == 0. Nếu bạn tham gia lập trình thi đấu, tốc độ là một yếu tố vô cùng quan trọng.  Thứ ba, các bài tập về bit cũng là một trong những dạng bài tập thường thấy của lập trình thi đấu.Toán tử gánCác phép gán cho phép ta đặt giá trị cho biến.Với giá trị x = 10, ta có các phép gán sau:            Toán tử        Ý nghĩa        Ví dụ                =        Gán giá trị bên trái bằng giá trị bên phải.        x = 20 sẽ đặt giá trị của x thành 20                +=        Thực hiện phép cộng với giá trị ở bên phải, sau đó gán cho giá trị ở bên trái (hay có thể hiểu là \"tăng giá trị ở bên trái lên bằng bên phải\").        x += 10 có ý nghĩa giống như x = x + 10.                -=, *=, /=, %=, &lt;&lt;=, &gt;&gt;=, &amp;=, |=, ^=        Tương tự với phép gán cộng, các phép gán này sẽ thực hiện phép toán rồi gán cho giá trị ở bên trái.            Các toán tử đặc biệtNgoài các loại toán tử được liệt kê ở trên, ta còn một số toán tử đặc biệt:  sizeof(): Trả lại kích cỡ của giá trị bên trong ngoặc, tính theo byte. Ví dụ:int a;cout &lt;&lt; sizeof(a);Output:4  giá_trị_bool? x : y: Nếu như giá trị bool trước dấu hỏi là true, toán tử này trả lại giá trị thứ nhất. Nếu là false, trả lại giá trị thứ hai. Ví dụint a = 10;cout &lt;&lt; (a &gt; 5? \"Bigger\" : \"Smaller\");Output:Bigger  ,: Cho phép thực hiện một loạt các biểu thức trong cùng một câu lệnh, theo đúng thứ tự được liệt kê. Giá trị của cả nhóm biểu thức sẽ bằng giá trị của biểu thức cuối cùng. Ví dụ:int a = 10;cout &lt;&lt; (a *= 2, a ++, a -= 3);Output18  . và -&gt;: Cho phép truy cập vào các yếu tố của cấu trúc dữ liệu và class. Sẽ được giải thích trong các bài viết sau.  &amp;: Khi được đặt trước một biến, &amp; trở thành toán tử địa chỉ, trả lại địa chỉ của ô bộ nhớ (con trỏ) của biến.  *: Khi được đặt trước một biến con trỏ, * trở thành toán tử địa chỉ, trả lại giá trị trong ô bộ nhớ đó. Hai toán tử con trỏ sẽ được giải thích trong các bài viết sau.Thứ tự tính toánGiống như trong môn toán có thứ tự thực hiện phép tính, các toán tử trong C++ cũng có thứ tự thi hành.Các toán tử toán bình thường sẽ thực hiện đúng theo thứ tự trong toán học bình thường (nhân chia trước, công trừ sau).Phép tính % sẽ ngang hàng với phép nhân chia.Phép toán ++ và -- được đặt trước giá trị sẽ được thực hiện trước mọi phép toán khác.Các phép toán con trỏ, sizeof(), các phép NOT sẽ được thực hiện sau ++ và --, nhưng trước các phép toán bình thường.Các phép toán bit và logic sẽ thực hiện sau phép toán thường., sẽ được thực hiện sau mỗi phép toán nó phân cách.++ và -- được đặt sau giá trị sẽ được thực hiện sau khi dòng lệnh kết thúc.Phần sau: [C++ Cơ bản] Phần 11: Hàm - Chương trình con",
              url: "/article/c-co-ban-phan-10-toan-tu-tiep"
            }
            ,

            {
              title: "[Lý thuyết đồ thị cơ bản] Phần 5: DAG và sắp xếp topo trên đồ thị",
              author: "Phương Nguyễn",
              category: ["article"],
              tag: ["lý-thuyết-đồ-thị-cơ-bản"],
              content: "Phần trước: [Lý thuyết đồ thị cơ bản] Phần 4: Đường đi ngắn nhất trên đồ thị và thuật toán DijkstraChu trìnhTheo wikipedia, trong lý thuyết đồ thị, chu trình trong đồ thị là một dây chuyền đóng. Đồ thị chỉ gồm một chu trình với \\(n\\) đỉnh được gọi là đồ thị vòng, ký hiệu \\(Cn\\).Các loại chu trình:  Chu trình chẵn: là chu trình có độ dài chẵn.  Chu trình lẻ: là chu trình có độ dài lẻ.  Chu trình có hướng: là một chu trình đơn mà mọi cung trong đó đều cùng hướng, nghĩa là mọi đỉnh đều có bậc trong và bậc ngoài bằng 1. Có thể gọi đơn giản là chu trình khi ngữ cảnh rõ ràng.  Chu trình đơn: là chu trình không chứa cùng một cạnh quá một lần. Trong đồ thị ở hình trên, \\( (1, 5, 2, 1) \\) là một chu trình đơn. Nếu không chỉ rõ, chu trình thường được hiểu là một chu trình đơn. (Nó có thể đi qua một điểm nhiều lần)  Chu trình Euler: là chu trình qua tất cả các cạnh, mỗi cạnh đúng một lần.  Chu trình bao trùm: là cách gọi khác của chu trình Hamilton.Ở đây chúng ta sẽ nhắc đến chu trình có hướng và cách phát hiện ra chu trình trên đồ thị có hướng bằng DFS (có rất nhiều cách để phát hiện chu trình nhưng DFS thông dụng nhất, và một cách khác sẽ được nói ở mục dưới). Trong một số bài giảng, thường sẽ phân loại cạnh thu được sau DFS và sẽ có hai loại gọi là tree edge và backedge, nhưng mình sẽ nói đơn giản cách kiểm tra một đồ thị có hướng có tồn tại chu trình hay không.Thuật toán đơn giản là, trong quá trình DFS thăm tới đỉnh \\( u \\), nếu khi ta xét tới một đỉnh \\( v \\) kề với đỉnh \\( u \\) mà đã được thăm rồi và quá trình thăm chưa kết thúc, khi đó đồ thị sẽ tồn tại chu trình.Dễ dàng chứng minh tính đúng đắn của thuật toán. Phương pháp cài đặt được trình bày ở dưới.DAG (Directed Acyclic Graph)Một đồ thị có hướng \\( G = (V, E) \\) được gọi là một DAG khi đồ thị đó không có chu trình có hướng.Sắp xếp topo trên đồ thịCông việcCho đồ thị có hướng không chu trình (DAG). Tìm cách sắp xếp thứ tự các đỉnh sao cho với mọi cung từ \\( u \\) đến \\( v \\) trong đồ thị, \\( u \\) luôn nằm trước \\( v \\).Thuật toánThuật toán để tìm thứ tự topo gọi là thuật toán sắp xếp topo. Mỗi DAG luôn có ít nhất một thứ tự topo và có thuật toán tuyến tính để tìm nó.Cách 1:Ý tưởng: Thêm ngẫu nhiên một đỉnh \\( u \\) không có cung vào ở trạng thái hiện tại của đồ thị vào trong mảng topo, bỏ tất cả các cung đi ra từ \\( u \\) đi và lặp lại như bước đầu cho tới khi tập đỉnh của đồ thị hiện tại rỗng.Xem xét:  Thuật toán này được phát hiện bởi Kahn vào năm 1962.  Khi ta thêm một đỉnh \\( u \\) ngẫu nhiên không có cung vào ở trạng thái hiện tại của đồ thị vào mảng topo, tất cả các cung vào \\( u \\) ở đồ thị ban đầu đều xuất phát từ các đỉnh đứng trước \\( u \\) trong mảng topo đi tới \\( u \\) do bước bỏ các cung đi ra từ một đỉnh đã được sắp xếp.  Nếu đồ thị tồn tại trạng thái không tồn tại một đỉnh không có cung vào mà tập cạnh khi đó khác rỗng, hoặc số lượng đỉnh trong mảng topo khác \\( \\mid V \\mid \\) thì chứng tỏ đồ thị có chu trình, và không phải một DAG.Độ phức tạp của thuật toán là \\( O( \\mid V \\mid + \\mid E \\mid) \\).Cài đặt bằng C++:vector&lt;int&gt; g[maxn];int n, m;                                   //số lượng đỉnh và cạnhint deg[maxn];                              //lưu số lượng cung vào.int x[maxn], slx, q[maxn], R;   //x là mảng thứ tự topo, q là hàng đợi chứa các đỉnh                                 //không có cung vào ở trạng thái hiện tạivoid sxtopo(){    for(int u=1; u&lt;=n; ++u) if(deg[u]==0) q[++R]=u;    while(R)    {        int u=q[R--];        x[++slx]=u;        for(int i=0; i&lt;g[u].size(); ++i)        {            int v=g[u][i];            --deg[v];            if(deg[v]==0) q[++R]=v;        }    }    if(slx&lt;n) cout&lt;&lt; \"!DAG\";}Cách 2:Ý tưởng: Sau khi duyệt DFS trên đồ thị, ta sẽ có một mảng kết quả lưu các đỉnh theo thứ tự thăm xong trước tới sau, mảng này chính là trật tự topo.Xem xét:  Tìm kiếm theo chiều sâu trên đồ thị (DFS) có thể dùng giải thuật này để tạo một danh sách tuyến tính các đỉnh của một đồ thị. Có ba cách hiện thực phương pháp này, một trong số đó là duyệt đảo hậu thứ tự (reverse postordering). Với các đồ thị có hướng không có chu trình, cách duyệt đảo hậu thứ tự cho ra một trật tự topo của đồ thị đó.  Với phương pháp sắp xếp topo bằng DFS, nếu đồ thị không phải là DAG thì ta vẫn có một thứ tự, nhưng ta lại có thế dùng DFS để kiểm tra luôn xem đồ thị có là DAG hay không.  Chứng minh thứ tự nhận được thỏa mản là một trật tự topo: Giả sử tồn tại một đỉnh \\( u \\) đứng trước một đỉnh \\( v \\) trong mảng kết quả mà có cung đi từ \\( v \\) tới \\( u \\). Khi đó do quá trình DFS \\( u \\) được thăm trước \\( v \\), nên khi thăm tới \\( v \\), ta xét các đỉnh kề với đỉnh \\( v \\), trong đó \\( u \\) được đánh dấu đã thăm -&gt; đồ thị không phải một DAG -&gt; trái với giả thuyết.Độ phức tạp của thuật toán là \\( O( \\mid V \\mid + \\mid E \\mid) \\).Cài đặt bằng C++:vector&lt;int&gt; g[maxn];int x[maxn], slx;int dd[maxn], kt[maxn];void DFS(int u){    dd[u]=1;    for(int i=0; i&lt;g[u].size(); ++i)    {        int v=g[u][i];        if(dd[v] &amp;&amp; !kt[v])         {            cout&lt;&lt; \"!DAG\";             exit(0);        }        DFS(v);    }    x[++slx]=u;    kt[u]=1;}Ứng dụngSắp xếp topo có rất nhiều ứng dụng quan trọng, đặc biệt là áp dụng quy hoạch động trên mảng trật tự topo.Bài toán tổng số đường điCho đồ thị có hướng không chu trình và 2 đỉnh \\( s \\), \\( t \\). Cho biết có bao nhiêu đường đi từ \\( s \\) đến \\( t \\). (2 đường đi khác nhau nếu thứ tự các đỉnh trên chúng khác nhau)Thuật toán: DFS từ \\( s \\). Gọi f[u] là số đường đi từ \\( u \\) tới \\( t \\). Khi đó f[t]=1.Nếu có một cung đi từ \\( u \\) tới \\( v \\), f[u] += f[v].Cài đặt bằng C++:DFS(s);f[t]=1;for(int i=n; i&gt;=1; --i) {    int u=x[i];    for(int j=0; j&lt;g[u].size(); ++j)    {        int v=g[u][j];        f[u]+=f[v];    }}Bài toán đường đi dài nhấtCho đồ thị có hướng, không có chu trình, có trọng số và 2 đỉnh \\( s \\), \\( t \\). Tìm đường đi dài nhất từ \\( s \\) tới các đỉnh khác.Thuật toán: DFS từ \\( s \\). Gọi f[u] là đường đi dài nhất từ \\( s \\) tới \\( u \\). Khi đó f[s]=0.Nếu có một cung đi từ \\( u \\) tới v, ```f[v]=max(f[v], f[u]+ trọng số cạnh (u,v))``.Cài đặt bằng C++:DFS(s);f[s]=0;for(int i=1; i &lt;= n; ++i) {    int u=x[i];    for(int j=0; j&lt;g[u].size(); ++j)    {        int v=g[u][j].F;\tint w=g[u][j].S;        f[v]=max(f[v], f[u] + w);    }}Một số bài tập thực hànhTOPO2509 - Bài tập của trường Đại học Bách Khoa Hà Nội.NKLEAGUE (SPOJ). Lời giải có tại đây.KCOLLECT (SPOJ).",
              url: "/article/ly-thuyet-do-thi-co-ban-phan-5-dag-va-sap-xep-topo-tren-do-thi"
            }
            ,

            {
              title: "[SPOJ] NKNUMFRE - Số thân thiện",
              author: "houtaru",
              category: ["spoj"],
              tag: ["spoj", "implementation"],
              content: "Link đề bài : http://vnoi.info/problems/show/NKNUMFRE/Đề bài :Số tự nhiên có rất nhiều tính chất thú vị. Ví dụ với số 23, số đảo ngược của nó là 32. Hai số này có ước chung lớn nhất là 1. Những số như thế được gọi là số thân thiện, tức là số 23 được gọi là số thân thiện, số 32 cũng được gọi là số thân thiện.Hãy nhập vào 2 số nguyên a,b (10≤a≤b≤30000). Hãy đếm xem trong khoảng từ a đến b (kể cả a và b) có bao nhiêu số thân thiện.Dữ liệuBao gồm một dòng chứa 2 số a,b. Hai số được cách nhau bằng một khoảng trắngKết quảBao gồm một dòng là kết quả của bài toán.Ví dụDữ liệu20 30\t\tKết quả3Solution : http://viahold.com/1YpNCode : http://viahold.com/1Yno",
              url: "/spoj/spoj-nknumfre-so-than-thien"
            }
            ,

            {
              title: "[SPOJ] NKLUCK - Dãy số may mắn",
              author: "houtaru",
              category: ["spoj"],
              tag: ["spoj", "bit", "data-structure"],
              content: "Link đề bài : http://vnoi.info/problems/show/NKLUCK/Đề bài :Hôm nay là bữa học đầu tiên của lớp đội tuyển sau khi đón chào năm mới 2014. Thầy đã cho các học sinh của mình ăn chơi một ngày. Để lấy hên đầu năm mới thầy đã ghi lên n mẫu giấy một số nguyên công việc này đã được thầy chuẩn bị trước ở nhà. Sau đó thầy úp n mẫu giấy lên bàn để không ai biết. Mỗi người sẽ lên và chọn một đoạn con liên tiếp tùy ý. Một đoạn được gọi là may mắn nếu trung vị của nó đúng bằng X. Trung vị của một dãy số gồm m phần tử là số ở vị trí thứ (m div 2)+1 trong dãy sau khi dãy đã được sắp xếp. Thầy giáo muốn biết xác suất để một học sinh có thể chọn được một dãy số may mắn. Vì đi chơi xuân nhiều quá nên thầy khá mệt mỏi, các bạn hãy giúp thầy giải quyết vấn đề này nhé.Dữ liệu vàoDòng đầu chứa số nguyên dương n và số nguyên X.n dòng tiếp theo mỗi dòng chứa giá trị của số được ghi trên mẫu giấy thứ i.Giới hạnn &lt;= 5*10^5.giá trị tuyệt đối của các số còn lại trong dữ liệu vào &lt;= 10^9.25% số test có n &lt;= 100.50% số test có n &lt;= 500.Dữ liệu raChứa một số duy nhất là kết quả bài toán với đọ sai lệch không quá 0.000001.Ví dụ :Dữ liệu vào:4 11234Dữ liệu ra:0.1Solution : http://viahold.com/1Ye1Code : http://viahold.com/1Y5Y",
              url: "/spoj/spoj-nkluck-day-so-may-man"
            }
            ,

            {
              title: "[SPOJ] ROADS - Roads",
              author: "Accepted Problems",
              category: ["spoj"],
              tag: ["spoj", "graph"],
              content: "Link đề gốc:http://vnoi.info/problems/show/ROADS/Đề bài:Có N thành phố 1..N nối bởi các con đường một chiều. Mỗi con đường có hai giá trị: độ dài và chi phí phải trả để đi qua. Bob ở thành phố 1. Bạn hãy giúp Bob tìm đường đi ngắn nhất đến thành phố N, biết rằng Bob chỉ có số tiền có hạn là K mà thôi.Dữ liệuDòng đầu tiên ghi t là số test.Với mỗi test, dòng đầu ghi K (0 ≤ K ≤ 10000).Dòng 2 ghi N, 2 ≤ N ≤ 100.Dòng 3 ghi R, 1 ≤ R ≤ 10000 là số đường nối.Mỗi dòng trong N dòng sau ghi 4 số nguyên S, D, L, T mô tả một con đường nối giữa S và D với độ dài L ( 1 ≤ L ≤ 100) và chi phí T (0 ≤ T ≤ 100). Lưu ý có thể có nhiều con đường nối giữa hai thành phố.Kết quảVới mỗi test, in ra độ dài đường đi ngắn nhất từ 1 đến N mà tổng chi phí không quá K. Nếu không tồn tại, in ra -1.Ví dụDữ liệu25671 2 2 32 4 3 33 4 2 41 3 4 14 6 2 13 5 2 05 4 3 20441 4 5 21 2 1 02 3 1 13 4 1 0Kết quả11-1Solution:Tham khảo tại: http://viahold.com/1t7xCode:Tham khảo tại: http://viahold.com/1Z4I",
              url: "/spoj/spoj-roads-roads"
            }
            ,

            {
              title: "Codeforces Round #428 (Div. 2)",
              author: "Admin Tổng Quản",
              category: ["codeforces"],
              tag: ["codeforces"],
              content: "Vào lúc 21:35 ngày 12/8/2017 theo giờ Việt Nam, Codeforces Round #428 sẽ được tổ chức dành cho Div. 2. Contest có 5 bài và diễn ra trong 2 tiếng đồng hồ.Các nhân vật trong bài tập được lấy tên dựa trên series Game of Throne đình đám.Đề bài được dịch trực tiếp bởi thành viên của nhóm Cowboy Coder tại đây.Solution của contest sẽ được update sau khi contest kết thúc.Update: solution của contesthttp://viahold.com/1zOF",
              url: "/codeforces/codeforces-round-428-div-2"
            }
            ,

            {
              title: "[SPOJ] C11ID - Mã số",
              author: "houtaru",
              category: ["spoj"],
              tag: ["spoj", "implementation"],
              content: "Link đề bài : http://vnoi.info/problems/show/C11ID/Đề bài :Đất nước C11 sắp tiến hành cấp N mã số khác nhau cho N người dân để tiện việc quản lí. Để việc cấp mã số mang tính dân chủ, mỗi người dân được quyền chọn một số max và chính quyền sẽ cấp cho người đó một mã số là một số tự nhiên có giá trị từ 1 đến max.Nhiệm vụ của bạn là đếm xem có bao nhiêu cách cấp mã số khác nhau cho N người này.Dữ liệuDòng 1: Số nguyên dương N.Dòng i trong N dòng tiếp theo: Số nguyên dương maxi.Kết quảPhần dư khi chia số cách cấp mã số khác nhau cho k. Với k là số nguyên tố nhỏ nhất lớn hơn 109.Giới hạn1 ≤ N ≤ 10^5.1 ≤ maxi ≤ 10^9.Ví dụInput 1:213Output 1:2Input 2:44444 Output 2:24 Giải thích:- Ví dụ 1: Có 2 cách cấp mã số là { 1, 2 } hoặc { 1, 3 }.- Ví dụ 2: Số cách cấp mã số là số hoán vị của tập (1, 2, 3, 4).Solution : http://viahold.com/1Xd7Code : http://viahold.com/1XeB",
              url: "/spoj/spoj-c11id-ma-so"
            }
            ,

            {
              title: "[SPOJ] MBEEWALK - Bee Walk",
              author: "Accepted Problems",
              category: ["spoj"],
              tag: ["spoj", "dp"],
              content: "Link đề gốc:http://vnoi.info/problems/show/MBEEWALK/Đề bài:Đếm số cách đi của của 1 con ong. Nó bắt đầu từ tổ của nó, đi ra ngoài và đi về tổ ở bước thứ n. Ở mỗi ô, nó có thể đi sang 1 trong 6 ô kề cạnh.InputDòng đầu ghi số test, mỗi dòng tiếp theo là 1 test, gồm 1 số n, 1 ≤ n ≤ 14.SAMPLE INPUT224OutputMỗi kết quả ghi trên 1 dòng, kết quả &lt;= 2^31.SAMPLE OUTPUT690Solution:Tham khảo tại: http://viahold.com/1XduCode:Tham khảo tại: http://viahold.com/1XcT",
              url: "/spoj/spoj-mbeewalk-bee-walk"
            }
            ,

            {
              title: "[SPOJ] SOPENP - Khai bút đầu xuân",
              author: "houtaru",
              category: ["spoj"],
              tag: ["spoj", "data-structute", "two-pointer"],
              content: "Link đề bài : http://vnoi.info/problems/show/SOPENP/Đề bài :Mùng 1 Tết, Nuga quyết định khai bút đầu xuân bằng cách giải một bài tập tin rất khó mà bạn ấy đã thấy trong một giấc mơ.Cho một dãy số nguyên dương. Tính xem có bao nhiêu dãy con gồm các phần tử liên tiếp của nó mà có số lượng phần tử khác nhau nằm trong khoảng [L, U].Sau 2 tiếng ngồi cắn bút mà không giải xong, Nuga quyết định nhờ các bạn đội tuyển tin giúp đỡ. Nuga sẽ rất biết ơn nếu các bạn giải được bài tập này, và bạn ấy sẽ lì xì cho các bạn nhân dịp đầu năm mới.Dữ liệuDòng đầu tiên chứa các số nguyên dương N, L, U. Sau đó là N dòng, mỗi dòng chứa một số nguyên dương X là một phần tử của dãy số.Kết quảMột dòng duy nhất chứa một số nguyên thể hiện số dãy con có số lượng phần tử khác nhau nằm trong khoảng từ L .. U.Giới hạn1 ≤ L ≤ U ≤ N ≤ 2^201 ≤ X ≤ 2^31 - 1Ví dụDữ liệu:4 1 223119719Kết quả:8Solution : http://viahold.com/1XTPCode : http://viahold.com/1X85",
              url: "/spoj/spoj-sopenp-khai-but-dau-xuan"
            }
            ,

            {
              title: "[SPOJ] MSTRING - String problem",
              author: "Joker",
              category: ["spoj"],
              tag: ["spoj", "string"],
              content: "Link đề bài gốc:http://vnoi.info/problems/show/MSTRING/Đề bài:Cho hai xâu A và B. Tính độ dài của xâu con đài nhất của A mà không là xâu con của B. Xâu con không nhất thiết phải gồm các kí tự liên tiếp.InputHai dòng là hai xâu A, B, độ dài &lt;=1000, chỉ gồm các chữ cái ‘a’..’z’.OutputIn ra độ dài nhỏ nhất tìm đượcVí dụ:Sample input 1 banana anbnaanbaan  Sample output 1 5  (eg. banna) Sample input 2 babab babba  Sample output 2 3  (eg. aab) Solution:Tham khảo tại: http://viahold.com/1XewCode:Tham khảo tại: http://viahold.com/1XTW",
              url: "/spoj/spoj-mstring-string-problem"
            }
            ,

            {
              title: "[SPOJ] NKINV - Dãy nghịch thế",
              author: "Joker",
              category: ["spoj"],
              tag: ["spoj", "tree"],
              content: "Link bài gốc:http://vnoi.info/problems/show/NKINV/Đề bài:Cho một dãy số a1.. aN. Một nghịch thế là một cặp số u, v sao cho u &lt; v và a[u ] &gt; a[v]. Nhiệm vụ của bạn là đếm số nghịch thế.Dữ liệu  Dòng đầu ghi số nguyên dương N.  N dòng sau mỗi dòng ghi một số ai( 1 ≤ i ≤ N ).Kết qủaGhi trên một dòng số M duy nhất là số nghịch thế.Giới hạn  1 ≤ N ≤ 60000  1 ≤ ai≤ 60000Ví dụ:Input:3312Output:2Solution:Tham khảo tại: http://viahold.com/1XHBCode:Tham khảo tại: http://viahold.com/1X4L",
              url: "/spoj/spoj-nkinv-day-nghich-the"
            }
            ,

            {
              title: "[SPOJ] VO17SORT - Exploding kittens",
              author: "houtaru",
              category: ["spoj"],
              tag: ["implementation", "bfs", "spoj"],
              content: "Link đề bài : http://vnoi.info/problems/show/VO17SORT/Đề bài :Trong lúc rảnh rỗi, Thắng dễ thương cùng đồng nghiệp trong công ty thực phẩm Con Heo Vàng chơi mèo nổ. Đỏ bạc đen tình, Thắng liên tục rút được lá Alter the future, giúp Thắng được sắp xếp các lá bài trên bài theo ý muốn.Hiện tại, trên bàn còn N lá bài xếp thành chồng. Mỗi lá bài có một nhãn hiệu là số nguyên phân biệt từ 1 tới N. Để sắp xếp, tại mỗi bước, Thắng sẽ lấy ra một dãy con liên tiếp của chồng bài, đưa lại dãy này vào một vị trí khác. Thứ tự của các lá bài trong đoạn con được rút ra cũng như trong phần còn lại của bộ bài không được phép thay đổi. Ví dụ, nếu hiện tại chồng bài đang là “2 3 5 1 4 7 6”, Thắng có thể xếp lại thành “2 5 1 4 7 3 6”. Từ “1 4 3 6 7 2 5” sang “6 7 2 5 1 4 3” cũng là một phép sắp xếp hợp lệ.Để gài bẫy cô bạn KTH của mình, Thắng sẽ sắp xếp chồng bài về thứ tự chuẩn, nghĩa là “1 2 3 … N”. Tuy nhiên, sợ ý đồ bị bại lộ, Thắng sẽ không thực hiện việc sắp xếp nếu như cần nhiều hơn 4 bước chuyển.Hãy giúp Thắng đễ thương tìm ra số bước tối thiểu cần sắp xếp nhé.InputDòng đầu tiên chứa số nguyên T là số lượng test.Trong các dòng tiếp theo, mỗi test được mô tả bởi hai dòng: Dòng trên chứa số nguyên N, dòng dưới chứa một hoán vị của N số nguyên dương bé nhất - là thứ tự của chồng bài lúc ban đầu.OutputGhi ra kết quả của mỗi test trên một dòng, là số bước tối thiểu cần để xếp chồng bài về thứ tự “1 2 3 .. N”, hoặc “5 or more” nếu cần ít nhất 5 bước để sắp xếp.Giới hạnTrong 30% số test, N &lt;= 3.Trong 70% số test, N &lt;= 7.Trong 100% số test, N &lt;= 15.Trong lúc thi bài của bạn chỉ được chấm với test ví dụ.Input:531 2 341 3 4 277 6 5 4 2 1 31010 7 5 8 1 2 9 3 4 6158 15 12 1 10 3 7 4 6 9 5 2 11 14 13Output:01445 or more Solution : http://viahold.com/1WwjCode : http://viahold.com/1Wqh",
              url: "/spoj/spoj-vo17sort-exploding-kittens"
            }
            ,

            {
              title: "[SPOJ] ACQUIRE - Land Acquisition",
              author: "houtaru",
              category: ["spoj"],
              tag: ["spoj", "dp", "convex-hull"],
              content: "Link đề bài : http://www.vnoi.info/problems/show/ACQUIRE/Đề bài :Cho N(N≤50000) hình chữ nhật khác nhau về hình dạng, mục tiêu của bài toán là phải lấy được tất cả hình chữ nhật. Một tập hình chữ nhật có thể thu được với chi phí bằng tích của chiều dài dài nhất và chiều rộng dài nhất. Chúng ta cần phân hoạch tập các hình chữ nhật này một cách khôn khéo sao cho tổng chi phí có thể được tối thiểu hóa và tính chi phí này. Hình chữ nhật không thể được xoay (đổi chiều dài và chiều rộng).Input :  Dòng đầu là số N.  N dòng tiếp theo, mỗi dòng là 2 số w, l lần lượt là chiều dài và chiều rộng của các hình chữ nhật.Output :  Gồm 1 dòng là tổng chi phí bé nhất.Input :4100 115 1520 51 100Output :500Giải thích :Chia làm 3 phần là (1), (2, 3), (4) &lt;=&gt; 100 x 1 + 20 x 15 + 1 x 100 = 500Solution : http://viahold.com/1V3ZCode : http://viahold.com/1V48",
              url: "/spoj/spoj-acquire-land-acquisition"
            }
            ,

            {
              title: "[SPOJ] VMUNCH - Gặm cỏ",
              author: "rknguyen",
              category: ["spoj"],
              tag: ["spoj", "bfs", "graph"],
              content: "Link gốchttp://vnoi.info/problems/show/VMUNCH/Đề bàiBessie rất yêu bãi cỏ của mình và thích thú chạy về chuồng bò vào giờ vắt sữa buổi tối.Bessie đã chia đồng cỏ của mình là 1 vùng hình chữ nhật thành các ô vuông nhỏ với R (1 &lt;= R &lt;= 100) hàng và C (1 &lt;= C &lt;= 100) cột, đồng thời đánh dấu chỗ nào là cỏ và chỗ nào là đá. Bessie đứng ở vị trí R_b,C_b và muốn ăn cỏ theo cách của mình, từng ô vuông một và trở về chuồng ở ô 1,1 ; bên cạnh đó đường đi này phải là ngắn nhất.Bessie có thể đi từ 1 ô vuông sang 4 ô vuông khác kề cạnh.Dưới đây là một bản đồ ví dụ [với đá (’*’), cỏ (’.’), chuồng bò (‘B’), và Bessie (‘C’) ở hàng 5, cột 6] và một bản đồ cho biết hành trình tối ưu của Bessie, đường đi được dánh dấu bằng chữ ‘m’.Input      Dòng đầu là N, M (N &lt;= 800, M là số lượng liên lạc 1 chiều)        Một số dòng tiếp theo mỗi dòng gồm 2 số u , v cho biết học sinh u có thể gửi tin tới học sinh v  Output  Gồm 1 dòng ghi số học sinh cần thầy nhắn tin.Ví dụInput5 6B...*...*....**.*...***.*..*.COutput9Giải thích   Bản đồ               Đường đi tối ưu1 2 3 4 5 6  &lt;-cột      1 2 3 4 5 6  &lt;-cột1 B . . . * .           1 B m m m * .2 . . * . . .           2 . . * m m m3 . * * . * .           3 . * * . * m4 . . * * * .           4 . . * * * m5 * . . * . C           5 * . . * . mSolutionhttp://viahold.com/1TQxCode mẫuhttp://viahold.com/1TOv",
              url: "/spoj/spoj-vmunch-gam-co"
            }
            ,

            {
              title: "[SPOJ] KGSS - Maximum Sum",
              author: "itsjustwinds",
              category: ["spoj"],
              tag: ["data-structure", "spoj"],
              content: "Đề: http://vnoi.info/problems/show/KGSS/Cho N&lt;=1e5 số. cho Q&lt;=1e5 truy vấnCó 2 loại truy vấn:  U i x: đổi phần tử tại vị trí i thành x  Q x y: tìm tổng của phần tử lớn nhất và lớn nhì trong đoạn x đến yExampleInput:51 2 3 4 56Q 2 4Q 2 5U 1 6Q 1 5U 1 7Q 1 5Output:791112Hướng dẫnhttp://viahold.com/1T8PCodehttp://viahold.com/1T8q",
              url: "/spoj/spoj-kgss-maximum-sum"
            }
            ,

            {
              title: "[SPOJ] QBSEGPAR - VOI05 Phân đoạn",
              author: " houtaru",
              category: ["spoj"],
              tag: ["spoj", "dp", "bit", "binary-search", "data-structure"],
              content: "Link đề bài : http://vnoi.info/problems/show/QBSEGPAR/Đề bài :Cho dãy số nguyên a1, a2, …, an và số nguyên dương k. Ta gọi k-phân đoạn của dãy số đã cho là cách chia dãy số đã cho ra thành k đoạn, mỗi đoạn là một dãy con gồm các phần tử liên tiếp của dãy. Chính xác hơn, một k-phân đoạn được xác định bởi dãy chỉ số1 &lt;= n1 &lt; n2 &lt; n3 &lt; … &lt; nk = nĐoạn thứ i là dãy con ani-1+1, ani-1+2, …, ani, i=1, 2, ..k. Ở đây quy ước n0=0Yêu cầu:Hãy xác định số M nhỏ nhất để tồn tại k-phân đoạn sao cho tổng các phần tử trong mỗi đoạn đều không vượt quá M.InputDòng đầu tiên chứa hai số nguyên n và k (1≤ k ≤ n ≤ 15000).            Dòng thứ i trong số n dòng tiếp theo chứa số nguyên ai (      ai      ≤ 30000), i =1, 2, …, n.      Các số cạnh nhau trên một dòng trong file dữ liệu cách nhau ít nhất một dấu cách.OutputGồm một số nguyên duy nhất là giá trị M tìm được.Input:9 4111322131Output:5Solution:http://viahold.com/1S0gCode:http://viahold.com/1S1A",
              url: "/spoj/spoj-qbsegpar-voi05-phan-doan"
            }
            ,

            {
              title: "[SPOJ] VMTRIP - Dời Đô xứ Dừa",
              author: "itsjustwinds",
              category: ["spoj"],
              tag: ["dfs", "bfs", "spoj"],
              content: "Đề: http://vnoi.info/problems/show/VMTRIP/Sau khi thống nhất vương quốc dừa một thời gian, vị vua mới là Pirakute lại ăn ngủ không yên vì tình trạng đất nước vẫn chưa được ổn định, lạm phát dừa làm cho đất nước ngày một yếu đi, trái dừa lại dần có nguy cơ bị lạm dụng trở thành vũ khí để chọi nhau như ngày nào… Một đêm nọ Pirakute nằm mơ, thấy rằng một trong những hòn đảo xa xôi trong vương quốc của mình bỗng mọc lên một cây dừa vàng khổng lồ. Thế là sáng hôm sau tỉnh dậy, Pirakute đã nghĩ rằng : “Có thể rằng kinh đô trên hòn đảo mà ta đang ở có phong thủy không được tốt nên đất nước mới suy yếu, lẽ chăng ta nên dời đô đến hòn đảo mà ta đã nhìn thấy trong mơ !?”Thế là ngay lập tức Pirakute đã cho triệu hồi quân thần và bàn kế sách dời đô. Sau khi nghiên cứu toàn bộ hệ thống đảo trên vương quốc dừa thì hiện toàn vương quốc có tổng cộng N đảo, được đánh số từ 1 tới N. Ngoài ra còn có M cây cầu dừa, mỗi cây cầu dừa nối một cặp hòn đảo với nhau để mọi người có thể đi từ hòn đảo này đến hòn đảo khác. Trong các hòn đảo của vương quốc, S là hòn đảo kinh đô hiện tại của vương quốc, và T chính là hòn đảo mà Pirakute đã mơ thấy và sẽ dời đô đến. Một hành trình đi từ S đến T qua các cây cầu dừa có độ dài bằng số lượng hòn đảo phân biệt phải đi qua trên hành trình đó. Để tiết kiệm chi phí dời đô, Pirakute quyết định sẽ chọn một hành trình dời đô có độ dài ngắn nhất. Tuy nhiên Pirakute nhận thấy rằng có rất nhiều cách chọn hành trình như vậy. Vốn rất thích các dãy số hoán vị nên sau một hồi suy nghĩ Pirakute đã nghĩ ra cách để chọn hành trình dời đô thích hợp:  Gọi K là số hòn đảo phải đi qua trên hành trình dời đô ngắn nhất đi từ S đến T.  Pirakute sẽ chọn một dãy hoán vị các số từ1 đến K: p[1], p[2], …, p[K]. Gọi là dãy hoán vị p  Trong các hành trình dời đô ngắn nhất(đi qua đúng K đỉnh) từ S đến T. Pirakute sẽ chọn hành trình có thứ tự từ điển nhỏ nhất theo dãy hoán vị p.  Nếu gọi a[1], a[2], …, a[K]là chỉ số của các hòn đảo phải đi qua của hành trình A. b[1], b[2], …,b[K]là chỉ số các hòn đảo phải đi qua của hành trình B. Khi đó ta nói hành trình A có thứ tự từ điển theo nhỏ hơn theo dãy hoán vị p so với hành trình B khi và chỉ khi tồn tại một số i(1 ≤i≤K)sao cho:      a[p[1]] = b[p[1]]; a[p[2]] = b[p[2]]; … a[p[i-1]] = b[p[i-1]];    a[p[i]] &lt; b[p[i]];Tuy nhiên do có quá nhiều cách chọn hành trình dời đô nên Pirakute không thể tìm ra được hành trình dời đô thích hợp. Bạn hãy giúp Pirakute tìm ra hành trình dời đô này nhé.Input  Dòng đầu tiên gồm 4 số N, M, S và T  M dòng tiếp theo, mỗi dòng gồm 2 số u và v là chỉ số của 2 hòn đảo mà có cây cầu nối với nhau  Dòng cuối cùng là K số của dãy hoán vị p. (Chú ý giá trị K sẽ không được cho trước mà bạn cần phải tìm ra theo yêu cầu của bài toán).  Dữ liệu luôn đảm bảo:  Có nhiều nhất một cây cầu dừa nối trực tiếp giữa 2 hòn đảo bất kì.  Tồn tại ít nhất một đường đi từ S đến T.Output  Dòng duy nhất gồm K số là chỉ số của các hòn đảo phải đi qua theo thứ tự của hành trình dời đô từ S đến T.Giới hạn:  Trong 20% số test: 1 ≤N ≤ 5000; 1 ≤M ≤ 10000;  Trong tất cả các test: 1 ≤N ≤ 100000; 1 ≤M ≤ 300000;  1 ≤S ≤N;  1 ≤T ≤N;  S luôn khác với T.Chấm điểm  Bài của bạn sẽ được chấm trên thang điểm 100. Điểm mà bạn nhận được sẽ tương ứng với % test mà bạn giải đúng.  Trong quá trình thi, bài của bạn sẽ chỉ được chấm với 1 test ví dụ có trong đề bài.  Khi vòng thi kết thúc, bài của bạn sẽ được chấm với bộ test đầy đủ.ExampleInput:9 9 1 91 21 32 53 43 75 86 76 98 94 1 2 5 3Output:1 3 7 6 9Hướng dẫnhttp://viahold.com/1SJFcodehttp://viahold.com/1SJV",
              url: "/spoj/spoj-vmtrip-doi-do-xu-dua"
            }
            ,

            {
              title: "[SPOJ] MDOLLS - Nested Dolls",
              author: "CVHvn",
              category: ["spoj"],
              tag: ["SPOJ", "DP", "data-structure", "binary-search"],
              content: "Link đề bài : http://vnoi.info/problems/show/MDOLLS/Đề bài :“Dilworth” có một bộ sưu tập các con búp bê Nga.  Búp bê với chiều rộng w1 và chiều cao h1 sẽ nằm trong được con lật đật chiều rộng w2 và chiều cao h2nếu w1 &lt; w2 và h1 &lt; h2. Tính số lớp búp bê bao nhau ít nhất mà có thể tạo ra được từ các búp bê ban đầu.Input :Dòng đầu là số test,  1 ≤ t ≤ 20. Mỗi test bắt đầu là số nguyên m, 1 ≤ m ≤ 20000, số lượng búp bê ban đầu. Dòng tiếp theo là 2m số nguyên w1, h1,w2, h2,… ,wm, hm, là chiều rộng và chiều cao của con búp bê thứ i, 1 ≤ wi, hi ≤ 10000.Output :Ghi số lớp búp bê bao nhau ít nhất có thể trên một dòng cho từng test.Solution:http://viahold.com/1RRRCode:http://viahold.com/1ROJ",
              url: "/spoj/spoj-mdolls-nested-dolls"
            }
            ,

            {
              title: "[C++ Cơ bản] Phần 9: Toán tử",
              author: "Admin Tổng Quản",
              category: ["article"],
              tag: ["cpp-cơ-bản", "programming"],
              content: "Phần trước: [C++ Cơ bản] Phần 8: Input và Output (tiếp)Toán tử (operator) là các ký hiệu nhằm yêu cầu chương trình thực hiện các phép xử lý toán học, logic, vân vân… Toán tử có thể chia làm 6 loại:  Các kí hiệu phép tính đại số  Các kí hiệu so sánh  Các toán tử logic  Các toán tử trên bit  Các toán tử gán  Các toán tử đặc biệtBài viết này sẽ đề cập tới ba loại toán tử đầu tiên, đó là các kí hiệu phép tính đại số, các kí hiệu so sánh và các toán tử logic.Kí hiệu phép tính đại sốĐây là loại kí hiệu gần gũi nhất với chúng ta - chúng chính là các dấu cộng, trừ, nhân, chia hằng ngày, cùng với một vài phép tính nữa.Giả sử chúng ta có hai giá trị x = 20 và y = 16. Các phép tính đại số trong C++ bao gồm:            Toán tử        Ý nghĩa        Ví dụ                +        Cộng        x + y cho ra kết quả 36                -        Trừ        x - y cho ra kết quả 4                *        Nhân        x * y cho ra kết quả 320                /        Chia. Đối với số nguyên, giá trị trả lại sẽ bằng phần nguyên của kết quả. Đối với số thực, giá trị trả lại sẽ là đầy đủ kết quả.        Nếu như x và y thuộc kiểu số nguyên, x / y cho ra kết quả 1Nếu như x hoặc y thuộc kiểu số thực, x / y cho ra kết quả 1.25                %        Lấy phần dư của phép chia với số nguyên        x % y cho ra kết quả 4                ++        Phép toán cộng 1 lên đối tượng. Có thể đặt trước, hoặc đặt sau đối tượng, nhưng sẽ có sự khác nhau.        x++ cho ra kết quả 21. Giá trị của x trở thành 21.                --        Phép toán trừ 1 lên đối tượng. Có thể đặt trước, hoặc đặt sau đối tượng, nhưng sẽ có sự khác nhau.        x-- cho ra kết quả 19. Giá trị của x trở thành 19.                ()        Dấu ngoặc trong phép tính\t            Kiểu dữ liệu trong phép tínhC++ sẽ cố gắng chuyển đổi kiểu dữ liệu trong phép toán để tránh sự xung đột trong nội bộ phép toán (ví dụ khi nhân số nguyên với số thực, nhân giá trị kiểu int với giá trị kiểu long long int).Ví dụ thứ nhất: Chạy chương trình sau đây#include &lt;iostream&gt;using namespace std;int main(){    int x = 300000;    int y = 200000;    cout &lt;&lt; x * y;    return 0;}Output-129542144Tại sao lại ra kết quả như vậy? Ta thấy trong phép nhân này, các giá trị được sử dụng đều là kiểu int - giá trị trả lại sẽ là kiểu int. Do kết quả giới hạn biểu diễn của int, phép toán cho ra kết quả sai.Để cho ra kết quả đúng, ta phải chỉnh lại kiểu dữ liệu của phép toán thành long long int:#include &lt;iostream&gt;using namespace std;int main(){    int x = 300000;    long long int y = 200000;    cout &lt;&lt; x * y;    return 0;}Output60000000000Ví dụ thứ hai: Phép chia hai số nguyên#include &lt;iostream&gt;using namespace std;int main(){    int x = 3;    int y = 2;    cout &lt;&lt; x / y;    return 0;}Output1Lý do kết quả của phép chia chỉ có phần nguyên, là do kiểu dữ liệu của cả hai biến đều là int, do đó phép chia sẽ trả lại kết quả kiểu int và bị cắt bỏ phần thập phân.Để có kết quả có phần thập phân, ta phải thực hiện phép chia có số thực#include &lt;iostream&gt;using namespace std;int main(){    int x = 3;    double y = 2;    cout &lt;&lt; x / y;    return 0;}Output1.5Phép toán ++ và --Phép toán ++ và -- cho phép viết tắt phép cộng và trừ 1 một cách nhanh chóng. Hai toán tử này có thể được đặt ở trước hoặc ở sau giá trị cần thay đổi, tuy nhiên  Khi đặt trước giá trị cần thay đổi, giá trị của đối tượng sẽ được tăng lên hoặc giảm đi, trước khi mọi phép toán khác diễn ra.  Khi đặt trước giá trị cần thay đổi, giá trị của đối tượng sẽ được tăng lên hoặc giảm đi, sau khi mọi phép toán khác diễn ra.Ví dụ minh họa:#include &lt;iostream&gt;using namespace std;int main(){    int x = 10, y = 10;    // In ra giá trị khi thực hiện phép toán    cout &lt;&lt; \"Before: x = \" &lt;&lt; ++ x &lt;&lt; \"; y = \" &lt;&lt; y ++ &lt;&lt; endl;    // In ra giá trị sau khi thực hiện phép toán    cout &lt;&lt; \"After: x = \" &lt;&lt; x &lt;&lt; \"; y = \" &lt;&lt; y &lt;&lt; endl;    return 0;}OutputBefore: x = 11; y = 10After: x = 11; y = 11Các kí hiệu so sánhCác toán tử so sánh được dùng để so sánh hai giá trị với nhau. Chúng sẽ trả lại giá trị kiểu bool: true nếu như mệnh đề là đúng, và false nếu là sai.Với hai giá trị x = 20 và y = 16 như trước, ta có:            Toán tử        Ý nghĩa        Ví dụ                ==        Bằng nhau        x == y cho ra kết quả false                !=        Khác nhau        x != y cho ra kết quả true                &gt;        Lớn hơn        x &gt; y cho ra kết quả true                &lt;        Nhỏ hơn        &lt; cho ra kết quả false                &gt;=        Lớn hơn hoặc bằng        x &gt;= y cho ra kết quả true                &lt;=        Nhỏ hơn hoặc bằng        x &lt;= y cho ra kết quả false    Toán tử logicKhi ta muốn kết hợp nhiều giá trị bool lại với nhau - ví dụ khi ta muốn kiểm tra nếu cả hai mệnh đề đều đúng, hoặc ít nhất một trong hai mệnh đề là đúng, vân vân… ta sử dụng các phép toán logic.Với hai giá trị x = 20 và y = 16 như trước, ta có các phép toán logic:            Toán tử        Ý nghĩa        Ví dụ                &amp;&amp; (AND)        Nếu như cả hai mệnh đề đều true, toán tử này trả lại giá trị true, ngược lại trả lại giá trị false        (x &gt; 15) &amp;&amp; (y &gt; 10) cho ra kết quả true        (x &lt; 15) &amp;&amp; (y &gt; 10) cho ra kết quả false        (x &lt; 15) &amp;&amp; (y &lt; 10) cho ra kết quả false                        || (OR)        Nếu như có một trong hai mệnh đề là true, toán tử này trả lại giá trị true, ngược lại trả lại giá trị false        (x &gt; 15) || (y &gt; 10) cho ra kết quả true        (x &lt; 15) || (y &gt; 10) cho ra kết quả true        (x &lt; 15) || (y &lt; 10) cho ra kết quả false                        ! (NOT)        Đảo ngược giá trị của mệnh đề (true trả về false, false trả về true)        !(x &gt; 15) cho ra kết quả false    Các toán tử so sánh và logic sẽ trở nên vô cùng quan trọng khi ta nghiên cứu tới các lệnh rẽ nhánh (if/else) và vòng lặp của chương trình.Phần sau: [C++ Cơ bản] Phần 10: Toán tử (tiếp)",
              url: "/article/c-co-ban-phan-9-toan-tu"
            }
            ,

            {
              title: "[SPOJ] CRATE - Coder Rating",
              author: "Joker",
              category: ["spoj"],
              tag: ["spoj", "tree"],
              content: "Link bài gốc:http://vnoi.info/problems/show/CRATE/Đề bài:Cho danh sách N lập trình viên (1 ≤ N ≤ 300000), đánh số lần lượt từ 1 đến N. Mỗi người đều tham gia cả hai giải thi đấu: Giải THPT và giải Mở rộng. Với mỗi lập trình viên, bạn sẽ được cung cấp điểm số của giải Mở rộng Ai và điểm số của giải THPT Hi (Các điểm số đều là số nguyên không âm và không vượt quá 100000). Lập trình viên i được coi là giỏi hơn lập trình viên j khi và chỉ khi cả 2 điểm số của lập trình viên i đều lớn hơn hoặc bằng điểm số tương ứng của lập trình viên j, trong đó có ít nhất 1 điểm số phải lớn hơn. Hãy tính xem với mỗi lập trình viên i thì có bao nhiêu lập trình viên mà i giỏi hơn.InputDòng đầu tiên chứa số nguyên N.N dòng tiếp theo, dòng thứ i+1 chứa 2 số nguyên Ai và Hi.OutputDòng i chứa số lượng lập trình viên mà lập trình viên i giỏi hơn.ExampleInput:81798 1832862 7001075 10891568 15572575 19841033 9501656 16491014 1473Output:60247151Solution:Tham khảo tại: http://viahold.com/1QpECode:Tham khảo tại: http://viahold.com/1QeA",
              url: "/spoj/spoj-crate-coder-rating"
            }
            ,

            {
              title: "[SPOJ] NKLEAGUE - Giải bóng đá",
              author: "itsjustwinds",
              category: ["spoj"],
              tag: ["tree", "graph", "spoj"],
              content: "Đề: http://vnoi.info/problems/show/NKLEAGUE/Một giải thi đấu bóng đá gồm n đội thi đấu vòng tròn một lượt. Các đội bóng được đánh số thứ tự từ 1 đến n. Theo thể lệ giải đấu, nếu trận đấu diễn ra với kết quả hòa, hai đội sẽ thi đấu luân lưu cho đến khi phân định thắng thua (nghĩa là các trận đấu đều được phân định thắng thua).Hỏi có tồn tại một cách sắp xếp các đội theo thứ tự sao cho trong thứ tự đó, mỗi đội đều thắng trận đấu với đội liền sau mình? Trong trường hợp tồn tại, hãy xác định một cách sắp xếp như vậy.Dữ liệu      Dòng đầu tiên chứa số nguyên n, số đội bóng tham dự giải đấu. (1 ≤ n ≤ 1000).    Dòng thứ i trong số n dòng tiếp theo chứa j kí tự 0 hoặc 1, kí tự thứ j thế hiện giá trị aij:  aii= 0 với mọi i.  aij= 1 nếu và chỉ nếu đội i thắng đội j. Dữ liệu vào luôn thỏa mãn aij+aji= 1 với i khác j.Kết quảIn ra -1 nếu không tồn tại cách sắp xếp thỏa mãn yêu cầu. Trong trường hợp tồn tại, in ra n số nguyên là chỉ số của các đội bóng trong cách sắp xếp tìm được.Hạn chế  Có 30% số test có n ≤ 9.Ví dụDữ liệu3010000110Kết quả3 1 2Hướng dẫnhttp://viahold.com/1QQKCodehttp://viahold.com/1QQf",
              url: "/spoj/spoj-nkleague-giai-bong-da"
            }
            ,

            {
              title: "[SPOJ] VMSORT - Sắp xếp",
              author: "itsjustwinds",
              category: ["spoj"],
              tag: ["data-structure", "spoj"],
              content: "Đề: http://vnoi.info/problems/show/VMSORT/Kì thi VM đang dần đi đến những vòng thi cuối cùng. Trong khi các thí sinh hăng say với những bài tập hóc búa, mang đậm tính chất Marathon thì các admin VNOI cũng phải đối mặt với những vấn đề rất nan giải, chẳng hạn như thống kê số lượng thí sinh, số lượng thí sinh giải được từng bài tập…Trong không khí căng thẳng của cuộc đua, ban tổ chức đã quyết định tặng một món quà đặc biệt cho các bạn. Và món quà đó chính là bài tập này!Bạn sẽ phải giúp các admin làm một nhiệm vụ sau: Cho dữ liệu mô tả các thí sinh tham gia mỗi một trong K vòng của cuộc thi VNOI Marathone 20xx, hãy tính xem có bao nhiêu thí sinh tham gia ít nhất một vòng thi.Input  Dòng 1: Ghi số nguyên dương K (1 ≤ K ≤ 5).  K nhóm dòng sau: Mỗi nhóm thể hiện dữ liệu của một vòng thi: Dòng đầu ghi số nguyên N (1 ≤ N ≤ 200) là số lượng thí sinh tham gia vòng thi đó. N dòng sau, mỗi dòng ghi một nick của thí sinh, dưới dạng một xâu khác rỗng, độ dài không quá 20 kí tự (đảm bảo xâu không chứa khoảng trống). Trong mỗi nhóm dòng mô tả một vòng thi, không có tên thí sinh nào được lặp lại hai lần.Output  Ghi ra một số nguyên duy nhất là số thí sinh tham gia ít nhất một vòng thi.ExampleInput:34flashmtll931110technolttuananhnb933mr_invincibleconankudoll9311103khanhptnkhphongtechnoltOutput:8Hướng dẫnhttp://viahold.com/1Q1eCodehttp://viahold.com/1Q2G",
              url: "/spoj/spoj-vmsort-sap-xep"
            }
            ,

            {
              title: "[SPOJ] VOXOR - XOR dãy số",
              author: "itsjustwinds",
              category: ["spoj"],
              tag: ["data-structure", "tree", "spoj"],
              content: "Đề: http://vnoi.info/problems/show/VOXOR/Cho dãy A gồm N số nguyên không âm. Ta lần lượt thực hiện Q thao tác trên tập hợp này:  XOR x: Với mọi i, Ai = Ai xor x  FIND k: Tìm số lớn thứ k trong dãy A.Yêu cầu: Thực hiện các truy vấn trên.InputDòng đầu tiên ghi 2 số N và Q.Dòng thứ hai ghi N số là giá trị ban đầu của dãy A.Tiếp theo là Q dòng, mỗi dòng ghi 1 trong 2 loại truy vấn.OutputVới mỗi truy vấn loại FIND, in ra kết quả tìm được.Giới hạnSubtask 1 (25%)  N, Q ≤ 5000  0 ≤ Ai ≤ 10^9  0 ≤ x ≤ 10^9.Các subtask 2, 3 và 4 tiếp theo đều có  N ≤ 10^5  Q ≤ 10^5  0 ≤ Ai ≤ 10^9Subtask 2 (40%)  0 ≤ x ≤ 100Subtask 3 (10%):  0 ≤ x ≤ 10^9  x luôn có dạng 2kSubtask 4 (25%):  0 ≤ x ≤ 10^9Ví dụInput:4 91 2 3 4FIND 1FIND 2FIND 3FIND 4XOR 6FIND 1FIND 2FIND 3FIND 4Output:43217542Giải thíchTrước truy vấn XOR 6, dãy số là 1 2 3 4.Sau truy vấn XOR 6, dãy số là 7 4 5 2.Hướng dẫnhttp://viahold.com/1Pt2codehttp://viahold.com/1Ptx",
              url: "/spoj/spoj-voxor-xor-day-so"
            }
            ,

            {
              title: "[SPOJ] ROBOCON - VOI 2012 Robocon",
              author: "itsjustwinds",
              category: ["spoj"],
              tag: ["bfs", "spoj"],
              content: "Đề: http://vnoi.info/problems/show/ROBOCON/Cuộc thi vòng loại Robocon năm nay có chủ đề “Gặp gỡ”. Các Robot sẽ tranh tài trên một lưới ô vuông gồm n hàng n cột. Các hàng của lưới được đánh số từ 1 đến n, từ trên xuống dưới. Các cột của lưới được đánh số từ 1 đến n, từ trái sang phải. Trên k ô vuông của lưới có đặt chướng ngại vật. Ở phần thi Robot tự động, mỗi đội sẽ phải sử dụng đồng thời hai con Robot.Tại thời điểm xuất phát, Robot thứ nhất được đặt tại ô (1,1), mỗi bước chỉ được phép di chuyển sang ô kề cạnh bên phải, hoặc xuống ô kề cạnh bên dưới hoặc xuống ô kề đỉnh phía dưới bên phải.Robot thứ hai được đặt tại ô (1,n), mỗi bước chỉ được phép di chuyển sang ô kề cạnh bên trái hoặc xuống ô kề cạnh bên dưới hoặc xuống ô kề đỉnh phía dưới bên trái.Bắt đầu từ thời điểm xuất phát được tính là 0, hai Robot phải di chuyển liên tục theo qui tắc đã nêu. Thời gian di chuyển từ một ô sang ô kế tiếp được tính là 1 giây. Nhiệm vụ của đội chơi là phải lập trình điều khiển hai Robot xuất phát cùng lúc, di chuyển tránh chướng ngại vật để gặp nhau tại một ô vuông không có chướng ngại vật. Hai Robot gặp nhau càng sớm đội chơi càng được nhiều điểm. Lưới ô vuông được thiết kế đảm bảo là luôn có cách đi để hai Robot gặp được nhau.Yêu cầu: Hãy tìm cách điều khiển sao cho hai Robot gặp nhau ở thời điểm sớm nhất.Ràng buộc: 50% số tests ứng với 50% số điểm của bài có n ≤ 100.Input  Dòng thứ nhất chứa hai số nguyên dương n, k (n ≤ 500, k ≤ 10000).  Dòng thứ i trong số k dòng tiếp theo chứa 2 số nguyên dương ui, vitương ứng là tọa độ hàng và cột của ô có đặt chướng ngại vật (i = 1, 2, …, k).Các số trên cùng một dòng được ghi cách nhau ít nhất một dấu cách.OutputGhi ra một số nguyên dương là thời điểm sớm nhất tìm được.ExampleInput:5 52 21 42 33 54 2Output:3Hướng dẫnhttp://viahold.com/1PXoCodehttp://viahold.com/1PZ2",
              url: "/spoj/spoj-robocon-voi-2012-robocon"
            }
            ,

            {
              title: "[SPOJ] AREA - Diện tích hình chữ nhật",
              author: "Joker",
              category: ["spoj"],
              tag: ["spoj", "math"],
              content: "Link bài gốc:http://vnoi.info/problems/show/AREA/Đề bài:Trên mặt phẳng toạ độ người ta vẽ ra N hình chữ nhật . Hãy tính diện tích che phủ bởi N hình chữ nhật này , biết rằng N hình chữ nhật này song song với 2 trục Ox và Oy .InputDòng 1 : số nguyên N ( 1 ≤ N ≤ 10000 ) .N dòng tiếp theo , mỗi dòng gồm 4 số nguyên x1 , y1 , x2 , y2 tương ứng là toạ độ góc trái dưới và góc phải trên của hình chữ nhật thứ i.( 0 ≤ x1 ≤ x2 ≤ 30000 , 0 ≤ y1≤ y2 ≤ 30000 ) .OutputGồm 1 dòng ghi ra diện tích phủ bởi N hình chữ nhật.Ví dụ:Input:210 10 20 2015 15 25 30Output:225 Solution:Tham khảo tại: http://viahold.com/1OtECode:Tham khảo tại: http://viahold.com/1Orx",
              url: "/spoj/spoj-area-dien-tich-hinh-chu-nhat"
            }
            ,

            {
              title: "[SPOJ] VOSCUN - CUNNING",
              author: "Nicky.Rio",
              category: ["spoj"],
              tag: ["spoj", "dp", "bfs"],
              content: "Link gốchttp://vnoi.info/problems/show/VOSCUN/Đề bàiCho một khối lập phương NxNxN được tạo thành bởi việc xếp nhiều cái lồng lên nhau. Các lồng được đánh số từ (1,1,1) đến (N,N,N). Bên trong mỗi lồng có một con cáo, nó mong muốn được tới lồng (1,1,1). Tuy nhiên, các con cáo này không phải là những con cáo bình thường, đây trở thành vấn đề bạn cần giải quyết.Mỗi con cáo cần nhảy một số bước nhất định để thoát. Nếu có nhiều đường, chúng luôn đi con đường với số lần nhảy ít nhất. Trong mỗi lần di chuyển con cáo có thể nhảy dọc theo 1 chiều âm hoặc dương trong các trục x, y, z một lượng là lũy thừa của 2 (…, -8, -4, -2, -1, 1, 2, 4, 8,…) và không được nhảy theo kiểu khác.Một lồng có thể  chứa nhiều cáo  trong một thời điểm. Cáo không thể rời khối lập phương.Viết chương trính tính T: tổng số bước nhảy cần thiết để toàn bộ cáo đến lồng (1,1,1). Ngoài ra, bạn phải xác định số bước nhảy cần thiết với mỗi con cáo để tới lồng (1,1,1)InputDòng đầu chứa 2 số nguyên N và K.K dòng tiếp theo lần lượt chứa 3 số nguyên a, b, c.OutputDòng đầu output in ra số nguyên T, tổng số bước nhảy được thực hiện bởi tất cả các con cáo.K dòng tiếp theo in ra số bước nhảy được thực hiện bởi con cáo ở lồng (a,b,c) được cho bởi truy vấn thứ K.ExampleInput3 42 1 22 3 31 1 13 3 3Output542303Giải thíchCho khối lập phương 3x3x3. Con cáo ở ô (2,1,2) có thể nhảy tới (1,1,2) và sau đó là (1,1,1). Con cáo ở (2,3,3) nhảy tới (1,3,3), (1,1,3) rồi (1,1,1). Con cáo ở (1,1,1) ở sẵn vị trí. Con cáo ở (3,3,3) nhảy tới (1,3,3), (1,1,3) rồi (1,1,1). Có thể có một số cách dịch chuyển khác với số lượt nhảy tương tự.Tổng số bước nhảy của 27 con cáo là 54.Từ 8 đến 1 có thể đi như sau: 8 -&gt; 9 -&gt; 1Solutionhttp://viahold.com/1Et7Code mẫuhttp://viahold.com/1EfK",
              url: "/spoj/spoj-voscun-cunning"
            }
            ,

            {
              title: "[SPOJ] VOSMAXK - Lại là dãy số",
              author: "Nicky.Rio",
              category: ["spoj"],
              tag: ["spoj", "stack", "dp"],
              content: "Link gốchttp://vnoi.info/problems/show/VOSMAXK/Đề bàiBenjamin là một cậu học sinh rất hiếu động và cũng rất ngoan. Ông già noel thầm nghĩ cậu bé này rất xứng đáng để được nhận quà trong ngày giáng sinh. Vốn bản tính tinh nghịch, cậu bé đã ghi ước nguyện của mình vào tờ giấy như sau:  Đoạn đầu cậu ghi một dãy số gồm N số nguyên không âm.  Đoạn thứ hai có nội dung : “Cháu ước gì cháu có thể có M viên kẹo trong đó M là số lượng dãy con liên tiếp có giá trị của phần tử lớn nhất là K “.Ông già Noel rất muốn tặng quà cho cậu nhưng dãy số quá dài nên ông đã nhờ tới các siêu lập trình viên của VOS. Hãy giúp ông tìm được M để ông còn tặng quà cho Benjamin.Dữ liệu vào:  Dòng đầu chứa 2 số N, K.  Dòng thứ N số nguyên dương mô tả dãy số ở đoạn đầu của bức thư.Dữ liệu ra:  Gồm một dòng là số M.Ràng buộc:  1 &lt;= N &lt;= 1 000 000.  Các số còn lại trong dữ liệu vào &lt;= 1 000 000 000.  1/3 số test có N &lt;= 1000.Ví dụInput5 51 2 5 3 4Output9Solutionhttp://viahold.com/1EPXCode mẫuhttp://viahold.com/1EDi",
              url: "/spoj/spoj-vosmaxk-lai-la-day-so"
            }
            ,

            {
              title: "[SPOJ] MESSAGE - Truyền tin",
              author: "Nicky.Rio",
              category: ["spoj"],
              tag: ["spoj", "dfs-and-similar", "graph"],
              content: "Link gốchttp://vnoi.info/problems/show/MESSAGE/Đề bàiMột lớp gồm N học sinh, mỗi học sinh cho biết những bạn mà học sinh đó có thể liên lạc được (chú ý liên lạc này là liên lạc một chiều : u có thể gửi tin tới v nhưng v thì chưa chắc đã có thể gửi tin tới u).Thầy chủ nhiệm đang có một thông tin rất quan trọng cần thông báo tới tất cả các học sinh. Để tiết kiệm thời gian, thầy chỉ nhắn tin tới 1 số học sinh rồi sau đó nhờ các học sinh này nhắn lại cho tất cả các bạn mà các học sinh đó có thể liên lạc được, và cứ lần lượt như thế làm sao cho tất cả các học sinh trong lớp đều nhận được tin .Hãy tìm một số ít nhất các học sinh mà thầy chủ nhiệm cần nhắn.Input      Dòng đầu là N, M (N &lt;= 800, M là số lượng liên lạc 1 chiều)        Một số dòng tiếp theo mỗi dòng gồm 2 số u , v cho biết học sinh u có thể gửi tin tới học sinh v  Output  Gồm 1 dòng ghi số học sinh cần thầy nhắn tin.ExampleInput12 151 33 66 16 88 1212 99 62 44 55 24 67 1010 1111 710 9Output2Giải thích: Chọn cả học sinh 2 và 7.Solutionhttp://viahold.com/1E5mCode mẫuhttp://viahold.com/1E0W",
              url: "/spoj/spoj-message-truyen-tin"
            }
            ,

            {
              title: "[SPOJ] C11SUM - Siêu trộm KID và Mật khẩu đêm Trung thu!",
              author: "G",
              category: ["spoj"],
              tag: ["spoj", "dp"],
              content: "Link đề gốc : http://vnoi.info/problems/show/C11SUM/.Đề bài :“Trung thu là tết thiếu nhiMà sao người lớn lại đi chơi nhiềuChơi nhiều rồi lại làm liềuLàm liều lại có thêm nhiều thiếu nhi.”Vẫn biết trung thu là một dịp tốt để đi chơi với gấu và làm liều, nhưng trăng sáng như thế, Kid không được bay lượn trên bầu trời hay đi ăn trộm thì phí. Hiểu rõ ‘tâm tư nguyện vọng’ của Kid, một tuần trước trung thu, ông Jirokichi đã gửi thư thách Kid có thể lấy được cặp bánh trung thu bằng vàng nguyên chất của mình. Và tất nhiên, như mọi khi, Kid nhận lời và giờ cậu đang hí hoáy chiếc két để lấy được cặp bánh trung thu mà ông Jirokichi đã thách thức (ăn trộm như chỗ không người :v). Nhưng mọi việc không chỉ đơn giản như thế, chiếc két được mã hóa cực kì chắc chắn, chỉ cần sai mật khẩu nhập vào, quả bom trong chiếc két sẽ phát nổ và cặp bánh sẽ tiêu tan, hiển nhiên Kid sẽ là người thua cuộc. May mắn thay, trong khi cải trang thành người phục vụ ông Jirokichi , cậu đã ‘mượn’ được tờ giấy có chứa mật khẩu của chiếc két. Trên tờ giấy đó có chứa một bài toán, mà đáp số của nó chính là mật khẩu của chiếc két. Tất nhiên, do sợ sẽ làm rơi laptop khi đang bay trên trời, nên Kid đã không mang theo máy tính, vì thế việc giải bài toán trên trở nên vô cùng khó khăn. Hãy giúp đỡ Kid giải bài toán trên, rất có thể sau khi đã mở được chiếc két, Kid sẽ tặng bạn một chiếc bánh trung bằng vàng đó.Bài toán trên tờ giấy của ông Jirokichi như sau:Cho một xâu S , S chỉ chứa các số 0 đến 9. Tính tổng các DÃY CON LIÊN TIẾP của S mod 10^9+7_Input  Một dòng duy nhất chứa xâu SOutput  Một số duy nhất là kết quả của bài toán.Giới hạn:Với length(s) là độ dài của xâu S:  50% số test length(S) ≤ 100  50% số test còn lại length(s) ≤ 10^6ExampleInput:737Output:864864Giải thích: 7 + 3 + 7 + 73 + 37 + 737 = 864.Solution :HereCode :Here",
              url: "/spoj/spoj-c11sum-sieu-trom-kid-va-mat-khau-dem-trung-thu"
            }
            ,

            {
              title: "[SPOJ] VMQUABEO - Quá béo",
              author: "Nguyễn Minh Quân",
              category: ["spoj"],
              tag: ["spoj", "two-pointer", "rmq", "data-structure"],
              content: "Link đề gốc: http://vnoi.info/problems/show/VMQUABEO/Đề bàiCân nặng đã ở mức đáng báo động, admin K quyết định tập chạy để giảm cân. Khu vực admin K sống có một con đường dài, điểm đầu của con đường là điểm 0, điểm cuối của con đường là điểm N-1. Các điểm cách đều nhau một khoảng 1 đơn vị độ dài; điểm thứ i có độ cao H[i]. Admin K muốn chọn ra một đoạn đường để tập chạy sao cho:  Đoạn đường có chiều dài ít nhất là L.  Chênh lệch độ cao giữa điểm cao nhất và điểm thấp nhất trên đoạn đường không vượt quá D.Bạn hãy giúp xác định xem có bao nhiêu đoạn đường thỏa mãn.Input  Dòng đầu tiên ghi ba số N L D.  Dòng thứ hai ghi N số H[i] là độ cao của điểm thứ i.OutputIn ra số đoạn đường thỏa mãn.Giới hạn  1 &lt;= L &lt; N &lt;= 10^6  0 &lt;= D &lt;= 10000  1 &lt;= H[i] &lt;= 10000  Trong 15% số test, N &lt;= 500  Trong 20% số test tiếp theo, N &lt;= 10^4  Trong 25% số test tiếp theo, N &lt;= 10^5SolutionHereCode mẫuHere",
              url: "/spoj/spoj-vmquabeo-qua-beo"
            }
            ,

            {
              title: "[SPOJ] C11DK1 - Những chiếc lá mùa thu",
              author: "G",
              category: ["spoj"],
              tag: ["spoj", "dp", "binary-search"],
              content: "Link đề bài: http://vnoi.info/problems/show/C11DK1/.Đề bài:“Hà Nội mùa thu, cây cơm nguội vàng, cây bàng lá đỏ, nằm kề bên nhau phố xưa nhà cổ, mái ngói thâm nâu. … Hà Nội mùa thu! Đi giữa mọi người, lòng như thầm hỏi “tôi đang nhớ ai?”, sẽ có một ngày trời thu Hà Nội, trả lời cho tôi, sẽ có một ngày từng con đường nhỏ trả lời cho tôi.”Mỗi năm đến mùa thu, những chiếc lá vàng lại rơi khắp trên đường làng, nơi mà khaihanhdk đang ở. Do lần đầu tiên xếp hạng cuối lớp, thầy chủ nhiệm đã phạt khaihanhdk phải quét hết lá vàng rơi trên con đường làng trước ngày 7-10. Nhưng đã học tệ rồi, lại còn thêm tính lười biếng. Cuối cùng, ngày 6-10 cũng đã đến, nhưng khaihanhdk vẫn chưa quét được chiếc lá vàng nào, khaihanhdk cứ ngồi khóc mãi, khóc mãi. Bỗng một lúc sau, Bụt hiện ra và hỏi: “Kìa con, vì sao con khóc?”.Khaihanhdk kể lại hết câu chuyện cho Bụt nghe, Bụt nói: “Ờ, ta hiểu rồi, ta chỉ có một cách để giúp con. Con hãy ra cửa hàng Olympic Tin học Việt Nam (VNOI), con mua vài chiếc máy hút lá vàng do cựu học sinh Nguyễn Vương Linh vừa đem hàng từ Thái Lan về. Vấn đề bây giờ là con phải biết cách chọn lựa máy nào cho tốt mà ít tốn kém đấy nhé. Nếu con không biết có thể hỏi các coder trên trang web vnoi.info, có thể họ sẽ có cách giúp con. Thôi, ta đi đây.”Con đường làng là 1 đường thẳng, trên đó mỗi chiếc lá vàng có tọa độ x[i], có không quá n (n &lt;= 10^4) chiếc lá vàng trên đường.Cửa hàng có m (m &lt;= 10^4) loại máy, có thể mua nhiều cái máy cùng 1 loại, không giới hạn số lượng. Mỗi loại máy có 2 thông số là:d[i]: nếu đặt máy i ở vị trí x thì nó sẽ hút được tất cả các lá vàng có tọa độ nằm trong khoảng [x – d[i], x + d[i]].c[i]: chi phí để mua máy.Yêu cầu: Cần đặt một số máy lên đường làng sao cho các máy hút hết được lá vàng và chi phí mua máy là thấp nhất.InputDòng đầu gồm 2 số: n và m.N dòng tiếp theo: mỗi dòng ghi số x[i] (abs(x[i]) &lt;= 10^9).M dòng tiếp thep: mỗi dòng ghi 2 số: d[i] và c[i] (1 &lt;= d[i] &lt;= 10^9, c[i] &lt;= 1000).OutputChi phí nhỏ nhất tìm được.ExampleInput:5 3283697 92 38 6Output:6 Solution:HereCode:Here",
              url: "/spoj/spoj-c11dk1-nhung-chiec-la-mua-thu"
            }
            ,

            {
              title: "[SPOJ] VOGAME - Trò chơi với những viên bi",
              author: "Nicky.Rio",
              category: ["spoj"],
              tag: ["spoj", "dp"],
              content: "Link gốchttp://vnoi.info/problems/show/VOGAME/Đề bàiCho một cái hộp có N viên bi đánh số từ 1 đến N có màu đỏ (màu 1) hoặc màu đen (màu 0). Màu của các viên bi được cho bởi dãy A gồm D số 0 hoặc 1:  COLOR[i] = A[i] với 1 ≤i≤ D  COLOR[i] = COLOR[i - 1]  XOR  COLOR[i - 2] XOR  COLOR[i - 3] XOR  … XOR  COLOR[i - D] với i &gt; DTuấn chơi một trò chơi như sau: Mỗi lượt Tuấn sẽ bốc ngẫu nhiên ra 2 viên bi bất kỳ từ hộp bi.  Nếu 2 viên bi cùng màu thì bỏ 2 viên đó đi và lấy từ một hộp khác một viên đen bỏ lại vào hộp.  Ngược lại, nếu 2 viên bi khác màu thì bỏ viên bi đen đi, giữ lại viên bi đỏ và cho lại vào hộp.Bạn hãy giúp Tuấn tìm xem, liệu màu của viên bi cuối cùng còn trong hộp có phải là cố định hay không. Nếu cố định (đen hoặc đỏ), in ra màu đó. Còn nếu màu của viên bi cuối cùng không cố định in ra “MANY”.InputDòng đầu tiên ghi số nguyên T là số lượng bộ dữ liệu. Mô tả của mỗi bộ dữ liệu như sau: Dòng thứ nhất chỉ gồm hai số nguyên lần lượt là N và DDòng tiếp theo ghi D số 0 hoặc 1 mô tả dãy A(1..d)OutputIn ra T dòng là kết quả của T bộ dữ liệu.Giới hạnTrong tất cả các test, T≤ 5.Subtask 1 (15% số điểm)* 1 ≤ D = N ≤ 20Subtask 2 (25% số điểm)* 1 ≤ D = N ≤ 105Subtask 3 (30% số điểm)* 1 ≤ D ≤ 20* 10^5 ≤ N ≤ 10^9Subtask 4 (30% số điểm)* 1 ≤ D ≤ 10^5* 10^5 ≤ N ≤ 10^9Ví dụInput32 21 12 20 02 21 0Output001Giải thíchBộ dữ liệu đầu tiênTrong đó có hai viên bi đỏ thì khi Tuấn bốc hai viên bi này lên. Theo quy tắc vì chúng cùng màu nên Tuấn sẽ bỏ 2 viên bi đó đi và cho lại vào hộp viên bi màu đen(màu 0).Bộ dữ liệu thứ hai Tương tự như bộ dữ liệu đầu tiên nhưng là hai viên bi màu đen. Tuấn cũng theo quy tắc và bỏ hai viên bi đen đó đi và sau đó cho lại vào hộp viên bi màu đen(màu 0).Bộ dữ liệu thứ baTuấn bốc hai viên bi từ trong hộp ra thì trong đó có một viên bi đỏ và một viên bi đen. Tuấn bỏ viên bi đen đi và chỉ giữ lại viên bi màu đỏ (màu 1) và cho viên đỏ lại vào hộp.Solutionhttp://viahold.com/1DkRCode mẫuhttp://viahold.com/1DSg",
              url: "/spoj/spoj-vogame-tro-choi-voi-nhung-vien-bi"
            }
            ,

            {
              title: "[SPOJ] C11BC1 - The country of heaven",
              author: "G",
              category: ["spoj"],
              tag: ["spoj", "dp", "math"],
              content: "Link đề gốc : http://vnoi.info/problems/show/C11BC1/.Đề bài :Một đất nước có N thành phố, mỗi thành phố được đặc trưng bởi 2 con số: A[i] và B[i] (trong đó: A[i] là khả năng tăng trưởng của thành phố đó và B[i] là “chỉ số ngôn ngữ” của thành phố đó). Một “liên minh” là 1 tập hợp gồm k thành phố trong N thành phố của đất nước (k &lt;= N) và có ít nhất 2 thành phố khác nhau về chỉ số ngôn ngữ. “Khả năng liên minh” của k thành phố trong 1 liên minh được tính bằng tích các khả năng tăng trưởng của k thành phố đó. Khả năng tăng trưởng của đất nước sẽ được tính bằng tổng tất cả các khả năng liên minh của các liên minh, và tất cả các liên minh này đều khác nhau.Ví dụ 1 liên minh gồm 5 thành phố là: 1, 4, 2, 5, 6 thì khả năng liên minh sẽ là A[1]*A[4]*A[2]*A[5]*A[6].Hai liên minh được gọi là khác nhau nếu tồn tại “ít nhất” một thành phố có trong liên mình này mà không có trong liên minh kia.InputDòng đầu gồm 2 số n và k (2&lt;= n &lt;= 10^5, 2 &lt;= k &lt;= 50)N dòng tiếp theo: mỗi dòng gồm 2 số A[i] và B[i] (A[i] &lt;= 1000 và B[i] &lt;= 10^9)OutputGồm 1 dòng duy nhất: Khả năng tăng trưởng của đất nước theo module 790972.ExampleInput:            5 3            4 16 45 32 23 5Output:            580Time limit đã được thay đổi, những ai code chưa chuẩn thì code lại với cách tối ưu hơn.Solution:HereCode :Here",
              url: "/spoj/spoj-c11bc1-the-country-of-heaven"
            }
            ,

            {
              title: "[SPOJ] BONES - Xúc xắc bò",
              author: "G",
              category: ["spoj"],
              tag: ["spoj", "implementation"],
              content: "Link đề gốc: http://vnoi.info/problems/show/BONES/.Đề bài :Bessie rất yêu thích chơi những trò chơi đổ xúc xắc và cô bò này đã nài được bác nông dân John chở tới cửa hàng đồ chơi và cô bò đã mua 3 cái xúc xắc về để lăn.Những viên xúc xắc này tương ứng có S1, S2 và S3 mặt đều nhau, các mặt được đánh số từ 1-&gt;S1, 1-&gt;S2 và 1-&gt;S3 (2 &lt;= S1 &lt;= 20; 2 &lt;= S2 &lt;= 20; 2 &lt;= S3 &lt;= 40).Bessie cứ thả xúc xắc liên tục và mỗi lần lại ghi nhận lại 1 số nguyên là tổng giá trị của 3 mặt xúc xắc thả được. Mục đích của cô bò là để tìm ra xem tổng giá trị nào xuất hiện nhiều nhất.Cho số mặt của 3 xúc xắc, hãy xác định xem tổng giá trị nào xuất hiện nhiều nhất. Nếu có nhiều hơn 1 giá trị xuất hiện nhiều nhất thì ghi ra giá trị nhỏ nhất.DỮ LIỆU  Dòng 1: 3 số nguyên cách nhau bởi dấu cách: S1, S2 và S3KẾT QUẢ  Dòng 1: Số nguyên nhỏ nhất là tổng giá trị xuất hiện nhiều lần nhất, giả sử rằng xác suất các mặt xúc xắc xuất hiện là như nhau.VÍ DỤDữ liệu3 2 3Kết quả5GIẢI THÍCHĐây là tất cả các trường hợp có thể xảy ra. 1 1 1 -&gt; 3 1 2 1 -&gt; 4 2 1 1 -&gt; 4 2 2 1 -&gt; 5 3 1 1 -&gt; 5 3 2 1 -&gt; 6 1 1 2 -&gt; 4 1 2 2 -&gt; 5 2 1 2 -&gt; 5 2 2 2 -&gt; 6 3 1 2 -&gt; 6 3 2 2 -&gt; 7 1 1 3 -&gt; 5 1 2 3 -&gt; 6 2 1 3 -&gt; 6 2 2 3 -&gt; 7 3 1 3 -&gt; 7 3 2 3 -&gt; 8 Trong đó 5 và 6 xuất hiện nhiều nhất (mỗi số 5 lần), vậy 5 là kết quả.Solution :HereCode :Here",
              url: "/spoj/spoj-bones-xuc-xac-bo"
            }
            ,

            {
              title: "[C++ Cơ bản] Phần 8: Input và Output (tiếp)",
              author: "Admin Tổng Quản",
              category: ["article"],
              tag: ["cpp-cơ-bản", "programming"],
              content: "Phần trước: [C++ Cơ bản] Phần 7: Input - OutputTrong phần trước, chúng ta đã nói về các đọc và viết ra màn hình console. Bài viết này sẽ nói về việc đọc và viết từ file.Cảnh báo: Bài viết này sẽ có rất nhiều nội dung mới, chưa được giải thích về trước, và sẽ được giải thích trong các phần về sau.File pathMỗi file và folder đều có một địa chỉ xác định, địa chỉ này được biểu diễn bằng một string (xâu ký tự), được gọi là đường dẫn (path). Đường dẫn bao gồm tên các folder dẫn tới file, phân cách nhau bằng dấu gạch chéo (/ hoặc \\\\, tùy thuộc vào hệ điều hành).Đường dẫn có hai dạng: Đường dẫn tuyệt đối (absolute) và tương đối (relative)  Đường dẫn tuyệt đối sẽ chỉ định tới một địa chỉ cố định. Ví dụ: C:\\\\user\\\\docs\\\\Letter.txt sẽ chỉ định tới file Letter.text, nằm trong thư mục docs của thư mục user, trong ổ C. Đường dẫn tuyệt đối bắt buộc phải có tên của ổ đĩa hoặc thư mục gốc (root).  Đường dẫn tương đối sẽ chỉ định tới một địa chỉ tương đối so với file của chương trình. Ví dụ: Chương trình được đặt trong thư mục C:\\\\Program Files\\\\My Program. Khi đó thay vì sử dụng đường dẫn tuyệt đối để truy cập vào file ở địa chỉ C:\\\\Program Files\\\\My Program\\\\Stuff\\\\xyz.txt, ta chỉ sử dụng đường dẫn tương đối Stuff\\\\xyz.txt.Bản thân tên của một file cũng là đường dẫn tương đối của nó, so với thư mục chứa nó.Khi ta chạy một dự án C++ trên CodeBlocks, đường dẫn tương đối được so với thư mục của dự án, thay vì là thư mục của file chương trình. Tuy nhiên khi ta chạy đơn lẻ file chương trình sau khi build ra mà không thông qua CodeBlocks, đường dẫn tương đối sẽ là so với thư mục chứa file chương trình như mặc định.Thư viện fstreamC++ cung cấp thư viện fstream dành cho việc nhập - xuất với file. Thư viện này định nghĩa ba class mới:ClassChức năngofstreamClass biểu diễn output file stream và được sử dụng để tạo mới và viết ra file.ifstreamClass biểu diễn input file stream và được sử dụng để đọc thông tin từ file.fstreamClass biểu diễn các stream liên quan tới file nói chung, và bao gồm khả năng của cả ofstream và ifstream.Để xử lý file với C++, ta cần phải khai báo sử dụng hai thư viện iostream và fstream\\#include &lt;iostream&gt;\\#include &lt;fstream&gt;Khai báo fileTrước khi đọc hoặc viết một file bất kì, ta phải khai báo file stream dành cho file đó trong chương trình.Việc khai báo file stream mới cũng giống như khai báo một biến mới - ở đây ta đặt tên biến file stream là myFile:fstream myFile;Sau đó, ta cần gọi lệnh open() của đối tượng fstream, để mở file và hướng file stream vào file mục tiêu.Chú ý: Các kiến thức về hàm và lệnh của đối tượng, cũng như các nội dung về lập trình hướng đối tượng nói chung, sẽ được giải thích trong các bài viết sau. Hiện tại, hãy tạm thời làm theo chỉ dẫn của bài viết.Cú pháp của lệnh open() là:stream_variable.open(const char \\*filename, ios::openmode mode);  filename là file path của file mục tiêu. Biến này có kiểu dữ liệu const char \\*, là kiểu dữ liệu con trỏ cố định chỉ tới một biến kiểu char. Phần nội dung về biến cố định (hằng số) và con trỏ sẽ được nói tới một bài viết khác. Hiện tại, ta sẽ sử dụng địa chỉ của file nằm trong ngoặc kép (\"\") như là địa chỉ của file.  mode là một giá trị kiểu bitmask không bắt buộc. Nó cho phép người dùng cài đặt chế độ mở file. Các giá trị có thể thiết lập là:Mode FlagChức năngios::appChế độ nối tiếp. Khi mở một file để viết dữ liệu vào, tất cả phần nội dung mới sẽ được viết vào cuối file.ios::ateMở một file ra để viết nội dung mới vào, và di chuyển con trỏ viết tới cuối file này.ios::inMở file ra để đọcios::outMở file ra để viếtios::truncMở file ra để viết. Nếu như file mục tiêu đã tồn tại trước đó và ta cần viết nội dung vào file, nó sẽ bị xóa sạch nội dung cũ trước khi viết nội dung mới.mode là một giá trị kiểu bitmask, do đó ta có thể sử dụng toán tử OR (|) để áp dụng nhiều mode vào cùng một lúc.Chú ý: OR và các toán tử khác liên quan tới toán học và xử lý bit sẽ được đề cập ở các bài viết sau.Ví dụ: Mở file myFile.txt ra để viết bằng luồng myFile ở trên, và nếu file đõ đã tồn tại thì xóa nội dung của nó đi:myFile.open(\"myFile.txt\", ios::out | ios:: trunc);Một ví dụ khác: Mở file myFile.txt ra để đọc và viết cùng lúc:myFile.open(\"myFile.txt\", ios::in | ios::out);Cả hai đoạn code này sẽ mở ra file myFile.txt ở trong thư mục của chương trình, do đường dẫn được sử dụng là đường dẫn tương đối.Chú ý: mode là giá trị không bắt buộc phải có.  Đối với các biến dạng fstream, mode được đặt mặc định bằng ios::in | ios::out.  Đối với các biến dạng ofstream, mode được đặt mặc định là ios::out.  Đối với các biến dạng ifstream, mode được đặt mặc định bằng ios::in.Do đó nếu không có nhu cầu đặc biệt, ta có thể bỏ qua giá trị của mode.Ví dụ: Mở file myFile.txt để đọc bằng input file stream myFileifstream myFile;myFile.open(\"myFile.txt\");Nếu như luồng đang được chỉ địng tới một file nào đó mà chưa được đóng lại, lệnh này sẽ thất bại, và việc nhập/xuất sẽ bị sai.Đọc và viết vào fileĐể đọc và viết vào file, ta chỉ cần sử dụng toán tử &gt;&gt; và &lt;&lt; lên các luồng, tương tự như với cin và cout.Ví dụ: Đọc một số từ file INPUT.TXT, và in số đó ra file OUTPUT.TXT\\#include &lt;iostream&gt;\\#include &lt;fstream&gt;using namespace std;int main(){ifstream input; input.open(\"INPUT.TXT\");ofstream output; output.open(\"OUTPUT.TXT\");int x; input &gt;&gt; x;output &lt;&lt; x;input.close(); output.close(); // Đóng filereturn 0;}Đóng fileKhi một chương trình C++ kết thúc, nó sẽ tự động giải phóng buffer và các vùng bộ nhớ tạm thời, và đóng tất cả các file đang mở lại. Tuy nhiên, việc đóng các file lại trước khi kết thúc chương trình cũng là một việc nên làm, tránh sự ảnh hưởng từ bên ngoài chương trình.Như trong ví dụ trên, để đóng một file lại, ta sử dụng cú phápstream_variable.close();Di chuyển con trỏ đọc/viếtClass istream cung cấp lệnh seekg (“seek get”) để di chuyển con trỏ đọc luồng input. Cú pháp của lệnh này làluồng.seekg(long long int pos, ios_base::seekdir way);  pos là số byte cần di chuyển.  way là một giá trị không bắt buộc, chỉ định địa điểm bắt đầu di chuyển. Giá trị phù hợp của way là ios::beg (từ điểm bắt đầu của luồng/file, mặc định), ios::cur (từ vị trí hiện tại) và ios::end (từ điểm kết thúc của luồng/file).Ví dụ:// Di chuyển tới byte thứ n của fileObjectfileObject.seekg( n );// Di chuyển thêm n byte nữa trong fileObjectfileObject.seekg( n, ios::cur );// Di chuyển tới byte thứ n từ cuối lênfileObject.seekg(- n, ios::end );// Di chuyển tới cuốifileObject.seekg( 0, ios::end );Class ofstream cũng cung cấp lệnh seekp (“seek put”) với cú pháp tương tự.freopenfreopen được sử dụng nhiều bởi giới lập trình thi đấu, vì trong lập trình thi đấu thì ta không có nhu cầu phải đọc hoặc in với nhiều file một lúc. Sau khi áp dụng freopen, ta có thể sử dụng cin và cout để đọc viết trên file - điều này rất có ích khi ta muốn copy đoạn code mẫu từ nơi này tới nơi khác, mà không phải lo về tên biến luồng dữ liệu.freopen là một lệnh được định nghĩa trong thư viện stdio.h của C. Nó cho phép người dùng chuyển hướng của luồng dữ liệu input hoặc output sang một file khác, nhằm đọc và viết trên file đó.Cú pháp của freopen là:freopen(const char \\*filename, const char \\*mode, FILE \\*stream);  filename là địa chỉ của file mục tiêu. Giá trị này thuộc kiểu const char \\*, giống như filename trong hàm open của fstream.  mode là chế độ mở file. Các giá trị phù hợp ở đây là:Giá trịÝ nghĩa\"r\"Mở file để đọc. File cần mở phải tồn tại trước đó.\"w\"Mở file để viết. Nếu file đã tồn tại trước đó, thì nội dung của nó sẽ bị xóa trắng trước khi mở. Nếu không, nó sẽ được tạo mới.\"a\"Mở file để viết. Nếu file đã tồn tại trước đó, nội dung mới sẽ được viết tiếp vào cuối file. Nếu không, nó sẽ được tạo mới.\"r\\+\"Mở một file để vừa đọc và viết. File phải tồn tại trước đó.\"w\\+\"Tạo một file rỗng mới để vừa đọc vừa viết.\"a\\+\"Mở một file để vừa đọc và viết. Nội dung mới sẽ được nối vào cuối file cũ.  stream là luồng dữ liệu cần chuyển. Giá trị ở đây có thể là stdin (luồng vào chuẩn) hoặc stdout (luồng ra chuẩn), hoặc các luồng vào và luồng ra khác.Sau khi gọi lệnh này với stdin hoặc stdout, ta có thể đọc và viết với file bằng luồng cin và cout sẵn có.Ví dụ: Khi áp dụng vào chương trình ở trên:\\#include &lt;iostream&gt;\\#include &lt;stdio.h&gt;using namespace std;int main(){freopen(\"INPUT.TXT\", \"r\", stdin);freopen(\"OUTPUT.TXT\", \"w\", stdout);int x;cin &gt;&gt; x;cout &lt;&lt; x;return 0;}Phần sau: [C++ Cơ bản] Phần 9: Toán tử",
              url: "/article/c-co-ban-phan-8-input-va-output-tiep"
            }
            ,

            {
              title: "[SPOJ] NKREZ - Hội trường",
              author: "Joker",
              category: ["spoj"],
              tag: ["spoj"],
              content: "Link bài gốc:http://vnoi.info/problems/show/NKREZ/Đề bài:Nhà trường có một phòng hội trường. Có những yêu cầu muốn sử dụng phòng hội trường này, mỗi yêu cầu cho biết thời điểm bắt đầu và thời điểm kết thúc. Nhà trường có thể chấp nhận hoặc từ chối đối với một yêu cầu.Yêu cầu: hãy giúp nhà trường chọn các yêu cầu sử dụng hội trường sao cho tổng thời gian hội trường được sử dụng là lớn nhất.Dữ liệuDòng đầu tiên chứa một số nguyên dương n (n ≤ 10000), số yêu cầu.Mỗi dòng trong số n dòng tiếp theo chứa 2 số nguyên dương p và k (0 ≤ p &lt; k ≤ 30000), mô tả một yêu cầu bắt đầu tại thời điểm p và kết thúc tại thời điểm k.Kết qủaGồm một dòng duy nhất là tổng thời gian lớn nhất mà hội trường được sử dụngVí dụ:Input:121 23 50 46 87 134 69 109 1211 1415 1914 1618 20Output:16Solution:Tham khảo tại: http://viahold.com/17AmCode:Tham khảo tại: http://viahold.com/178O",
              url: "/spoj/spoj-nkrez-hoi-truong"
            }
            ,

            {
              title: "[C++ Cơ bản] Phần 7: Input - Output",
              author: "Admin Tổng Quản",
              category: ["article"],
              tag: ["cpp-cơ-bản", "programming"],
              content: "Phần trước: [C++ Cơ bản] Phần 6: Biến global và biến localNhập và xuất là hai yếu tố vô cùng cơ bản của một chương trình. Trong những bài viết trước của C++ Cơ bản, chúng ta đã sử dụng cout để in thông tin ra màn hình console. Bài viết này và bài viết sau sẽ dành ra để giải thích cụ thể về input và output trong C++.Tóm tắt nhanh về thư viện stdio.h của CThư viện stdio.h và các hàm scanf(), printf() là phương pháp input - output tiêu chuẩn của C. C++ thừa hưởng tất cả các tài nguyên của C, do đó chúng cũng có thể được sử dụng trong C++. Tuy nhiên series bài viết này sẽ không đi sâu vào thư viện này vì:  Cú pháp của các hàm scanf() và printf() phức tạp hơn so với cin và cout của C++.  cin và cout là phương pháp input và output chuẩn của C++.Bạn có thể nghe nói rằng cin và cout chậm hơn scanf() và printf(). Điều này là đúng, bởi vì chúng phải đồng bộ hóa luồng nhập xuất với thư viện stdio.h để chương trình có thể sử dụng cả hai thư viện của C và C++. Tuy nhiên trong áp dụng thực tế, chênh lệch này có thể tạm bỏ qua được, trừ khi bạn thật sự cần tốc độ xử lý cao (như khi lập trình thi đấu). Khi đó bạn có thể tắt đồng bộ hóa bằng việc sử dụng lệnh:iostream::sync_with_stdio(false);Lưu ý rằng kể cả sau khi áp dụng iostream::sync_with_stdio(false), tốc độ của cin/cout vẫn có thể chậm hơn đáng kể so với scanf()/printf() trên một số bộ dịch, nhưng nhìn chung thì điều này không quá ảnh hưởng tới việc lập trình thi đấu. Mục đích chính của các kì thi phần lớn là để kiểm tra kĩ năng thuật toán, cho dù kĩ năng tối ưu hóa vẫn là hết sức quan trọng.Các thư viện nhập/xuất của C++Nhập/xuất của C++ diễn ra theo các stream (luồng), là các dãy byte được gửi tới (từ thiết bị nhập xuất, từ các file, vv…) và gửi đi (tới các thiết bị hiển thị như màn hình, loa, vv…) từ chương trình.C++ có ba thư viện quan trọng cho việc nhập/xuất:            Thư viện        Chức năng                iostream        Định nghĩa các đối tượng cin, cout, cerr, clog, tương ứng với các stream input, output, stream báo lỗi không buffer và có buffer.                iomanip        Định nghĩa các hàm để tùy chỉnh lại dữ liệu nhập xuất, ví dụ như chỉnh sửa độ chính xác của số thập phân được in ra, chỉnh sửa hệ cơ số của số được in ra (thập phân, bát phân, …), vân vân…                fstream        Thư viện này liên quan tới việc xử lý với file. Sẽ được giải thích trong bài viết sau.    Để khai báo sử dụng thư viện, ta sử dụng cú pháp:#include &lt;tên_thư_viện&gt;Chú ý không cần sử dụng dấu chấm phẩy.Buffer là gì?Buffer là một vùng nhớ tạm thời của hệ thống, dành cho việc tạm thời lưu trữ dữ liệu của chương trình trước khi di chuyển tới một vùng khác. Đối với input và output, buffer giống như việc lưu trữ tất cả các nội dung cần được nhập và xuất, trước khi được nhập vào hoặc xả ra.coutcout là một đối tượng thuộc class ostream. cout được kết nối với các đối tượng đầu ra tiêu chuẩn, ví dụ như màn hình console của hệ điều hành. Ta sử dụng cout với toán tử chèn dữ liệu vào stream (stream insertion) &lt;&lt; (hai dấu nhỏ hơn).Chú ý: Ở đây mình có nói tới class ostream. Class và các nội dung của lập trình hướng đối tượng sẽ được giới thiệu kĩ hơn ở các bài sau. Hiện tại, hãy tạm hiểu class là một kiểu dữ liệu được người dùng định nghĩa, khác với các kiểu dữ liệu nguyên thủy như int, float, double, vv…Ví dụ:#include &lt;iostream&gt;using namespace std; int main( ) {   cout &lt;&lt; \"Xin chào \" &lt;&lt; \"Việt Nam\" &lt;&lt; endl;}Output:Xin chào Việt NamToán tử &lt;&lt; có thể được sử dụng nhiều lần trong một câu lệnh cout, như ở ví dụ trên.C++ cho phép người dùng in ra các giá trị thuộc các kiểu dữ liệu có sẵn int, float, double, char, string và các giá trị con trỏ.cout là phương pháp output có sử dụng buffer.cincin là một đối tượng thuộc class istream. cin được kết nối với các đối tượng đầu vào tiêu chuẩn, ví dụ như bàn phím. Ta sử dụng cin với toán tử lấy dữ liệu từ stream (stream extraction) &gt;&gt; (hai dấu lớn hơn).Ví dụ: chương trình sau sẽ yêu cầu bạn nhập vào một số, và in ra số bạn đã nhập vào.#include &lt;iostream&gt;using namespace std;int number;int main(){    cout &lt;&lt; \"Nhap vao mot so: \";    cin &gt;&gt; number;    cout &lt;&lt; \"So ban nhap vao la: \" &lt;&lt; number;    return 0;}Bộ dịch C++ sẽ tự động nhận ra kiểu dữ liệu của biến được đặt sau toán tử, và lựa chọn phương pháp nhập dữ liệu phù hợp với kiểu dữ liệu đó.Toán tử &gt;&gt; cũng có thể được sử dụng nhiều lần trong một câu lệnh.cin là phương pháp input có sử dụng buffer.cerr và clogcerr và clog là hai đối tượng của class ostream giống như cout. Về mặc định, chúng cũng được kết nối với các đối tượng đầu ra tiêu chuẩn như cout, và cũng sử dụng chung toán tử &lt;&lt; như cout.Điểm khác biệt giữa cerr và clog là cerr không được buffer, còn clog thì có. Điều này có nghĩa là tất cả nội dung của cerr sẽ được in ra ngay lập tức, trong khi clog sẽ được lưu trữ lại cho tới khi buffer đầy hoặc được giải phóng (do người dùng tự giải phóng, khi có dữ liệu xuất ra mới và cần in ra dữ liệu cũ, hoặc khi chương trình kết thúc).cerr và clog được sử dụng nhiều vào việc in ra các thông báo lỗi. Khi xây dựng các dự án lớn với C++, chúng sẽ trở nên vô cùng quan trọng, vì ta có thể thay đổi luồng ra của output (cout) ra riêng với các thông báo lỗi (cerr và clog) để quan sát riêng rẽ.Phần sau: [C++ Cơ bản] Phần 8: Input và Output (tiếp)",
              url: "/article/c-co-ban-phan-6-input-output"
            }
            ,

            {
              title: "[SPOJ] KSEQ1 - Dãy số 1",
              author: "houtaru",
              category: ["spoj"],
              tag: ["spoj", "dp"],
              content: "Link đề bài : http://vnoi.info/problems/show/KSEQ1/Đề bài :Cho một dãy số A1 …. An Yêu cầu: tìm số K lớn nhất sao cho tồn tại dãy chỉ số i1 &lt; i2 &lt; … &lt; i2k thỏa mãn Ai1 &lt; Ai( k + 1 ) ; Ai2 &lt; Ai( k + 2 ) …… Aik &lt; Ai2kDữ liệuDòng đầu ghi số nguyên dương N.Dòng sau ghi N số Ai ( 1 ≤ i ≤ N ).Kết quả :Ghi trên một dòng số K lớn nhất tìm được.Giới hạn :N ≤ 300 ; 1 ≤ Ai ≤ 10000.Example :Dữ liệu:71 2 3 4 5 6 7Kết qủa3Solution : http://viahold.com/13wyCode : http://viahold.com/13x5",
              url: "/spoj/spoj-kseq1-day-so-1"
            }
            ,

            {
              title: "[SPOJ] NKDIVSEQ - Chia đoạn",
              author: "rknguyen",
              category: ["spoj"],
              tag: ["spoj", "math"],
              content: "Link bài gốc:http://vnoi.info/problems/show/NKDIVSEQ/Đề bài:Thầy Hoàng xây dựng một dãy số vô hạn A từ dãy các số nguyên dương bằng cách lần lượt xét các số tự nhiên bắt đầu từ 1 và lần lượt chọn các số cho dãy A theo quy tắc : chọn một số chia hết cho 1 (hiển nhiên là số 1),  sau đó là hai số chia hết cho 2, tiếp theo là 3 số chia hết cho 3, 4 số chia hết cho 5, 5 số chia hết cho 5…. Như vậy các số đầu tiên của dãy A là: 1, 2, 4, 6, 9, 12, 16, 20, 24, 28, 30, 35, 40, 45, 50, 54, …..Thầy Hoàng tìm ra quy luật xác định một cách nhanh chóng các phần tử của dãy. Bạn là người lập trình giỏi, hãy giúp các bạn Đội tuyển Toán viết chương trình kiểm tra quy luật mà Thầy Hoàng tìm ra có đúng hay không.Yêu cầuCho số tự nhiên N. Hãy xác định số thứ N của dãy số.Dữ liệu  Chứa duy nhất số N (1≤ N ≤100000).Kết quảGhi ra số thứ N tìm được.Ví dụ:Input:10Output:28Solution:Tham khảo tại: http://viahold.com/picCode:Tham khảo tại: http://viahold.com/piw",
              url: "/spoj/spoj-nkdivseq-chia-doan"
            }
            ,

            {
              title: "[SPOJ] SEQ198 - VOI 2016 - SEQ198",
              author: "CVHvn",
              category: ["spoj"],
              tag: ["dp", "spoj"],
              content: "Link đề bài : http://vnoi.info/problems/show/SEQ198/Đề bài :Con số 198 có gợi cho bạn điều gì không? Khi học lịch sử Việt Nam, Vinh biết rằng ngày 19-8-1945 là ngày Tổng khởi nghĩa, ngày nhân dân cả nước ta nhất tề đứng lên làm cuộc Cách mạng Tháng Tám vĩ đại. Hiện nay, 198 được đặt tên cho nhiều bệnh viện, công viên, đường phố trong cả nước. Con số này đã gợi ý cho Vinh khảo sát dãy số SEQ98 sau đây: Dãy số nguyên không âm a1, a2, …, an được gọi là dãy SEQ198 nếu không tồn tại hai chỉ số i và j (1 ≤ i,j ≤ n) mà ai-aj hoặc là bằng 1 hoặc là bằng 8 hoặc là bằng 9.Ví dụ:Dãy số nguyên 1, 3, 5, 7 là dãy SEQ198.Dãy số nguyên 7, 3, 5, 1, 9, 21 không phải là dãy SEQ198 bởi vì có hai phần tử 1 và 9 có hiệu 9 - 1 = 8. Tuy nhiên, sau khi xóa bớt phần tử 1, ta thu được dãy 7, 3, 5, 9, 21 là một dãy SEQ198.Vinh quan tâm tới bài toán sau đây: Cho dãy số nguyên không âm b1, b2, …, bm, hãy tìm cách loại bỏ một số ít nhất phần tử của dãy để được dãy còn lại là SEQ198.Input :Dòng đầu chứa số nguyên dương m;Dòng thứ hai chứa m số nguyên không âm b1, b2, …, bm (bi ≤ 10^9).Output :Ghi ra số nguyên k là số phần tử bị loại bỏ. Ghi số 0 nếu dãy đã cho là SEQ198.Ràng buộc :Có 50% số test ứng với 50% số điểm của bài có m ≤ 20.Có 50% số test còn lại ứng với 50% số điểm của bài có m ≤ 2000.Solution : http://viahold.com/oUJCode : http://viahold.com/oU0",
              url: "/spoj/spoj-seq198-voi-2016-seq198"
            }
            ,

            {
              title: "[C++ Cơ bản] Phần 6: Biến global và biến local",
              author: "Admin Tổng Quản",
              category: ["article"],
              tag: ["cpp-cơ-bản", "programming"],
              content: "Phần trước: [C++ Cơ bản] Phần 5: Biến và kiểu dữ liệuTa định nghĩa scope (phạm vi) là các khu vực của một chương trình. Các biến của chương trình C++ có thể được định nghĩa tại 3 vị trí:  Bên trong một khối lệnh (ví dụ như hàm int main() của chương trình). Các biến như vậy được gọi là biến local (local variable, nhiều tài liệu sẽ dịch là biến địa phương).  Trong phần định nghĩa của một hàm. Các biến như vậy được gọi là tham số của hàm đó (parameter).  Ở bên ngoài tất cả các hàm. Các biến như vậy được gọi là biến global (global variable, nhiều tài liệu sẽ dịch là biến toàn cục).Hàm, chương trình con và tham số của hàm sẽ được trình bày trong một bài viết khác. Trọng tâm của bài viết này là về biến global và local.Biến localBiến local được định nghĩa trong một khối lệnh, và chỉ tồn tại bên trong khối lệnh đó. Khi khối lệnh được thực hiện xong thì biến local cũng sẽ biến mất. Biến local cũng không thể truy cập được từ bên ngoài khối lệnh của nó.Ví dụ: Biến x ở đoạn code sau là biến local của hàm int main()#include &lt;iostream&gt;using namespace std; int main () {   int x = 10;   cout &lt;&lt; x;   return 0;}Biến globalBiến global được định nghĩa bên ngoài các khối lệnh. Biến global có thể được định nghĩa ở bất cứ vị trí nào trong chương trình (tất nhiên, bên ngoài khối lệnh), tuy nhiên thường ta quy chuẩn đặt chúng ở đầu chương trình. Chúng sẽ giữ nguyên giá trị của mình trong suốt quá trình chạy của chương trình, và tất cả các hàm hay chương trình con của chương trình đều có thể truy cập vào chúng.Ví dụ: Biến x trong đoạn code sau là biến global#include &lt;iostream&gt;using namespace std;int x = 10; int main () {   cout &lt;&lt; x;   return 0;}Trong một chương trình, ta có thể khai báo những biến local và global trùng tên nhau. Khi ta truy cập vào tên của chúng, biến local sẽ được sử dụng trong hàm mà nó được định nghĩa.Ví dụ: Trong đoạn code sau, chương trình sẽ in ra giá trị của biến local#include &lt;iostream&gt;using namespace std;int x = 10; int main () {   int x = 20;   cout &lt;&lt; x;   return 0;}Output:20Giá trị mặc định của các biếnKhi một biến local được khởi tạo, chương trình C++ sẽ lấy một ô nhớ bất kỳ của hệ thống để dành cho nó. Điều này dẫn tới việc biến local không có giá trị mặc định cụ thể, và ta bắt buộc phải tự tay đặt giá trị cho chúng.Khi một biến global được khởi tạo, tất cả các bit biểu diễn của nó sẽ có giá trị bằng 0. Điều này có nghĩa là:  Các kiểu biến số có giá trị đều bằng 0  Các kiểu chữ cái sẽ có giá trị đều bằng kí tự '\\0' (kí tự null)  Các con trỏ đều có địa chỉ NULL (sẽ nói trong các bài sau)  Vân vân…Tuy nhiên, việc khởi tạo các biến một cách hợp lệ vẫn là một điều nên làm, để tránh việc các tác nhân bên ngoài (ví dụ: một bộ dịch không theo quy chuẩn này) có thể làm ảnh hưởng tới chương trình.Phần sau: [C++ Cơ bản] Phần 7: Input - Output",
              url: "/article/c-co-ban-phan-6-bien-global-va-bien-local"
            }
            ,

            {
              title: "[SPOJ] CHEER - Động viên đàn bò",
              author: "itsjustwinds",
              category: ["spoj"],
              tag: ["graph", "spoj"],
              content: "Đề: http://vnoi.info/problems/show/CHEER/Bác John dạo này lười đến nỗi không muốn bảo trì các con đường dẫn bác đến thăm N (5 &lt;= N &lt;= 10,000) cánh đồng (đánh số từ 1 đến N) nữa. Mỗi cánh đồng là nơi ở của một cô bò. Bác John có kế hoạch loại bỏ nhiều nhất P (N-1 &lt;= P &lt;= 100,000) con đường sao cho các cánh đồng vẫn liên thông.Ban phải xác định N-1 con đường cần giữ lại.Đường nối hai chiều j nối giữa cánh đồng Sj và Ej(1 &lt;= Sj&lt;= N; 1 &lt;= Ej&lt;= N; Sj# Ej) và cần Lj(0 &lt;= Lj&lt;= 1000) thời gian để di chuyển. Không có hai cánh đồng nào được nối trực tiếp bởi nhiều hơn một con đường.Đàn bò buồn vì hệ thống giao thông của chúng sắp bị rút gọn. Bạn phải thăm mỗi cô bò ít nhất một lần trong ngày để động viên. Mỗi lần thăm cánh đồng i (dù chỉ đi ngang qua), bạn phải trò chuyện với cô bò trong thời gian Ci(1 &lt;= Ci&lt;= 1000).Bạn sẽ nghỉ lại đêm trên cùng một cánh đồng (bạn sẽ được chọn) cho đến khi đàn bò đều đã hết bị suy sụp. Bạn sẽ trò chuyện với cô bò trong cánh đồng mà bạn nghỉ lại ít nhất 2 lần vào buổi sáng thức dậy và vào buổi tối khi trở về nghỉ.Giả dụ bác John theo lời khuyên của bạn giữ lại một số con đường và bạn sẽ chọn cánh đồng tối ưu nhất để nghỉ lại, hãy xác định thời gian nhỏ nhất bạn cần để thăm tất cả đàn bò ít nhất một lần trong ngày.Dữ liệu      Dòng 1: Hai số nguyên N và P cách nhau bởi khoảng trắng        Dòng 2..N+1: Dòng i+1 chứa một số nguyên duy nhất Ci        Dòng N+2..N+P+1: Dòng N+j+1 chứa ba số nguyên phân biệt: Sj, Ej và Lj  Kết quả  Dòng 1: Một số nguyên duy nhất, tổng thời gian cần để thăm tất cả đàn bò (bao gồm hai lần thăm cô bò ở nơi mà bạn nghỉ).Ví dụDữ liệu:5 71010206301 2 52 3 52 4 123 4 172 5 153 5 64 5 12Kết quả:176Hướng dẫnhttp://viahold.com/n0jCodehttp://viahold.com/n14",
              url: "/spoj/spoj-cheer-dong-vien-dan-bo"
            }
            ,

            {
              title: "[SPOJ] C11CAVE - Hang động",
              author: "Joker",
              category: ["spoj"],
              tag: ["spoj"],
              content: "Link đề bài gốc:http://vnoi.info/problems/show/C11CAVE/Đề bài:Một con đom đóm bay vào một cái hang đầy những chướng ngại vật gồm: măng đá (nhô lên từ mặt đất) và nhũ đá (đâm xuống từ trần hang). Hang này dài N đơn vị (N chẵn) và cao H đơn vị. Khi vào hang, vật cản đầu tiên là măng đá, sau đó là nhũ đã, rồi lại đến măng đá, … cứ thế thay phiên nhau.Đây là một ví dụ về một hang dài 14 đơn vị và cao 5 đơn vị.Con đom đóm này không phải là loài có thể bay quanh các chướng ngại vật. Thay vào đó, nó sẽ chọn một mức chiều cao bắt đầu rồi bay từ đầu đến cuối hang, phá hết tất cả các chướng ngại vật trên đường bay của nó.Theo ví dụ trên, nếu chọn mức 4, con đom đóm sẽ phá tất cả là 8 chướng ngại vật.Đây không phải là lựa chọn tốt nhất vì con đom đóm sẽ ít mệt hơn nếu chọn mức 1 hoặc mức 5, lúc này nó chỉ cần phá 7 chướng ngại vật.Bạn được cho chiều dài, chiều cao và kích thước của tất cả các chướng ngại vật. Hãy xác định số chướng ngại vật tối thiểu mà con đom đóm cần phá để thoát khỏi hang, và có bao nhiêu cách chọn khác nhau đưa đến kết quả đó.Dữ liệu  Dòng 1: Hai số nguyên N và H (1 ≤ N ≤ 2.105 và 1 ≤ H ≤ 5.105) là chiều dài và chiều cao của hang.  Mỗi dòng trong N dòng tiếp theo là một số nguyên dương - kích thước của chướng ngại vật. Tất cả các kích thước đều nhỏ hơn H.Kết quảGồm 2 số nguyên cách nhau là số chướng ngại vật ít nhất cần phá và số cách chọn khác nhau để có được kết quả đó.Ví dụ:Input:6 7153351Output:2 3Solution:Tham khảo tại: http://viahold.com/mwWCode:Tham khảo tại: http://viahold.com/mtJ",
              url: "/spoj/spoj-c11cave-hang-dong"
            }
            ,

            {
              title: "[Lý thuyết đồ thị cơ bản] Phần 4: Đường đi ngắn nhất trên đồ thị và thuật toán Dijkstra",
              author: "Phương Nguyễn",
              category: ["article"],
              tag: ["lý-thuyết-đồ-thị-cơ-bản", "graph"],
              content: "Phần trước: [Lý thuyết đồ thị cơ bản] Phần 3: Tìm kiếm theo chiều sâu trên đồ thị - Depth-First Search (DFS)Đường đi ngắn nhất trên đồ thịNếu đồ thị biểu diễn một mạng lưới giao thông, thì người ta không chỉ quan tâm tới việc có tồn tại đường đi từ một đỉnh này tới đỉnh khác hay không, mà người ta còn quan tâm tới con đường tối ưu nhất, ngắn nhất có thể.Trong lý thuyết đồ thị, bài toán đường đi ngắn nhất giữa hai đỉnh cho trước là bài toán tìm một đường đi giữa chúng sao cho tổng các trọng số của các cạnh tạo nên đường đi đó là nhỏ nhất. Định nghĩa một cách hình thức, cho trước một đồ thị có trọng số \\( G = (V, E, w) \\) (nghĩa là một tập đỉnh V, một tập cạnh E, và một hàm trọng số có giá trị thực w : E → R), cho trước một đỉnh u thuộc V, tìm một đường đi P từ u tới một đỉnh v thuộc V sao cho:nhỏ nhất trong tất cả các đường đi từ u tới v. Bài toán đường đi ngắn nhất giữa mọi cặp đỉnh là một bài toán tương tự, trong đó ta phải tìm các đường đi ngắn nhất cho mọi cặp đỉnh u và v.Các thuật toán thường được dùng để giải quyết những bài toán này là:  Thuật toán Dijkstra - giải bài toán bài toán đường đi ngắn nhất giữa hai đỉnh cho trước nếu tất cả các trọng số đều không âm. Thuật toán này có thể tính toán tất cả các đường đi ngắn nhất từ một đỉnh xuất phát cho trước s tới mọi đỉnh khác mà không làm tăng thời gian chạy.  Thuật toán Bellman-Ford - giải bài toán bài toán đường đi ngắn nhất giữa hai đỉnh cho trước trong trường hợp trọng số có thể có giá trị âm.  Giải thuật tìm kiếm A* giải bài toán  bài toán đường đi ngắn nhất giữa hai đỉnh cho trước sử dụng heuristics để tăng tốc độ tìm kiếm  Thuật toán Floyd-Warshall - giải bài toán đường đi ngắn nhất cho mọi cặp đỉnh.  Thuật toán Johnson - giải bài toán đường đi ngắn nhất cho mọi cặp đỉnh, có thể nhanh hơn thuật toán Floyd-Warshall trên các đồ thị thưa.  Lý thuyết nhiễu (Perturbation theory) - tìm đường đi ngắn nhất địa phương (trong trường hợp xấu nhất)Chú ý:Ta có đường đi P = {v1, v2, …, vk} là một đường đi ngắn nhất từ v1 tới vk. Khi đó ta có nhận xét, đường đi từ vi tới vj qua {vi, vi+1, …, vj} với i,j ∈ [1, k] là một đường đi ngắn nhất từ vi tới vj.Thuật toán DijkstraTrong trường hợp đồ thị \\( G = (V, E, w) \\) có trọng số trên các cạnh không âm, ta có thuật toán Dijkstra để tìm đường đi ngắn nhất từ đỉnh xuất phát s tới các đỉnh khác của đồ thị.Ý tưởng của thuật toán:Ta có mảng kc[u] là khoảng cách ngắn nhất từ đỉnh s tới đỉnh u trên đồ thị. Ban đầu kc[s] = 0, các giá trị khác bằng dương vô cực. Ta sẽ lấy đỉnh u có kc[u] nhỏ nhất vào thời điểm hiện tại, và sử dụng khoảng cách của nó để cập nhật khoảng cách ngắn nhất của các đỉnh xung quanh. Với một đỉnh u bất kì, vì nó được cập nhật bởi các đường đi ngắn nhất của các đỉnh xung quanh nó, nên bản thân đường đi của nó cũng là ngắn nhất.Dữ liệu:  Đồ thị được biểu diễn bằng danh sách kề với một mảng vector g[maxn] với g[u] lưu các đỉnh kề của u kèm theo trọng số  Mảng kc dùng để lưu trữ độ dài đường đi ngắn nhất từ đỉnh nguồn s đến đỉnh u.  Để tính được giá trị nhỏ nhất này, khi khởi tạo ta phải gán cho kc[u] = +∞ (khi cài đặt trên máy tính, ta chỉ cần đặt bằng một giá trị cực lớn), sau đó gặp giá trị nhỏ hơn thì thay thế lại.  Những đỉnh đã tính được kc[u] hữu hạn được cho vào một hàng đợi có ưu tiên. Hàng đợi này luôn được bổ sung và sắp xếp lại bằng một cấu trúc hợp lý (heap, set,…)  Để theo dõi trạng thái của các đỉnh trong quá trình xét, ta dùng hàm cl. Lúc đầu các đỉnh được tô màu trắng (cl[u]=0), khi đã tính xong khoảng cách nó được tô màu đen(cl[u] != 0).  Nếu cần ghi lại đường đi ta sẽ phải dùng một hàm pre để chỉ đỉnh đứng ngay trước đỉnh u trên đường đi ngắn nhất từ s tới u.Cài đặt bằng ngôn ngữ C++ dùng set:#define fs first#define sc secondtypedef pair&lt;int,int&gt; II;vector&lt;II&gt; g[maxn];set&lt;II&gt; S;int cl[maxn], kc[maxn];void Dijkstra(int s) {\tmemset(kc,0,sizeof(kc));\tcl[s]=1;\tS.insert(II(kc[s],s));\twhile(!s.empty())\t{\t\tII t=*S.begin();\t\tS.erase(t);\t\tint u=t.sc;\t\tfor(int i=0; i&lt;S.size(); ++i)\t\t{\t\t\tint v=g[u][i].fs, L=g[u][i].sc;\t\t\tif(cl[v]==0)\t\t\t{\t\t\t\tcl[v]=1;\t\t\t\tkc[v]=kc[u]+L;\t\t\t\tS.insert(II(kc[v],v));\t\t\t} else if(kc[v]&gt;kc[u]+L)\t\t\t{\t\t\t\tS.erase(II(kc[v],v));\t\t\t\tkc[v]=kc[u]+L;\t\t\t\tS.insert(II(kc[v],v));\t\t\t}\t\t}\t}}Độ phức tạpThuật toán Dijkstra bình thường sẽ có độ phức tạp là \\( O(n^2+m) \\), do ta phải duyệt n lần (đối với n đỉnh), mỗi lần duyệt lại phải duyệt qua n đỉnh để tìm đỉnh có kc[u] nhỏ nhất. Tuy nhiên ta có thể sử dụng kết hợp với cấu trúc heap hoặc set, khi đó độ phức tạp sẽ là \\( O((m+n)log(n)) \\), nếu dùng Fibonacci thì độ phức tạp giảm xuống còn \\( O(m+nlog n) \\). Trong đó m là số cạnh, n là số đỉnh của đồ thị đang xét (giới thiệu ở bài sau).Bài tập ví dụ:  QBSCHOOL. Lời giải tại đây.  QBBUILD. Lời giải tại đây.  NETACCEL. Lời giải tại đây.  VDANGER.  BESTSPOT.Phần sau: [Lý thuyết đồ thị cơ bản] Phần 5: DAG và sắp xếp topo trên đồ thị",
              url: "/article/ly-thuyet-do-thi-co-ban-phan-4-duong-di-ngan-nhat-tren-do-thi-va-thuat-toan-dijkstra"
            }
            ,

            {
              title: "[SPOJ] BLGEN - Chuỗi gen đặc trưng",
              author: "G",
              category: ["spoj"],
              tag: ["dp"],
              content: "Link đề gốc: http://vnoi.info/problems/show/BLGEN/.Đề bài:Tế bào của một cá thể sinh vật ngoài hành tinh mới được phát hiện gồm rất nhiều gen, mỗi gen trong chuỗi gen của tế bào đều có số lượng nào đó các nucleotide (ký hiệu là nu). Các chuyên gia thường quan tâm chuỗi gen của mỗi cá thể dưới góc độ một chuỗi số lượng tương ứng các nu (gọi tắt là chuỗi nu), do đó chuỗi sẽ như là một dãy số nguyên dương đồng thời số số hạng của dãy này sẽ được gọi là độ dài của chuỗi. Mỗi gen được xem là đặc biệt nếu số nu của nó hoặc là bình phương của một số nguyên hoặc là lập phương của một số nguyên tố. Để nghiên cứu khả năng biến đổi gen của loài sinh vật nói trên, các nhà khoa học xem xét hai mẫu chuỗi nu của hai cá thể và quan tâm đến mức độ “giống nhau” giữa chúng theo cách tìm ra chuỗi con chỉ gồm các gen đặc biệt mà cùng xuất hiện ở cả hai chuỗi nu (mỗi chuỗi con như vậy đều được gọi là chuỗi đặc trưng chung của hai chuỗi nu). Lưu ý rằng, chuỗi con của một chuỗi nu X, là chuỗi thu được từ X bằng cách giữ nguyên tất cả hoặc loại bỏ đi một số nào đó các gen mà vẫn giữ thứ tự  xuất hiện trong chuỗi X.Yêu cầu :Xác định độ dài lớn nhất L của chuỗi đặc trưng chung của hai chuỗi nu cho trước. Dữ liệu vào:Dòng đầu ghi lần lượt các số hạng của chuỗi nu thứ nhất. Dòng tiếp theo ghi lần lượt các số hạng của chuỗi nu thứ hai.Tất cả các số hạng của hai chuỗi đều nguyên dương và không vượt quá 10^19.Độ dài của mỗi chuỗi nu đều không vượt quá 1000.Kết quả:Ghi ra  duy nhất một số nguyên L tìm được. Ví dụ :  Input :2 9 8 4 1 27 4 65 6 9 1 8 2 6 27 1 4Output :4(Giải thích: L = 4, một trong các chuỗi đăc trưng chung là: 9, 1, 27, 4) Ràng buộc :60% số test ứng với 60% số điểm của bài ứng với tình huống độ dài của hai chuỗi nu  không vượt  quá 255 và giá trị của mỗi số hạng đều không vượt quá 10^6Solution :HereCode :Here",
              url: "/spoj/spoj-blgen-chuoi-gen-dac-trung"
            }
            ,

            {
              title: "[SPOJ] FLOW1 - Giao lưu",
              author: "Nicky.Rio",
              category: ["spoj"],
              tag: ["spoj", "max-flow"],
              content: "Link gốchttp://vnoi.info/problems/show/FLOW1/Đề bàiCuộc thi giao lưu “Tết Ta Tin (TTT)” giữa hai đội Sư Phạm (SP) và Tổng Hợp (TH) có m bài toán tin học, mỗi đội có n học sinh tham dự. Các bài toán được đánh số từ 1 đến m và các học sinh của mỗi đội được đánh số từ 1 tới n.Học sinh của hai đội đều là những lập trình viên xuất sắc, tuy nhiên mỗi học sinh có thể giải quyết những bài toán thuộc sở trường của mình hiệu quả hơn những bài khác.Hãy giúp thầy My tổ chức cuộc thi theo thể thức sau:  Chọn đúng n cặp đấu, mỗi cặp gồm 01 học sinh SP và 01 học sinh TH làm 01 bài toán trong số những bài toán này.  Có đúng n bài toán được mang ra thi  Học sinh nào cũng được tham gia  Bài toán cho cặp đấu bất kỳ phải thuộc sở trường của cả hai thí sinh trong cặpBiết rằng luôn tồn tại phương án thực hiện yêu cầu trên.Input  Dòng 1: Chứa hai số n, m (1 ≤ n ≤ m ≤ 255)  n dòng tiếp theo, dòng thứ i ghi danh sách các bài toán thuộc sở trường của học sinh SP thứ i.  n dòng tiếp theo, dòng thứ j ghi danh sách các bài toán thuộc sở trường của học sinh TH thứ j.Chú ý dùng Eoln chứ không dùng SeekEolnOutputGồm m dòng, dòng thứ k ghi số hiệu thí sinh SP và số hiệu thí sinh TH trong cặp đấu bằng bài toán k, nếu bài toán k không được mang ra thi thì ghi vào dòng này hai số 0 .ExampleInput4 63 61 22 4563 5 641 2 6Output2 40 00 03 34 21 1Solutionhttp://viahold.com/YzFCode mẫuhttp://viahold.com/YmZ",
              url: "/spoj/spoj-flow1-giao-luu"
            }
            ,

            {
              title: "[SPOJ] C11PNUM - Số nguyên tố!",
              author: "Nguyễn Minh Quân",
              category: ["spoj"],
              tag: ["spoj", "math", "implementation"],
              content: "Link đề gốc: http://vnoi.info/problems/show/C11PNUM/Đề bàiCho 2 số nguyên N và K (1 &lt;= N &lt;= 264- 1, 3 &lt;= K &lt;= 10). Tìm số nguyên lớn nhất không vượt quá N và là tích của K số nguyên tố liên tiếp.Input  Dòng đầu là số nguyên T tương ứng với số bộ test (1 &lt;= T &lt;= 15)  T dòng tiếp theo mỗi dòng là 1 cặp số (N, K) cách nhau 1 dấu cáchOutput  Gồm T dòng là kết quả của T bộ test tương ứng, nếu không tìm được số thỏa mãn in ra -1SolutionHereCode mẫuHere",
              url: "/spoj/spoj-c11pnum-so-nguyen-to"
            }
            ,

            {
              title: "[SPOJ] BINARY2 - SPBINARY2",
              author: "G",
              category: ["spoj"],
              tag: ["spoj", "dp"],
              content: "Link đề gốc : http://vnoi.info/problems/show/BINARY2/.Đề bài :Đề bài tương tựSPBINARY, nhưng giới hạn lớn hơnCho 2 số n và k ( 2&lt;=k &lt;= n &lt;= 10^6)Hãy đếm xem có bao nhiêu xâu nhị phân độ dài n mà không có quá k số 0 hoặc k số 1 nào liên tiếp nhau.InputGồm 1 dòng duy nhất là 2 số n và k.OutputGồm 1 dòng duy nhất là số dãy nhị phân thoả mãn (module 10^9).ExampleInput:3 2Output:6Solution :HereCode :Here",
              url: "/spoj/binary2-spbinary2"
            }
            ,

            {
              title: "[SPOJ] BASEH - Cơ số H",
              author: "G",
              category: ["spoj"],
              tag: ["spoj", "implementation"],
              content: "Link đề bài : http://vnoi.info/problems/show/BASEH/.Đề bài :Cho một dãy số a[1],a[2],a[3],…,a[n] và hai số K,H được xác định như sau:  a[1]=1.  Nếu K chẵn thì a[K] = H * a[K / 2].  Nếu K lẻ thì a[K] = H * a[(K - 1) / 2] + 1.Các bạn hãy lập trình tính số thứ K của dãy viết trong hệ cơ số H.Input  Gồm một dòng duy nhất chứa 2 số K,H.Output  In ra số duy nhất là kết quả bài toán.Giới hạn  0&lt; K &lt;=1000000000.  0=&lt; H &lt;=2008.Ví dụInput7 110Output111Soluntion :HereCode :Here",
              url: "/spoj/spoj-baseh-co-so-h"
            }
            ,

            {
              title: "[SPOJ] LEM7 - COMPANY",
              author: "Nguyễn Minh Quân",
              category: ["spoj"],
              tag: ["spoj", "dp"],
              content: "Link đề gốc: http://vnoi.info/problems/show/LEM7/Đề bàiMột công ty gồm một số phòng, mỗi phòng gồm 1 số lãnh đạo và 1 số nhân viên, trong phòng không có ai vừa là lãnh đạo vừa là nhân viên. Không có 2 người nào cùng thuộc 2 phòng khác nhau. Mỗi lãnh đạo điều hành công việc của mọi nhân viên trong phòng nhưng 2 lãnh đạo thuộc cùng phòng không điều hành nhau. Hiệu quả của 1 phòng được tính bằng số lượng quan hệ trong phòng đó.Ví Dụ: Nếu 1 phòng có 2 lãnh đạo và 3 nhân viên thì hiệu quả phòng đó bằng 6. Hiệu quả của công ty bằng tổng hiệu quả các phòng.Một công ty muốn có hiệu quả bằng 1 số nguyên dương E cho trước. Hãy tìm cách tổ chức công ty sao cho các điều kiện sau được thoả mãn:  Công ty có ít nhất 1 phòng  Hiệu quả của công ty đúng bằng E  Số N là tổng số người trong công ty nhỏ nhất có thể được  Nếu có nhiều phương án tổng số người đúng bằng N tìm phương án có tổng số lãnh đạo S là nhỏ nhất  Nếu có nhiều phương án với N và S nhỏ nhất tìm phương án có số phòng K là ít nhấtInputGồm 1 dòng duy nhất: E (1 &lt;= E &lt;= 10000)OutputGồm 1 dòng ghi 3 số nguyên: N, S, KSolutionHereCode mẫuHere",
              url: "/spoj/spoj-lem7-company"
            }
            ,

            {
              title: "[SPOJ] MINK - Huyền thoại Lục Vân Tiên",
              author: "Accepted Problems",
              category: ["spoj"],
              tag: ["spoj", "data-structure", "stack"],
              content: "Link đề gốc:http://vnoi.info/problems/show/MINK/Đề bài:Dạo này tivi cũng đang chiếu phim Lục Vân Tiên , sẵn tiện lấy luôn làm tiêu đề .Lục Vân Tiên cũng giống Samurai Jack , bị Quan Thái Sư đẩy vào vòng xoáy thời gian và bị chuyển tới tương lai của những năm 2777 .Ở thời đại này , Tráng sỹ phải là người thông thạo máy tính , gõ bàn phím lia lịa như đấu sỹ thời xưa múa kiếm ấy và phải qua một cuộc thi lập trình mới được phong danh hiệu .Để vượt qua vòng loại , Vân Tiên cần tham gia cuộc thi sát hạch . Ban Giám Khảo cuộc thi sát hạch gồm có N người , họ đều là các cao thủ trong giới IT . Các thành viên trong Ban Giám Khảo được đánh số từ 1 -&gt; N và mỗi người lại có một chỉ số sức mạnh gọi là APM ( Actions Per Minute ) . Các giám khảo sẽ xếp hàng lần lượt từ 1 -&gt; N . Mỗi thí sinh sẽ phải đấu với K vị giám khảo và K vị giám khảo này phải đứng liền thành 1 đoạn ( Tức là i , i+1 , i+2 , … i+K-1 ) , chỉ cần thắng 1 vị giám khảo thì sẽ vượt qua vòng loại .Tuy nhiên thí sinh kô được chọn xem những giám khảo nào sẽ đấu với mình .Vân Tiên rất lo vì lỡ may đụng độ với những vị giám khảo nào “khó nhằn” thì sẽ tiêu mất . Nên chiến thuật của Vân Tiên là tập trung hạ vị giám khảo có chỉ số APM thấp nhất trong số K vị . Bạn hãy lập trình để giúp Lục Vân Tiên xác định được ở tất cả các phương án thì chỉ số APM của vị giám khảo thấp nhất sẽ là bao nhiêu ( Có tất cả N-k+1 phương án :Phương án 1 : Vân Tiên phải đấu với vị 1 -&gt; vị kPhương án 2 : Vân Tiên phải đấu với vị 2 -&gt; vị k+1…Phương án N-k+1 : Vân Tiên phải đấu với vị N-k+1 -&gt; vị N ) .( 1 &lt;= N &lt;= 17000 , chỉ số APM của 1 giám khảo &gt;= 1 và &lt;= 2 * 10^9 , 1 &lt;= K &lt;= N ) .InputDòng 1 : số T là số test .Tiếp theo là T bộ test , mỗi bộ test có format như sau :Dòng 1 : N kDòng 2 : N số nguyên dương A[1] , … A[N] .OutputKết quả mỗi test ghi ra trên dòng , dòng thứ i gồm N-k+1 số , số thứ j tương ứng là chỉ số APM của vị giám khảo yếu nhất trong phương án j .Ví dụ:Input:24 23 2 4 13 31 2 3Output:2 2 11Solution:Tham khảo tại:http://viahold.com/SaTCode:Tham khảo tại: http://viahold.com/SZmCode đã được nộp và AC trên SPOJ, sử dụng bộ dịch của C++11",
              url: "/spoj/spoj-mink-huyen-thoai-luc-van-tien"
            }
            ,

            {
              title: "[SPOJ] QTDIVSEQ - Chia đoạn",
              author: "Joker",
              category: ["spoj"],
              tag: ["spoj", "dp"],
              content: "Link bài gốc:http://vnoi.info/problems/show/QTDIVSEQ/Đề bài:Cho dãy A gồm n số nguyên A1, A2,… , Anvà số nguyên dương k. Hỏi có bao nhiêu cách chia dãy A thành k đoạn liên tiếp có tổng bằng nhau (mỗi đoạn có ít nhất 1 phần tử) ?InputDòng đầu: hai số nguyên dương n và k, cách nhau một khoảng trắngDòng hai: n số nguyên A1, A2,… , An, mỗi số cách nhau một khoảng trắngOutputSố nguyên S là số cách chia thỏa yêu cầu đề bài. Do kết quả có thể rất lớn, bạn chỉ cần in ra S mod 1000000007 (10^9+ 7)Giới hạn1 ≤ k ≤ n ≤ 10^6|Ai| ≤ 10^9 (1 ≤ i ≤ n)Ví dụ:Input:8 3-2 6 -1 3 -2 4 5 -1Output:2Solution:Tham khảo tại: http://viahold.com/ROlCode:Tham khảo tại: http://viahold.com/S0J",
              url: "/spoj/spoj-qtdivseq-chia-doan"
            }
            ,

            {
              title: "[SPOJ] MTOTALF - Total Flow",
              author: "itsjustwinds",
              category: ["spoj"],
              tag: ["max-flow", "spoj"],
              content: "Đề: http://vnoi.info/problems/show/MTOTALF/Để quản lý nước cho đàn bò, FJ  đã vẽ bản đồ đường ống gồm N (1&lt;=N&lt;=700) ống trong trang trại mà nối bể nước với các chuồng. FJ thấy rằng các đường ống có kích thước khác nhau và được nối một cách rất kỳ lạ. Do đó, FJ muốn tính xem lượng nước truyền qua các ống.Hai ống nước được nối liên tiếp với nhau cho phép lượng nước không vượt quá thông lượng nhỏ nhất của hai ống. Một ống có thông lượng 5 nối với ống có thông lượng 3 sẽ tương đương với một ống có thông lượng 3.:  +---5---+---3---+    -&gt;    +---3---+Còn hai ống nối song song cho phép thông lượng nước là tổng thông lượng của từng ống.    +---5---+ ---+       +---    -&gt;    +---8---+    +---3---+Còn một ống mà không nối với chuồng bò nào hay ống nào khác có thể bỏ đi:    +---5---+ ---+               -&gt;    +---3---+    +---3---+--Sử dụng cách thức trên, cho bản đồ đường ống, xác định lượng nước có thểtruyền từ nguồn (A) cho tới chuồng (Z).Xét ví dụ sau:             +-----------6-----------+    A+---3---+B                      +Z             +---3---+---5---+---4---+                     C       DỐng BC và CD có thể gộp lại được:             +-----------6-----------+    A+---3---+B                      +Z             +-----3-----+-----4-----+                         DSau đó gộp BD và DZ  :             +-----------6-----------+    A+---3---+B                      +Z             +-----------3-----------+Gộp hai nhánh nối B và Z:             B    A+---3---+---9---+ZGộp AB và BZ và thông lượng thu được là 3:    A+---3---+ZFJ cần viết một chương trình đọc vào một tập các đường ống mà mỗiđường ống được mô tả thông qua 2 đầu nối và tính thông lượng từ ‘A’ tới ‘Z’.Mọi dữ liệu cần tính đều có thể suy luận theo các quy tắc bên trên.Ống i nối hai nút a_i và b_i (a_i,b_i là các chữ cái hoa hoặc thường  ‘A-Za-z’) và có thông lượng F_i (1 &lt;= F_i &lt;= 1,000). Tên nút phân biệt chữ cái hoa và thường (‘A’ &lt;&gt; ‘a’).Input* Dòng 1: Số nguyên N* Dòng 2..N + 1: Dòng i+1 mô tả ống i qua hai chữ cái và một số nguyên,cách nhau bởi 1 dấu trống: a_i, b_i, and F_iVí dụ:5A B 3B C 3C D 5D Z 4B Z 6Output* Dòng 1: Lượng nước lớn nhất có thể truyền từ nguồn A tới chuồng Z.Ví dụ:  3Hướng dẫn:http://viahold.com/Nn8Codehttp://viahold.com/Nnh",
              url: "/spoj/spoj-mtotalf-total-flow"
            }
            ,

            {
              title: "[SPOJ] NKFLOW - Luồng cực đại trên mạng",
              author: "itsjustwinds",
              category: ["spoj"],
              tag: ["max-flow", "spoj"],
              content: "Đề: http://vnoi.info/problems/show/NKFLOW/Trong lý thuyết đồ thị, mạng luồng là một đồ thị có hướng, trong đó mỗi cạnh có một độ thông qua và một giá trị luồng. Lượng luồng trên mỗi cạnh không được vượt quá độ thông qua của cạnh đó. Lượng luồng đi vào một đỉnh phải bằng lượng luồng đi ra khỏi nó, trừ khi đó là đỉnh nguồn (có nhiều lượng luồng đi ra hơn), hay đỉnh đích (có nhiều lượng luồng đi vào hơn). Mạng luồng có thể dùng để mô hình hóa hệ thống đường giao thông, dòng chảy của chất lỏng trong ống, dòng điện trong mạch, hay bất kỳ các bài toán nào tương tự khi có sự di chuyển trong một mạng các nút.Mô hình các ống dẫn nước bằng một mạng luồng. Mỗi ống nước có đường kính xác định nên chỉ cho phép một lưu lượng nước xác định chảy qua. Ở nơi giao điểm giữa các ống, lưu lượng nước đi vào phải bằng lưu lượng nước đi ra nếu không nước sẽ nhanh chóng bị thất thoát. Ta có một bồn nước, hay đỉnh phát, và một vòi nước, hay đỉnh thu. Một cách trực quan, giá trị luồng trên mạng chính là vận tốc nước chảy ra từ vòi. Luồng còn có thể mô hình sự lưu chuyển của người hay hàng hóa trên các mạng giao thông, dòng điện trong hệ thống phân phối,… Đối với các hệ thống mạng này, luồng đi vào các nút trung gian cần phải bằng luồng đi ra khỏi nút đó. Tính chất này cũng giống như định luật dòng điện Kirchhoff. Mạng luồng còn được ứng dụng trong sinh thái học: mạng luồng xuất hiện khi xem xét sự lưu chuyển chất dinh dưỡng và năng lượng giữa các nhóm khác nhau trong một mạng thức ăn. Các bài toán gắn với loại mạng sinh thái này hoàn toán khác với trường hợp mạng chất lỏng hay mạng giao thông.Bài toán luồng cực đại trên mạng yêu cầu tìm một luồng tương thích có giá trị lớn nhất trong mạng luồng có một đỉnh phát và một đỉnh thu. Bài toán luồng cực đại trên mạng có thể xem như trường hợp đặc biệt của lớp các bài toán mạng phức tạp hơn, chẳng hạng như bài toán lưu thông . Định lý luồng cực đại-lát cắt hẹp nhất (max-flow min-cut theorem) chỉ ra giá trị luồng cực đại từ s đến t (đỉnh phát đến đỉnh thu) bằng giá trị của lát cắt s-t hẹp nhất trên mạng.Bạn hãy thử giải quyết bài toán luồng cực đại trên mạng: cho một mạng luồng, hãy tìm giá trị luồng cực đại.Dữ liệu  Dòng đầu tiên chứa 4 số nguyên dương n, m, s, t, (2 ≤ n ≤ 1000) tương ứng là số đỉnh, số cạnh của đồ thị, chỉ số của đỉnh phát và đỉnh thu.  m dòng tiếp theo, mỗi dòng có dạng ba số u, v, c cách nhau ít nhất một dấu cách thể hiện có cung u, v trong mạng với khả năng thông qua là c (1 ≤ c ≤ 10^6).Kết qủaIn ra một số duy nhất là giá trị của luồng cực đại trên mạng.Ví dụDữ liệu:6 8 1 61 2 51 3 52 4 62 5 33 4 33 5 14 6 65 6 6Kết qủa9Hướng dẫnhttp://viahold.com/NbkCodeDinitz(N^2*M): http://ideone.com/DGrZT7E.K(N*M^2): http://ideone.com/JNxZ0h",
              url: "/spoj/spoj-nkflow-luong-cuc-dai-tren-mang"
            }
            ,

            {
              title: "[SPOJ] PALINY - Palindrome dài nhất",
              author: "itsjustwinds",
              category: ["spoj"],
              tag: ["binary-search", "string", "spoj"],
              content: "Đề: http://vnoi.info/problems/show/PALINY/Cho xâu S. Tìm xâu đối xứng dài nhất gồm các kí tự liên tiếp trong SInputDòng 1: N (số ký tự của xâu S; N&lt;=50 000)Dòng 2: Xâu ký tự độ dài NOutput1 dòng duy nhất gồm độ dài của xâu đối xứng dài nhấtExampleInput:5abacdOutput:3Hướng dẫnhttp://viahold.com/NCjCodehttp://viahold.com/NHI",
              url: "/spoj/spoj-paliny-palindrome-dai-nhat"
            }
            ,

            {
              title: "[C++ Cơ bản] Phần 5: Biến và kiểu dữ liệu",
              author: "Admin Tổng Quản",
              category: ["article"],
              tag: ["cpp-cơ-bản", "programming"],
              content: "Phần trước: [C++ Cơ bản] Phần 4: Cú pháp C++ cơ bảnKhi lập trình, chúng ta cần phải sử dụng biến để lưu trữ dữ liệu của chương trình. Các biến được lưu trữ trên bộ nhớ của hệ thống - khi ta khai báo một biến trong chương trình, ta đang yêu cầu hệ thống trích ra một khoảng bộ nhớ để lưu trữ thông tin của biến đó.C++ là ngôn ngữ đặt kiểu dữ liệu tĩnh (statically typed), có nghĩa là mỗi biến và hàm của chương trình đều có một kiểu dữ liệu cố định trong quá trình chạy chương trình. Kiểu dữ liệu quyết định kích thước bộ nhớ mà biến hoặc hàm chiếm trên hệ thống, khoảng giá trị mà biến hoặc hàm có thể biểu diễn, và những thao tác xử lý ta có thể thực hiện lên giá trị của chúng.Các kiểu dữ liệu nguyên thủy    Kiểu dữ liệu    Từ khóa    BooleanKiểu dữ liệu đúng sai (true/false)    bool    CharacterKiểu kí tự    char    IntegerKiểu số nguyên    int    Floating pointKiểu số thực    float    Double floating pointKiểu số thực, với khoảng biểu diễn và độ chính xác cao hơn    double    ValuelessKhông trả giá trị gì về cả. Kiểu dữ liệu này thường thấy khi ta muốn tạo ra một chương trình con - một hàm chỉ thực hiện thao tác trên các đối tượng, mà không trả lại gì cả.    void    Wide characterKiểu kí tự, với khoảng biểu diễn rộng hơn    wchar_tMột số kiểu dữ liệu nguyên thủy còn có thể được tùy chỉnh bằng các từ khóa:  signed: Khi đặt trước các kiểu số, nó cho biết kiểu số này có dấu (khoảng giá trị bao gồm cả số âm). Thường vô dụng và không dùng tới.  unsigned: Khi đặt trước các kiểu số, nó cho biết kiểu số này không có dấu (chỉ bao gồm số không âm). Điều này làm tăng giá trị cực đại của khoảng biểu diễn lên.  short: Đặt trước kiểu int để đặt kiểu giá trị số nguyên, với khoảng biểu diễn và khoảng bộ nhớ chiếm chỗ giảm một nửa. Có thể viết short thay vì short int.  long: Sử dụng long long int để đặt kiểu giá trị số nguyên, với khoảng biểu diễn và khoảng bộ nhớ chiếm chỗ tăng gấp đôi. Có thể viết long long thay vì long long int. long int không có khác biệt gì so với int.Khoảng giá trị và bộ nhớ chiếm chỗ của các kiểu dữ liệu“Cái đm, lại phải nhớ một đống số nữa à?”Thật ra là không. Đúng, khoảng giá trị của các biến là hằng số, nhưng ta không cần phải nhớ một cách máy móc. Lấy ví dụ như kiểu int:Như chúng ta đã biết, các dữ liệu trong  máy tính được lưu trữ bằng dãy bit nhị phân 0 - 1. 8 bit nhị phân thì bằng 1 byte. Cứ \\( 2 ^ {10} \\) (1024) byte thì bằng 1 kB, \\( 2 ^ {10} \\) kB thì bằng 1 MB, vân vân… int là kiểu dữ liệu số nguyên 4 byte, vậy nên nó sẽ được biểu diễn bằng 32 bit.Nếu biểu diễn số nguyên bằng cả 32 bit thì sẽ không thể biểu diễn số âm được. Vậy người ta quy ước bit đầu tiên của giá trị int sẽ mang giá trị \\( - 2 ^ {31} \\), thay vì \\( 2 ^ {31} \\) như bình thường. Ví dụ:  Số 7 sẽ được biểu diễn là 0000 0000 0000 0000 0000 0000 0000 0111 (3 bit 1 ở cuối, tổng bằng 7)  Số 100 sẽ được biểu diễn là 0000 0000 0000 0000 0000 0000 ‭0110 0100‬‬‬  Số -1 sẽ được biểu diễn là ‭1111111111111111111111111111111111111111111111111111111111111111‬ (tất cả đều là số 1, giá trị bằng \\( - 2 ^ {31} + 2 ^ {30} + 2 ^ {29} + 2 ^ {28} + …\\))‬‬Vậy khoảng giá trị của int là từ \\( - 2 ^ {31} \\) tới \\( 2 ^ {31} - 1 \\).short có kích cỡ bằng một nửa int, vậy nó sẽ chiếm 2 byte, khoảng giá trị là \\( - 2 ^ {15} \\) tới \\( 2 ^ {15} - 1 \\).long có kích cỡ bằng gấp đôi int, vậy nó sẽ chiếm 8 byte, khoảng giá trị là \\( - 2 ^ {63} \\) tới \\( 2 ^ {63} - 1 \\).Khi các biến dạng số được gắn thêm unsigned, chúng sẽ không biểu diễn số âm nữa, do đó tất cả các bit của chúng đều sẽ được dùng để biểu diễn số nhị phân – việc tính toán khoảng của chúng cũng đơn giản như vậy.Ta chỉ cần nhớ dữ liệu được lưu trữ bằng bao nhiêu byte, là có thể suy ra khoảng của chúng.Đối với các kiểu dữ liệu kí tự, kí tự biểu diễn được còn phụ thuộc vào bảng mã chương trình sử dụng.Các bạn có thể xem kích cỡ và khoảng của các kiểu dữ liệu tại đây.Tại sao kiến thức này lại quan trọng?Đầu tiên, việc biết giới hạn biểu diễn của các kiểu dữ liệu là cực kì quan trọng, để tránh việc thực hiện tính toán tràn khả năng biểu diễn dẫn tới sai sót. Việc thực hiện tính toán trên các kiểu dữ liệu sẽ được đề cập rõ hơn trong các bài viết về toán tử.Như đã nói trong các bài viết trước, C++ được sử dụng nhiều trong việc lập trình điều khiển phần cứng. Không phải phần cứng nào cũng có nhiều dung lượng bộ nhớ - các thiết bị như đèn nháy, máy giặt làm sao có thể lắp RAM 4 GB như laptop được.Kể cả khi dung lượng không phải là vấn đề, việc tiết kiệm bộ nhớ của chương trình và đem đến trải nghiệm tốt hơn cho người dùng cũng là một việc nên làm.Đối với các bạn sử dụng C++ để lập trình thi đấu, việc sử dụng quá nhiều bộ nhớ cũng sẽ gây sinh ra lỗi Memory Limit Exceeded (MLE) và bài làm của các bạn có thể bị đánh fail, vậy nên phải biết cách sử dụng bộ nhớ hợp lý.Khai báo biến trong C++Để khai báo biến, ta sử dụng cú pháp:kiểu_dữ_liệu danh_sách_các_biến;Ví dụ:int    i, j, k;char   c, ch;float  f, salary;double d;Các biến cũng có thể được gán giá trị khởi tạo bằng cú pháp:kiểu_dữ_liệu tên_biến = giá_trị;Ví dụ:int d = 3, f = 5; char x = 'x'; Giá trị khởi tạo của các biến khi không được người dùng đặt trước sẽ được nói trong một bài khác, tuy nhiên việc tự khởi tạo giá trị cho biến là một việc nên làm, tránh những thay đổi ở bên ngoài chương trình có thể làm giá trị này khác đi.Đặt giá trị cho biếnSau khi được khai báo, giá trị của biến có thể được thay đổi lại bằng cú pháp:tên_biên = giá_trị;Ví dụ:int x;x = 20;Nếu đặt giá trị cho một biến chưa tồn tại trước đó, trình dịch sẽ báo lỗi.Chương trình ví dụChương trình sau đây sẽ khởi tạo một số biến và in ra giá trị của chúng#include &lt;iostream&gt;using namespace std;  int main () {   // Khai báo biến   int a, b = 10;   int c;   float f;    // Đặt giá trị cho biến   a = 10;   b = 20;   c = a + b;   cout &lt;&lt; c &lt;&lt; endl ;   f = 70.0/3.0;   cout &lt;&lt; f &lt;&lt; endl ;   return 0;}Output:3023.3333Viết tắt kiểu dữ liệu bằng typedefTừ khóa typedef cho phép ta đặt cách gọi khác cho một kiểu dữ liệu. Ví dụ, ta muốn sử dụng cách gọi ULL để gọi tên cho kiểu dữ liệu unsigned long long int, ta sử dụng cú pháp:typedef unsigned long long int ULL;Khi đó ta có thể khai báo các biến kiểu unsigned long long int bằng cách sử dụng tên kiểu dữ liệu ULL:ULL x = 1000;Phần sau: [C++ Cơ bản] Phần 6: Biến global và biến local",
              url: "/article/c-co-ban-phan-5-bien-va-kieu-du-lieu"
            }
            ,

            {
              title: "[Lý thuyết đồ thị cơ bản] Phần 3: Tìm kiếm theo chiều sâu trên đồ thị - Depth-First Search (DFS)",
              author: "Phương Nguyễn",
              category: ["article"],
              tag: ["lý-thuyết-đồ-thị-cơ-bản", "graph"],
              content: "Phần trước: [Lý thuyết đồ thị cơ bản] Phần 2: Tìm kiếm theo chiều rộng trên đồ thị - Breadth-First Search (BFS)Bài này chúng ta sẽ tiếp tục với các thuật toán tìm kiếm trên đồ thị. Bài trước là BFS, bài này sẽ nói về DFS, tìm kiếm theo chiều sâu. Nó là một thuật toán đơn giản nhưng bạn sẽ làm được nhiều thứ tuyệt vời với nó.Như bình thường, chúng ta sẽ có một đồ thị có hướng liên thông G=(V, E), |V|=n, |E|=m và sẽ biểu diễn nó bằng một danh sách kề. Chúng ta sẽ sử dựng một mảng vector để lưu. Vector g[u] sẽ lưu một danh sách các đỉnh kề với u.Và mục đích của chúng ta sẽ là “khám phá” đồ thị này. Chúng ta sẽ đi thăm tất cả các đỉnh của đồ thị, theo một thứ tự bất kì nào đó, mỗi đỉnh một lần.Bằng việc sử dụng BFS, chúng ta sẽ duyệt đồ thị loang ra theo từng lớp từ một đỉnh xuất phát u và chúng ta sẽ tìm được những con đường ngắn nhất, những cách nhanh nhất để tới một đỉnh khác. Và BFS là một cách tốt để tìm xem đỉnh nào không thể tới được từ u.DFS tương tự như vậy. Tuy những con đường đi tới một đỉnh khác chúng ta tìm ra chưa chắc đã là ngắn nhất, nhưng xét trên phương diện cài đặt thì DFS đơn giản và gọn nhẹ hơn BFS nhiều.Ý TưởngÝ tưởng vô cùng đơn giản. Nó giống như việc bạn lạc vào một mê cung. Và bạn có một cái bánh mì. Cách tốt nhất để thoát khỏi mê cung trước khi bánh mì hết là: Bạn nhìn thấy một lối đi trước mặt, bạn đi theo lối đó, và vừa đi vừa rải những mẩu bánh mì nhỏ dọc theo con đường. Khi bạn tới một ngõ cụt, bạn quay lại con đường đã đi. Nếu bạn gặp ngã rẽ, bạn nhìn thấy bánh mì ở một con đường và bạn biết mình đã đi qua nó rồi, nó vô dụng, và bạn sẽ đi theo ngả khác.Và nếu bạn hết bánh mì, nó giống như việc bộ nhớ máy tính của bạn không đủ hoặc thời gian bạn có để giải quyết vấn đề đã hết vậy. Xin chúc mừng, bạn đã dùng hết thời gian và bánh mì để duyệt các đỉnh trong mê cung, và giờ bạn đã mắc kẹt và sẽ chết đói :vThuật Toán  Thăm đỉnh xuất phát, đỉnh u, đánh dấu đỉnh u.  Xét các đỉnh v kề với đỉnh hiện đang thăm          Nếu đỉnh v chưa được đánh dấu (chưa thăm), thăm đỉnh v.      Nếu đỉnh v đã được đánh đấu, bỏ qua.      Cài đặt bằng ngôn ngữ C++So sánh với BFS, chúng ta có thể cài đặt DFS dễ dàng với một hàm đệ quy.Tùy theo những gì bạn cần làm trên đồ thị mà bạn có thể điều chỉnh code cho phù hợp.vector g[maxn]; // vector lưu các đỉnh kề với các đỉnhint dd[maxn]; // mảng đánh dấuvoid dfs(int u){    dd[u]=1; // đánh dấu đỉnh u đã đi qua    for(int i = 0; i &lt; g[u].size(); ++ i) // với mỗi đỉnh v kề với u    {        int v = g[u][i];        if(dd[v] == 0) dfs(v); // nếu v chưa đánh dấu, tới thăm đỉnh u    }}Độ phức tạpO(|V| + |E|) tương đương BFS  DFS được gọi đúng 1 lần ứng với mỗi đỉnh.  Mỗi cạnh được duyệt qua 1 lần với đồ thị có hướng. Nếu là đồ thị vô hướng thì mỗi cạnh được duyệt qua 2 lần.Ứng dụngDFS được ứng dụng rất nhiều. Ví dụ như…  Xác định các thành phần liên thông của đồ thị  Sắp xếp tô-pô cho đồ thị  Xác định các thành phần liên thông mạnh của đồ thị có hướng  Kiểm tra một đồ thị có phải là đồ thị phẳng hay khôngChú ý: Với code đệ quy bằng ngôn ngữ C++, do C++ giới hạn bộ nhớ một chương trình con được phép sử dụng, đôi khi số lượng đỉnh lớn một chút sẽ làm bạn bị tràn lượng bộ nhớ đó, cần phải áp dụng cài đặt khử đệ quy để tránh trường hợp này. Tuy nhiên trong các cuộc thi lập trình thi đấu (và trong lập trình thực tế), bạn ít khi gặp phải trường hợp này. Cài đặt khử đệ quy cũng khó và dễ sai hơn so với đệ quy, nên cũng không đáng phải liều mạng tới mức đó.Một số bài tập vận dụngADS (SPOJ). Lời giải xem tại đây.PWALK (SPOJ)Phần sau: [Lý thuyết đồ thị cơ bản] Phần 4: Đường đi ngắn nhất trên đồ thị và thuật toán Dijkstra",
              url: "/article/ly-thuyet-do-thi-co-ban-phan-3-tim-kiem-theo-chieu-sau-tren-do-thi-depth-first-search-dfs"
            }
            ,

            {
              title: "[SPOJ] AMSSEQ - Dãy số",
              author: "G",
              category: ["spoj"],
              tag: ["dp", "qhd"],
              content: "Link gốc : http://vnoi.info/problems/show/AMSSEQ/.Đề bài :Cho 1 dãy số gồm N phần tử (N ≤ 10000), mỗi phần tử có 1 giá trị nằm trong khoảng [-1000, 1000]. Ban đầu, bạn sẽ ở vị trí ô số 0 với tổng điểm là 0. Mỗi nước đi, người chơi có thể di chuyển sang phải tối thiểu là 1 bước và tối đa là K bước (K ≤ 10) . Khi dừng lại ở 1 ô nào đó thì giá trị của ô đó sẽ được cộng vào tổng điểm. Bạn có thể dừng cuộc chơi bất cứ lúc nào. Hãy tìm cách chơi sao cho tổng điểm nhận được là nhiều nhất.Dữ liệu vào      Dòng đầu tiên chứa 2 số N, K.        Dòng thứ 2 chứa N số của dãy, mỗi số cách nhau 1 dấu cách. Mỗi số nằm trong khoảng [-1000, 1000]  Dữ liệu ra  Số điểm lớn nhất có thể đạt được.Giới hạn:  N ≤ 10000.  K ≤ 10.  Trong 20% số test có N ≤ 10Ví dụInput:5 2 -2 3 -6 -4 5Output:4Giải thích:- Ta có thể đi theo thứ tự 0 -&gt; 2 -&gt; 4 -&gt; 5. Số điểm đạt được là 0 + 3 - 4 + 5 = 4.Solution :HereCode :Here",
              url: "/spoj/spoj-amsseq-day-so"
            }
            ,

            {
              title: "[SPOJ] JOBSET - VOI 2014 - Chọn công việc",
              author: "Nicky.Rio",
              category: ["spoj"],
              tag: ["spoj", "max-flow"],
              content: "Link gốchttp://vnoi.info/problems/show/JOBSET/Đề bàiCông ty xây dựng SVI phải lựa chọn các dự án cần thực hiện để lợi nhuận đem lại là nhiều nhất. Công ty có một danh sách gồm n dự án đánh số từ 1 đến n. Sau khi công ty rà soát năng lự thực hiện các dự án, công ty đưa ra bảng đánh giá hiệu quả (có thể là lợi nhuận hoặc thua lỗ) từ việc thực hiện dự án i là pi (nếu pi &gt; 0 đó là lợi nhuận, ngược lại nếu pi &lt; 0 thì đó là thua lỗi phải chị từ việc thực hiện dự án i, |pi| &lt; 10^6). Việc lựa chọn các dự án cần thực hiện để lợi nhuận đem lại là lớn nhất không phải là đơn giản bời vì công ty không thể chi lựa chọn các công việc đem lại lợi nhuận để thực hiện. Có một danh sách gồm m điều kiện liên quan đến việc lựa chọn thực hiện các dự án. Điều kiện thứ j yêu cầu: “Nếu thực hiện dự án uj thì phải thực hiện dự án vj”, j = 1, 2, .., m. Một tập con các dự án được gọi là lựa chọn được nếu mỗi dự án trong nó luôn thỏa mãn các điều kiện trong danh sách.Yêu cầuHãy giúp công ty tìm tập các dự án lựa chọn được mà việc thực hiện chúng đem lại tổng hiệu quả lớn nhất.Input  Dòng đầu ghi một số nguyên dương n  Dòng thứ hai ghi n số nguyên tương ứng là tính hiệu quả của từng công việc.  Dòng thứ bai ghi một số nguyên dương m (m &lt;= 10^4).  Dòng thứ j trong số m dòng tiếp theo ghi hai số nguyên dương uj và vj chỉ sự ràng buộc rằng nếu thực hiện công việc uj thì phải thực hiện công việc vj.OutputGhi ra một số nguyên là tổng hiệu quả của tập các dự có thể án thực hiện tìm được. Ghi ra số 0 nếu như không chọn dự án nảo cả.Giới hạn  30% số test có n &lt;= 20.  30% số test khác có n &lt;= 100.  40% số test còn lại có n &lt;= 500.ExampleInput610 4 -5 3 -1 -242 32 56 54 3Output11Solutionhttp://viahold.com/BW4Code mẫuhttp://viahold.com/BOl",
              url: "/spoj/spoj-jobset-voi-2014-chon-cong-viec"
            }
            ,

            {
              title: "[SPOJ] VO17PHD - Du lịch Bắc Ninh",
              author: "Nicky.Rio",
              category: ["spoj"],
              tag: ["spoj", "shortest-path"],
              content: "Link gốchttp://vnoi.info/problems/show/VO17PHD/Đề bàiSau khi ra đề xong cho kỳ thi VNOP (Vietnam National Olympiad in Philosophy) Online 2017, GS - TSKH - NGND - CVCC kiêm nhà Đông Phương học PVH quyết định tự thưởng cho mình một chuyến du lịch Bắc Ninh.Bắc Ninh là tỉnh nổi tiếng với dân ca quan hệ. Bắc Ninh là trung tâm xứ Kinh Bắc cổ xưa. Hiện nay trên địa bàn tỉnh Bắc Ninh có khoảng 41 lễ hội đáng chú ý trong năm được duy trì. Trong đó có những lễ hội lớn như: hội chùa Dâu, Hội Lim, hội đền Đô, hội đền Bà Chúa Kho. Con người Bắc Ninh với truyền thống văn hoá, hiếu khách, cần cù và sáng tạo, với những bàn tay khéo léo mang đậm nét dân gian của vùng trăm nghề như tơ tằm, gốm sứ, đúc đồng, trạm bạc, khắc gỗ, làm giấy, tranh vẽ dân gian… nổi bật là những làn điệu dân ca quan hệ. Ngoài ra, nếu ai có dịp về Đình Bảng du xuân, thì không thể bỏ qua cơ hội thưởng thức món bánh phu thê đặc sản nổi tiếng của vùng đất kinh kỳ. Những cặp bánh thơm ngon được người dân Đình Bảng dùng trong những mâm lễ cưới hỏi hay những ngày lễ, Tết với mong ước về một cuộc sống sung túc, ấm no, hạnh phúc. Bánh phu thê (có nghĩa là chồng vợ) nên người ta thường mua ít nhất một cặp chứ không bao giờ mua lẻ một chiếc…Thành phố Bắc Ninh bao gồm N khu phố. Các khu phố được đánh số từ 1 tới N, và được nối với nhau bởi M con đường hai chiều. Mỗi con đường có một độ dài riêng biệt.Vào dịp ghé thăm của nhà Đông Phương học PVH, có rất nhiều sự kiện quảng bá văn hóa và du lich Bắc Ninh được diễn ra. Đặc biệt, vào mỗi ngày, tại thành phố N sẽ diễn ra buổi biểu diễn những làn điệu quan hệ. Thêm vào đó, những chiếc bánh phu thê cũng được bán ở tất cả các khu phố trên toàn Bắc Ninh. Mỗi ngày, tại khu phố i có Pi chiếc bánh phu thê được mang ra bán ở đây.Là người yêu thích văn hóa Phương Đông từ lâu, GS - TSKH - NGND - CVCC PVH không muốn bỏ lỡ giây phút thưởng thức quan hệ Bắc Ninh nào, nên đã chọn con đường đi ngắn nhất để đi từ khu phố 1 (khách sạn của GS) tới khu phố N (nơi diễn ra sự kiện nghệ thuật). Ngoài ra, GS còn muốn trên con đường ngắn nhất của mình, tổng số lượng bánh phu thê được rao bán ở đây là lớn nhất.Hãy giúp GS tìm ra độ dài đường đi ngắn nhất và tổng số bánh được bán nhiều nhất trên con đường này.InputDòng đầu tiên chứa số nguyên dương N là số khu phố tại Bắc Ninh.Dòng thứ hai chứa N số nguyên P1, P2, …, PN, lần lượt là số bánh phu thê được rao bán tại các khu phố 1, 2, …, N.Dòng thứ ba chứa số nguyên M là số con đường hai chiều trên toàn thành phố.M dòng tiếp theo, mỗi dòng chứa ba số nguyên dương U, V và C, miêu tả một con đường giữa hai khu phố U và V với chiều dài là COutputNếu không tồn tại đường đi từ khu phố 1 tới khu phố N, in ra “impossible”. Ngược lại, in ra hai số nguyên trên một dòng lần lượt là độ dài đường đi ngắn nhất từ khu phố 1 tới khu phố N và tổng số bánh phu thê tối đa được rao bán trên một con đường ngắn nhất.Giới hạn      Trong tất cả các test, 1 &lt;= N &lt;= 10^5, 0 &lt;= M &lt;= 10^5, 0 &lt;= Pi&lt;= 10^9 và 1 &lt;= C &lt;= 10^9        Trong 30% số test đầu tiên, P1 = P2= … = PN= 0.        Trong 30% số test tiếp theo, N &lt;= 1000 và C = 1.        Trong 40% số test còn lại, không có ràng buộc gì thêm.  ExampleInput82 1 1 1 100 1 1 2101 2 12 3 23 4 24 8 11 8 71 5 35 8 41 6 26 7 27 8 2 Output6 7Solutionhttp://viahold.com/AuHCode mẫuhttp://viahold.com/AcA",
              url: "/spoj/spoj-vo17phd-du-lich-bac-ninh"
            }
            ,

            {
              title: "[SPOJ] VO17LAN - Hoa Ngọc Lan",
              author: "Nguyễn Minh Quân",
              category: ["spoj"],
              tag: ["spoj", "vnoi-online", "vo17", "implementation", "math"],
              content: "Link đề gốc : http://vnoi.info/problems/show/VO17LAN/Đề bàiĐể chuẩn bị cho kì thi VOI 2017, hai đội tuyển Hải Phòng và Hải Dương dắt tay nhau ra Hà Nội học Giáo Sư.Saker vốn từ trước đến nay bị_Lũ bạn sống lỗi_ ghét bỏ, nên khi cả đội ra Hà Nội, không ai cho Saker ở cùng phòng. Bí quá, Saker chẳng còn cách nào ngoài cách cầu xin hai bạn nữ đội Hải Phòng cho ở nhờ.Để việc “xin xỏ tỏ tình” dễ bề thành công, trước khi đi, Saker hái một bó gồm N bông hoa Ngọc Lan. N bông hoa này có độ hấp dẫn là A1, A2, …, AN. Saker cần phải chia bó hoa trên làm hai phần tặng cho hai bạn nữ.Độ hấp dẫn của một phần được tính bằng ước số chung lớn nhất của độ hấp dẫn các bông hoa trong phần đó. Saker muốn chia số hoa hiện tại sao cho độ hấp dẫn của phần hoa kém hấp dẫn hơn là lớn nhất có thể. Tất nhiên, nếu Saker dành toàn bộ số hoa chỉ cho một người, chiến tranh thế giới sẽ nổ ra và hắn sẽ bị đuổi khỏi phòng đầu tiên.Hãy giúp Saker thực hiện trót lọt ý đồ ám muội này.InputDòng đầu tiên chứa một số nguyên T, là số bộ dữ liệuCác dòng tiếp theo lần lượt mô tả các bộ dữ liệu. Mỗi bộ dữ liệu được mô tả trên hai dòng: Dòng đầu tiên chứa số N là số bông hoa, dòng thứ hai chứa N số nguyên dương A1, A2, …, ANlần lượt là độ hấp dẫn của các bông hoa.OutputVới mỗi bộ dữ liệu, in ra trên một dòng một số nguyên duy nhất là độ hấp dẫn tối đa của phần hoa kém hấp dẫn hơn.Giới hạn      Trong 25% số test đầu tiên, T &lt;= 20, 2 &lt;= N &lt;= 15 và Ai&lt;= 109.        Trong 25% số test tiếp theo, T &lt;= 20, 2 &lt;= N &lt;= 100 và Ai&lt;= 270.        Trong 50% số test còn lại, 2 &lt;= N &lt;= 50000, Ai&lt;= 109và tổng giá trị của N trong các test của môt file input không quá 200000.  SolutionHereCode mẫuHere",
              url: "/spoj/spoj-vo17lan-hoa-ngoc-lan"
            }
            ,

            {
              title: "[SPOJ] MINCUT - VOI 2015 Day 2 - Cắt hình",
              author: "Nguyễn Minh Quân",
              category: ["spoj"],
              tag: ["spoj", "binary-search"],
              content: "Link đề gốc: http://vnoi.info/problems/show/MINCUT/Đề bàiCho A là lưới ô vuông gồm m dòng và n cột. Các dòng của lưới được đánh số từ 1 đến m, từ trên xuống dưới. Các cột của lưới được đánh số từ 1 đến n , từ trái sang phải. Ô nằm trên giao của dòng i và cột j của lưới, được gọi là ô (i, j), chứa số nguyên không âm a_i,j có giá trị không vượt quá 10 ^ 6.Các lưới ô vuông như vậy luôn là đối tượng cho nhiều nghiên cứu thú vị. Vừa qua, trong giờ học ôn luyện cho kỳ thi học sinh giỏi Tin học, Hùng được cô giáo giao cho giải quyết bài toán trả lời truy vấn sau đây đối với bảng đã cho:Cho một hình chữ nhật con có ô trái trên là ô (x, y) và ô phải dưới là ô (u, v), cần đưa ra chênh lệch nhỏ nhất trong số các chênh lệch giữa hai tổng các số trong hai hình chữ nhật thu được bằng việc cắt ngang hoặc cắt dọc hình chữ nhật đã cho dọc theo đường kẻ của lưới. Giả thiết (x, y) và (u, v) là hai ô khác nhau trên lưới.Bạn hãy giúp Hùng giải quyết bài toán đặt ra.Yêu cầu: Cho lưới A và k bộ x_q, y_q, u_q, v_q (q = 1, 2, …, k) tương ứng với k truy vấn, hãy đưa ra các câu trả lời cho k truy vấn.Dữ liệu vào:   Dòng đầu tiên chứa ba số nguyên m, n, k (k ≤ m × n);  m dòng tiếp theo, dòng thứ i chứa n số nguyên không âm a_i_1, a_i_2, …, a_i_n;  Dòng thứ q trong số k dòng tiếp theo chứa 4 số nguyên x_q, y_q, u_q, v_q (q = 1, 2, …, k).Dữ liệu ra:  Ghi ra file văn bản MINCUT.OUT gồm k dòng, mỗi dòng chứa một số là câu trả lời cho một truy vấn theo thứ tự xuất hiện trong file dữ liệu vào.Ràng buộc:  Có 30% số test ứng với 30% số điểm của bài có m, n ≤ 10.  Có 30% số test khác ứng với 30% số điểm của bài có m, n ≤ 100.  Có 40% số test  ứng với 40% số điểm còn lại của bài có m, n ≤ 1000.SolutionHereCode mẫuHere",
              url: "/spoj/spoj-mincut-voi-2015-day-2-cat-hinh"
            }
            ,

            {
              title: "[SPOJ] KQUERY2 - K-query II",
              author: "CVHvn",
              category: ["spoj"],
              tag: ["SPOJ", "data-structure", "sqrt-decomposition"],
              content: "Link đề bài: http://vnoi.info/problems/show/KQUERY2/Đề bài:Cho một dãy n phần tử a1, a2, …, an và một số các truy vấn-k. Ngoài ra còn có một số thao tác cập nhật.Một thao tác cập nhật là một cặp (i, v) nghĩa là ai cần được gán giá trị v.Một truy vấn-k là một bộ ba (i, j, k) (1 ≤ i ≤ j ≤ n).Với mỗi truy vấn-k (i, j, k), bạn phải trả về số phần tử lớn hơn k nằm trong dãy con ai, ai+1, …, aj.Input:Dòng 1: n (1 ≤ n ≤ 30000).Dòng 2: n số a1, a2, …, an (1 ≤ ai ≤ 10^4).Dòng 3: q (1 ≤ q ≤ 200000), số truy vấn-k.q dòng tiếp theo, số đầu tiên trong mỗi dòng là 0 hoặc 1. Số 0 theo sau bởi 2 số i và v (1 ≤ i ≤ n, 1 ≤ v ≤ 10^4) cho biết một thao tác cập nhật. Số 1 theo sau bởi 3 số nguyên i, j, k (1 ≤ i ≤ j ≤ n, 1 ≤ k ≤ 10^4) cho biết một truy vấn-k.Output:Với mỗi truy vấn-k (i, j, k), in ra số phần tử lớn hơn k trong dãy con ai, ai+1, …, aj trên một dòng.Solution: http://viahold.com/4NeCode: http://viahold.com/4C9",
              url: "/spoj/spoj-kquery2-k-query-ii"
            }
            ,

            {
              title: "[C++ Cơ bản] Phần 4: Cú pháp C++ cơ bản",
              author: "Admin Tổng Quản",
              category: ["article"],
              tag: ["cpp-cơ-bản", "programming"],
              content: "Phần trước: [C++ Cơ bản] Phần 3: Thiết lập môi trường làm việc - Giới thiệu về Code::BlocksMột chương trình C++ cơ bản có cấu trúc giống như một tập hợp các đối tượng lập trình, giao tiếp với nhau bằng việc kích hoạt các phương thức giữa chúng. Cụ thể hơn thì:  Đối tượng (object): Một đối tượng sẽ có các tính chất và phương thức. Ví dụ: một con chó thì có tính chất như màu lông, tuổi, tên, giống chó; có các phương thức như sủa, ăn, tiêu hóa thức ăn.  Lớp (class): Class là định nghĩa của đối tượng. Một class sẽ được định nghĩa danh sách những tính chất và phương thức mà các đối tượng trong class đó sở hữu. Ví dụ: Cả loài chó nói chung sẽ có những tính chất như trên, trong khi con Milu nhà bạn sẽ có giá trị đặc biệt cho từng tính chất.  Phương thức (method): Phương thức là những hành vi được định nghĩa của một đối tượng. Phương thức là nơi mà các biến được thay đổi, đối tượng giao tiếp với nhau, vân vân… Ví dụ: Khi một con chó sủa, biến “Cơ vòm họng” của nó sẽ co bóp để tạo âm thanh, đối tượng “Âm thanh” sẽ được tạo ra, và hàng xóm sẽ được kích hoạt phương thức “Cau có”.  Biến cá thể (instance variable): Mỗi đội tượng sẽ có một số biến cá thể, định nghĩa các giá trị tính chất của nó.Cấu trúc chương trình C++Hãy cùng nhìn lại chương trình HelloWorld lúc trước của chúng ta và cùng nhau tìm hiểu từng phần một:#include &lt;iostream&gt;using namespace std;int main(){    cout &lt;&lt; \"Hello world!\" &lt;&lt; endl;    return 0;}  #include &lt;iostream&gt;: Như đã nói ở trước, C++ có một hệ thống thư viện chứa các hàm và chương trình con quan trọng cho việc lập trình. Ở đây ta sử dụng cú pháp include để khai báo sử dụng thư viện iostream – một trong các thư viện nhập/xuất của C++.  using namespace std;: Dòng lệnh này khai báo sử dụng không gian tên std. Chúng ta tạm thời chưa cần quan tâm ở đây.  int main(): Hàm main() là nơi chương trình C++ được triển khai. Hàm này trả lại một giá trị kiểu số nguyên (int) thông báo chương trình có được kết thúc một cách hợp lệ hay không.  Ngoặc nhọn là đánh dấu phần nội dung của hàm main().  cout &lt;&lt; \"Hello world!\" &lt;&lt; endl;: Dòng lệnh này yêu cầu chương trình in ra xâu ký tự Hello world! cùng với việc xuống dòng.  return 0;: Báo hiệu kết thúc hàm main(), trả về giá trị 0 (chương trình kết thúc hợp lệ, không có gì bất thường).Dấu chấm phẩy và khối lệnh ngoặc nhọnTrong C++, tất cả các dòng lệnh đều phải kết thúc bằng dấu chấm phẩy. Nó đánh dấu kết thúc cho các hành động xử lý logic của chương trình.Như ở trong ví dụ trên: các dòng using namespace std;, cout &lt;&lt; “Hello world!” &lt;&lt; endl; và retun 0; đều phải kết thúc bằng dấu chấm phẩy.Một khối lệnh là một nhóm lệnh được đóng trong hai ngoặc nhọn. Các lệnh trong khối lệnh sẽ được triển khai từ trên xuống dưới, từ trái qua phải. Ví dụ cho một khối lệnh là hàm main() ở trên:{    cout &lt;&lt; \"Hello world!\" &lt;&lt; endl;    return 0;}C++ không công nhận việc xuống dòng là kết thúc của một câu lệnh. Do đó ta có thể đặt dấu chấm phẩy ở bất kì đâu, hoặc viết nhiều câu lệnh trên cùng một dòng, mà không sinh ra lỗi. Đoạn code:{    cout &lt;&lt; \"Hello world!\" &lt;&lt; endl    ;    return 0;}và{    cout &lt;&lt; \"Hello world!\" &lt;&lt; endl; return 0;}đều là các đoạn code hợp lệ.Cách đặt tên trong C++Các đối tượng trong C++ như biến, chương trình con, vân vân… đều cần có tên. C++ có một số quy tắc đặt tên như sau:  Tên phải được bắt đầu bằng chữ cái tiếng anh (từ a tới z hoặc từ A tới Z), hoặc một dấu gạch dưới “_”, có thể được nối tiếp bởi các chữ cái, dấu gạch dưới hoặc các số.  Tên không được chứa các dấu câu, kí tự đặc biệt như @, %, $.  Tên có sự phân biệt chữ hoa - chữ thường. Ví dụ, number và Number là hai tên gọi khác nhau trong một chương trình C++.  Tên không được trùng với các từ khóa đã được C++ sử dụng. Danh sách các từ khóa có thể được tìm thấy ở http://en.cppreference.com/w/cpp/keyword.Chú ý: Đừng lo ngại về số lượng từ khóa của C++! Mặc dù trông chúng có thể nhiều, nhưng các IDE hiện đại đều được tích hợp chức năng gợi ý từ. Bạn sẽ rất dễ dàng nhận ra được tên biến bạn định đặt có trùng với từ khóa nào không. Các bộ dịch cũng sẽ tự động báo lỗi khi dịch phải chương trình đặt tên biến có từ khóa.Khoảng trắngCác kí hiệu không nhìn thấy được như dấu cách, kí tự xuống dòng, tab và các đoạn comment được gọi chung là khoảng trắng. Các khoảng trắng có tác dụng phân biệt các đối tượng trong một câu lệnh với nhau. Ví dụ khi khai báo hàm int main(), khoảng trắng (dấu cách) là cần thiết. Trong các trường hợp khác, ví dụ như câu lệnhx = y + z;Bản thân các dấu kí hiệu toán đã có khả năng phân biệt đối tượng, và các khoảng trắng chỉ được cho vào để đoạn code dễ đọc hơn.CommentTa cũng có thể cho thêm các đoạn bình luận để giải thích cho code. Ví dụ như đoạn code sau:#include &lt;iostream&gt;using namespace std;/* Hàm main() là nơi chương trình được thực hiện */int main() {    cout &lt;&lt; \"Hello world!\" &lt;&lt; endl; // In ra dòng chữ Hello World!    return 0;}Có hai cách để comment trong code C++:  Sử dụng /* */ để dánh dấu khoảng comment.  Sử dụng //. Đoạn comment sẽ bắt đầu từ kí hiệu này tới hết dòng.Trình dịch C++ sẽ bỏ qua tất cả các đoạn code được comment, vì vậy chúng không sinh ra lỗi.Comment còn có một tác dụng khác, đó là tạm thời tắt một đoạn code đi nhằm mục đích sửa chữa - debug.CodeBlocks hỗ trợ tổ hợp phím Ctrl + Shift + C để bỏ dòng code hiện tại, hoặc các dòng code được bôi đen, vào trong comment, cùng với Ctrl + Shift + X để bỏ dòng code ra khỏi comment.Phần sau: [C++ Cơ bản] Phần 5: Biến và kiểu dữ liệu",
              url: "/article/c-co-ban-phan-4-cu-phap-c-co-ban"
            }
            ,

            {
              title: "[SPOJ] MATSUM - Matrix Summation",
              author: "houtaru",
              category: ["spoj"],
              tag: ["spoj", "bit", "data-structure"],
              content: "Link đề bài: http://www.vnoi.info/problems/show/MATSUM/Đề bài:Cho ma trận N x N (N &lt;= 1028).Có nhiều lệnh :  “SET x y num” - gán ô (x, y) = num  “SUM x1 y1 x2 y2” - tính tổng hình chữ nhật góc trái trên (x1, y1), góc phải dưới (x2, y2)  “END” - kết thúc testcaseInput:  Dòng đầu, t là số testcase  Mỗi testcase, dòng đầu là số N, các dòng tiếp theo là các lệnhOutput:Trong mỗi testcase, mỗi dòng là kết quả của lệnh “SUM”. ỗi testcase cách nhau 1 dòng.Solution: http://dataurbia.com/1ADjCode: http://dataurbia.com/1ABu",
              url: "/spoj/spoj-matsum-matrix-summation"
            }
            ,

            {
              title: "[SPOJ] MEDIAN - Phần tử trung vị",
              author: "Accepted Problems",
              category: ["spoj"],
              tag: ["spoj", "implementation"],
              content: "Link đề gốc:http://vnoi.info/problems/show/MEDIAN/Đề bài:Cho một dãy số a1, a2, …, an được sinh ngẫu nhiên như sau:  a1=seed  ai=(ai-1*mul+add)%65536Với mul, add, seed là các số cho trước.Cho một số k ≤ n. Dãy đã cho có n-k+1 dãy con độ dài k. Hãy tính tổng tất cả các phần tử trung vị (phần tử nhỏ thứ (k+1)\\/2) của n-k+1 dãy con này).Dữ liệuDòng đầu tiên chứa số test (không quá 30). Mỗi dòng tiếp theo chứa 5 số nguyên seed, mul, add, N, K. (0 ≤ seed, mul, add ≤ 65535, 1 ≤ N ≤ 250000, 1 ≤ K ≤ 5000, K ≤ N)Kết quảVới mỗi test in ra số hiệu test (theo mẫu) cùng với tổng các trung vị tìm được.Ví dụ:Dữ liệu53 1 1 10 310 0 13 5 24123 2341 1231 7 347 5621 1 125000 170032321 46543 32552 17 17Kết quảCase #1: 60Case #2: 49Case #3: 102186Case #4: 4040137193Case #5: 25569Giải thíchVới test 1, dãy sinh ra là 3, 4, 5, 6, 7, 8, 9, 10, 11, and 12.Các dãy con là (3, 4, 5), ..., (10, 11, 12).Các trung vị là 4, 5, ..., 11.Chú ý:Muốn hiểu được code bài này trước hết các bạn cần phải nắm rõ được về set. Những kiến thức cơ bản về set các bạn hãy đọc trước trên VNOI : http://vnoi.info/library/56/4958/Solution:Tham khảo tại: http://dataurbia.com/18WuCode:Tham khảo tại: http://dataurbia.com/18YJCode đã được nộp và AC trên SPOJ, sử dụng bộ dịch của C++11",
              url: "/spoj/spoj-median-phan-tu-trung-vi"
            }
            ,

            {
              title: "[SPOJ] BGMINE - Xây đập giữ vàng",
              author: "houtaru",
              category: ["spoj"],
              tag: ["spoj", "dp", "bit", "data-structute"],
              content: "Link bài gốc : http://vnoi.info/problems/show/BGMINE/Đề bài :Trên một con đường biểu diễn như trục số thực có n mỏ vàng đánh số từ 1 tới n. Mỏ thứ  i nằm ở tọa độ xi, có tổng trữ lượng vàng là gi, trong mỏ còn có lượng đá đủ để xây dựng đoạn kè có độ dài ri. Trong mùa mưa lũ, việc phòng chống ngập cho các mỏ trở nên cấp thiết và rất khó khăn trong việc vận chuyển vật liệu xây kè. Vì vậy, Chính phủ muốn  dùng đá ở một dãy mỏ liên tiếp để xây dựng một đoạn kè liên tục bảo vệ tất cả các mỏ đó. Ta có thể coi cửa các mỏ vàng rất nhỏ, nên dù chỉ nằm ở đầu đoạn kè thì mỏ vẫn được an toàn.Yêu cầu:Hãy giúp chính phủ xác định đoạn kè có thể xây dựng với tổng trữ lượng vàng trong các mỏ được bảo vệ là lớn nhất.Input :Dòng đầu chứa số nguyên dương  n ≤ 105  là số lượng mỏ vàng.n dòng tiếp theo, dòng thứ i chứa ba số nguyên xi, gi, ri cách nhau bởi dấu cách (−109  ≤ x1  &lt; x2  &lt; ⋯ &lt; xn  ≤ 109; 0 ≤ gi, ri   ≤ 109)Output :Một số nguyên duy nhất là tổng trữ lượng vàng lớn nhất trong các mỏ được bảo vệ theo phương án tìm được.Solution : http://dataurbia.com/11KyCode : http://dataurbia.com/17qS",
              url: "/spoj/spoj-bgmine-xay-dap-giu-vang"
            }
            ,

            {
              title: "[SPOJ] COLOREC - VOI 2011 Hình chữ nhật bốn màu",
              author: "La Hoàng Phong",
              category: ["spoj"],
              tag: ["implementation"],
              content: "Link đề bài gốc : http://vnoi.info/problems/show/COLOREC/Đề bài :Trên mặt phẳng tọa độ Đề các vuông góc Oxy cho n điểm phân biệt Ai(xi, yi) i = 1, 2, 3, …, n.   Mỗi điểm Ai được tô bởi màu Ci thuộc {1, 2, 3, 4}. Ta gọi hình chữ nhật bốn màu là hình chữ nhật thỏa mãn hai điều kiện sau:  Bốn đỉnh của hình chử nhật là bốn điểm trong n điểm đã cho và được tô bởi bốn màu khác nhau.  Các cạnh của hình chử nhật song song với một trong hai trục tọa độ.Yêu cầu:Cho biết tọa độ và màu của n điểm, hãy đếm số lượng hình chữ nhật bốn màu.Dữ liệu:  Dòng đầu tiên chứa số nguyên dương n (4 &lt;= n &lt;= 10^5) là số lượng điểm trên mặt phẳng.  Dòng thứ i trong n dòng tiếp theo chứa ba số nguyên xi, yi, ci (|xi|, |yi| &lt;= 200)  là thông tin về tọa độ và màu của điểm thứ i (i = 1, 2, 3, .., n).  Các số trên cùng một dòng được ghi cách nhau ít nhất một dấu cách.Kết quả:Ghi ra trên một dòng số lượng hình chữ nhật đếm được.Ví dụ:input 70 0 10 1 42 1 22 -1 30 -1 1-1 -1 4-1 1 1output2Ràng buộc:50% số test ứng với 50% số điểm của bài có 4 &lt;= n &lt;= 100Solution :Tham khảo tại : http://dataurbia.com/16nVCode :Tham khảo tại : http://dataurbia.com/16oZ",
              url: "/spoj/spoj-colorec-voi-2011-hinh-chu-nhat-bon-mau"
            }
            ,

            {
              title: "[SPOJ] KBUILD - Sửa cầu",
              author: "La Hoàng PHong",
              category: ["spoj"],
              tag: ["data-structure"],
              content: "Link đề bài gốc : http://vnoi.info/problems/show/KBUILD/Đề bài :Vì lo lắng Pirate sẽ buồn chán khi một thân một mình ở đảo hoang, bạn gái Pirate từ trong đất liền dự định sang chơi với anh ấy.Pirate đang sinh sống trên một quần đảo gồm N đảo. Vì các đảo khá gần nhau nên chẳng cần thuyền bè gì, Pirate chỉ cần đốn đại cây dừa nào đó và bắc ngang là có thể đi được từ đảo này sang đảo khác. Vì không muốn hủy hoại môi trường nên anh ấy chỉ đốn N - 1 cây dừa làm cầu, vừa đủ để từ một đảo bất kì đi đến được hết mọi đảo còn lại.Nhưng mà “Môi son, má đào, chân guốc cao gót làm sao em qua cầu dừa???”. Lo lắng sợ bạn gái sẽ rơi xuống biển và bị cá đuối nẫng mất, Pirate hộc tốc đi sửa chữa các cây cầu dừa. Anh đưa ra một lịch trình như sau: vào mỗi ngày sẽ đi kiểm tra mọi cây cầu trên đường đi từ đảo a đến đảo b.Tuy nhiên, lịch trình đó khá là phi khoa học. Thực hiện, xong rồi, Pirate mới ngớ ra là không biết mình có bỏ sót cây cầu nào không?Input  Dòng thứ nhất: số nguyên N - số hòn đảo.  N - 1 dòng tiếp theo: mỗi dòng gồm hai số nguyên a và b - có một cây cầu dừa nối đảo a và đảo b.  Dòng thứ N + 1: số nguyên M - số ngày kiểm tra.  M dòng tiếp theo: mỗi dòng gồm hai số nguyên a và b - ngày hôm đó, Pirate sẽ kiểm tra các cây cầu trên đoạn đường từ đảo a đến đảo b.Output  Một số nguyên duy nhất thể hiện số cây cầu chưa được kiểm tra.Giới hạn  1 ≤ N, M ≤ 200000  60% số test có 1 ≤ N, M ≤ 5000  80% số test có 1 ≤ N, M ≤ 50000ExampleInput:61 22 32 44 54 623 65 6Output:1Giải thích: Ngày thứ nhất, Pirate kiểm tra các cây cầu (2, 3), (2, 4) và (4, 6). Ngày thứ hai, anh kiểm tra các cây cầu (5, 4) và (4, 6). Cây cầu duy nhất chưa được kiểm tra là (1, 2).Solution :Tham khảo tại : http://dataurbia.com/16bDCode :Tham khảo tại : http://dataurbia.com/16bW",
              url: "/spoj/spoj-kbuild-sua-cau"
            }
            ,

            {
              title: "[SPOJ] DHEXP - Biểu thức",
              author: "rknguyen",
              category: ["spoj"],
              tag: ["spoj", "greedy"],
              content: "Link bài gốc : http://vnoi.info/problems/show/DHEXP/Đề bài :Một dãy gồm n số nguyên không âm a_1, _a_2,…, an_ được viết thành một hàng ngang, giữa hai số liên tiếp có một khoảng trắng, như vậy có tất cả (n­-1) khoảng trắng. Người ta muốn đặt _k dấu cộng và (n-1-k) dấu trừ vào (n­-1) khoảng trắng đó để nhận được một biểu thức có giá trị lớn nhất.Ví dụ, với dãy gồm 5 số nguyên 28, 9, 5, 1, 69 và k = 2 thì cách đặt 28+9-5-1+69 là biểu thức có giá trị lớn nhất.Yêu cầuCho dãy gồm n_số nguyên không âm _a_1, _a_2,…, an_ và số nguyên dương k, hãy tìm cách đặt k dấu cộng và (n-1-k) dấu trừ vào (n­-1) khoảng trắng để nhận được một biểu thức có giá trị lớn nhất.Input  Dòng đầu chứa hai số nguyên dương n, k (k &lt; n)  Dòng thứ hai chứa n số nguyên không âm a_1, a_2,…, aN _(ai _≤ 10^6)OutputMột số nguyên là giá trị của biểu thức đạt được.Ví dụInput5 228 9 5 1 69Output100SolutionTham Khảo Tại : http://dataurbia.com/15oDCodeTham Khảo Tại : http://dataurbia.com/15m3",
              url: "/spoj/spoj-dhexp-bieu-thuc"
            }
            ,

            {
              title: "[SPOJ] C11BC2 - Robin",
              author: "rknguyen",
              category: ["spoj"],
              tag: ["spoj", "dfs", "graph", "connected-component"],
              content: "Link bài gốc : http://vnoi.info/problems/show/C11BC2/Đề bài :Một ngày đẹp trời nọ, trên vương quốc của các Coders 2011, bỗng xuất hiện 1 lão phù thủy độc ác, lão phù thủy sirDat_LS đã có âm mưu thôn tính đất nước  của đức vua vodanh9x. Lão phù thủy này rất yêu con gái của đức vua là Rose và đã bắt Rose về nơi ở của lão ta.Đức vua vodanh9x liền tìm hiệp sĩ Robin và sẽ hứa gả con gái cho Robin nếu chàng cứu được công chúa Rose trở về. Lão phù thủy sirDat_LS độc ác với khuôn mặt rất ghê tởm khiến công chúa mỗi khi nhìn thấy hắn thì công chúa lại ngất đi.Và rồi, chàng Robin của chúng ta đã tìm được đến nơi ở của lão phù thủy. Nơi ở của lão là 1 mê cung có N phòng, và N phòng này liên thông với nhau và có đúng N-1 đường đi (coi mỗi đường đi là 1 cạnh).Nhưng khó khăn thay, lão phù thủy đã đánh số mỗi đường đi là 1 hoặc 2. Nếu chàng Robin muốn đến cứu công chúa, thì từ nơi xuất phát đến nơi có công chúa phải có ít nhất một đường đi được đánh số 2, nếu không chàng Robin sẽ chết.Yêu cầuCho m truy vấn (m &lt;= 10^5) mỗi truy vấn có dạng (x,y), trong đó x là nơi xuất phát của Robin và y là nơi nhốt công chúa. Xác định đường đi ngắn nhất từ x đến y có cạnh co trọng số 2 hay không?Input  Dòng đầu là số nguyên N (N &lt;= 10^4) - số đỉnh của đồ thị và M  – số truy vấn.  Từ dòng 2 đến dòng N: dòng thứ i chứa 2 số nguyên dươngx (x &lt; i) và k (k &lt;= 2) nghĩa là có cạnh nối giữa i và x và được đánh số là k.  M dòng sau: mỗi dòng chứa 2 số x và y (Biểu thị cho truy vấn (x,y)).OutputVới mỗi truy vấn, xuất ra “YES” nếu tồn tại đường đi có ít nhất 1 cạnh có trọng số 2, ngược lại xuất ra “NO”.Ví dụInput6 71 11 23 11 25 21 35 12 12 11 22 41 2OutputYESYESNONONOYESNOSolutionTham Khảo Tại : http://dataurbia.com/14qkCodeTham Khảo Tại : http://dataurbia.com/14r5",
              url: "/spoj/spoj-c11bc2-robin"
            }
            ,

            {
              title: "[C++ Cơ bản] Phần 3: Thiết lập môi trường làm việc  - Giới thiệu về Code::Blocks",
              author: "Admin Tổng Quản",
              category: ["article"],
              tag: ["cpp-cơ-bản", "programming"],
              content: "Phần trước: [C++ Cơ bản] Phần 2: Giới thiệu về C++Như đã nói ở trong phần 1, bạn thậm chí chỉ cần tới một trình soạn thảo văn bản (text editor) để viết file mã nguồn C++. Tuy nhiên để tiện lợi, chúng ta sẽ sử dụng IDE trong series bài viết này. IDE được chọn là Code::Blocks IDE (ở đây gọi tắt là CodeBlocks), viết bởi The Code::Blocks Team. Lý do mình chọn IDE này cho series bài viết đơn giản là vì sự đơn giản mà mạnh mẽ của nó, và vì đây là cũng là IDE đầu tiên mình sử dụng để học C++ :))Cài đặt CodeBlocksMục này hướng dẫn cài đặt CodeBlocks trên HĐH Windows, đối với các bạn sử dụng hệ điều hành nhân Linux có thể áp dụng gần như tương tự, hoặc sử dụng Terminal để cài đặt CodeBlocks.Để cài đặt CodeBlocks, bạn cần phải tìm tới trang chủ của dự án CodeBlock và lựa chọn mục Download. Tại đây bạn có 3 lựa chọn để download CodeBlocks về máy tính của mình. Để đơn giản nhất, ta chọn Download the Binary Release (Tải về bản cài đặt phát hành chính thức).Link download ở trong các danh sách liệt kê ở dưới. Tùy vào hệ điều hành của bạn, hãy lựa chọn phiên bản CodeBlocks phù hợp để download. Chú ý đối với người dùng Windows là phải download phiên bản có mingw-setup để download CodeBlocks có kèm theo bộ dịch GNU C++.Tiếp theo chúng ta chạy file cài đặt CodeBlocks. Đối với nội dung của series này thì chỉ cần để lại các cài đặt như mặc định là đủ.Khi cài đặt hoàn tất và bạn khởi động CodeBlocks lần đầu, phần mềm sẽ hỏi bạn sử dụng bộ dịch gì cho chương trình. Hãy để mặc định (GNU CCC Complier) và click Next.Giao diện của IDE sẽ hiện thị - quá trình cài đặt hoàn tất:Tạo chương trình C++ mới với CodeBlockĐể tạo chương trình C++ mới, bạn cần phải tạo project (dự án) mới trong CodeBlocks.Bạn có thể tạo project mới bằng đường dẫn hiển thị ở màn hình khởi động (Create a new project), hoặc bằng việc lựa chọn File/New/Project… Trên thanh công cụ.Màn hình tạo project mới hiển thị, bạn phải lựa chọn loại chương trình bạn muốn viết ở đây. Trong các ví dụ của series bài viết này, chúng ta sẽ sử dụng chương trình màn hình console (Console application). Ta click chọn vào Console application và nhấn Go, hoặc click đúp chuột vào Console application.Ở mục ngôn ngữ, ta chọn C++ và ấn Next.Ở mục tiếp theo, ta phải lựa chọn tiêu đề của dự án và folder nơi chứa thư mục của dự án. Tất cả các file của dự án sẽ nằm trong một folder con của folder này, được đặt tên là tên của dự án. Lấy ví dụ hình dưới, mình muốn tạo ra một dự án có tên là HelloWorld, được đặt ở trong thư mục D:\\Class:Ta nhấn Next để tiếp tục. Ở mục tiếp theo chứa các cài đặt về trình dịch và môi trường làm việc của dự án, ta tạm thời không phải quan tâm ở đây, click Finish.Dự án đã được tạo thành xong. Ở phía bên trái của màn hình là bố cục của dự án. Khi khởi điểm, mục này chỉ bao gồm 1 file duy nhất là file main.cpp, file mã nguồn C++ của dự án, nằm trong mục Sources:Ta click đúp chuột để mở file này. Bên trong là một chương trình C++ đơn giản:Hãy thử click vào nút được khoanh đỏ để build và chạy chương trình này:Xin chúc mừng, bạn vừa chạy thành công một chương trình C++ đơn giản :)) Hello World được coi như là bài tập khởi đầu với mọi ngôn ngữ lập trình, khi bạn phải viết một chương trình in ra dòng chữ đầu tiên. Mọi kiến thức về một ngôn ngữ sẽ từ đó mà nảy nở :))Dịch và chạy chương trình C++Bên cạnh nút build và chạy chương trình như trên, còn có hai nút quan trọng khác là chỉ build và chỉ chạy chương trình:  Nút đầu tiên từ trái qua sẽ build chương trình, nhưng không chạy nó. Nếu chương trình không có thay đổi, sẽ không có gì xảy ra.  Nút thứ hai sẽ chạy chương trình, theo như lần cuối cùng nó được build. Có nghĩa là mọi thay đổi từ lần build cuối sẽ không có ảnh hưởng gì tới chương trình chạy.  Nút thứ ba, chúng ta vừa sửa dụng, là nút build và chạy chương trình vừa được build xong.Tại sao ta phải biết 3 nút này? Bạn sẽ nhanh chóng nhận ra quá trình build khá là lâu, mất vài giây. Đôi khi bạn chỉ muốn kiểm tra chương trình mà cũng phải mất thời gian chờ đợi dự án build xong, thật rách việc. Vậy nên ta chỉ cần chạy chương trình không bằng nút chạy, không mất thời gian chờ đợi nữa.Để nhanh gọn hơn, 3 nút này có 3 phím tắt trên bàn phím, lần lượt là Ctrl + F9, Ctrl + F10 và F9.Tới đây là kết thúc phần chuẩn bị cho series bài viết. Ở bài viết tiếp theo, chúng ta sẽ tới nội dung chính của series – ngôn ngữ C++!Phần sau: [C++ Cơ bản] Phần 4: Cú pháp C++ cơ bản",
              url: "/article/c-co-ban-phan-3-thiet-lap-moi-truong-lam-viec-gioi-thieu-ve-codeblocks"
            }
            ,

            {
              title: "[SPOJ] V8ORG - Tổ chức đối lập",
              author: "rknguyen",
              category: ["spoj"],
              tag: ["spoj", "dfs", "graph"],
              content: "Link bài gốc : http://vnoi.info/problems/show/V8ORG/Đề bài :Ở một đất nước nọ, lực lượng an ninh vừa phát hiện một tổ chức đối lập. Tổ chức đối lập này được tổ chức chặt chẽ, bao gồm mạng lưới thành viên và chỉ huy ở các cấp bậc khác nhau. Các thành viên của tổ chức được đánh số từ 1 đến N. Tổ chức có một chỉ huy tối cao, luôn được đánh số 1. Mỗi thành viên chỉ biết viên chỉ huy trực tiếp của mình (có duy nhất một viên chỉ huy trực tiếp) chứ không biết các chỉ huy cấp cao hơn.Khi tiến hành việc bắt giữ các thành viên, tổ chức sẽ bị phân rã thành các nhóm nhỏ không liên kết với nhau, ví dụ sau khi bắt giữ thành viên số 2 (hình 1), tổ chức bị phân rã thành 4 nhóm. Lực lượng an ninh khẳng định, một nhóm chứa ít hơn K thành viên sẽ không còn là mối đe dọa cho đất nước. Để không làm giảm hình ảnh của đất nước trước dư luận quốc tế, các nhà lãnh đạo an ninh muốn bắt giữ một số lượng ít nhất phần tử đối lập, sao cho các nhóm bị phân rã đều không còn gây nguy hại cho đất nước.Cho biết cấu trúc của tổ chức đối lập, việc chương trình giúp các nhà lãnh đạo an ninh xác định số lượng phần tử đối lập ít nhất cần bắt giữ.Input  Dòng đầu tiên chứa số nguyên K (1 ≤ K ≤ 10000).  Dòng thứ hai chứa số nguyên N (1 ≤ N ≤ 10000).  Dòng thứ ba chứa N-1 số nguyên cách nhau bởi khoảng trắng, chỉ số của chỉ huy trực tiếp của mỗi phần tử của tổ chức (trừ chỉ huy tối cao): số đầu tiên cho biết chỉ huy của phần tử thứ hai, số thứ hai cho biết chỉ huy của phần tử thứ ba,…OutputIn ra một số nguyên duy nhất là số phần tử đối lập ít nhất cần bắt giữ.Ví dụInput3141 1 2 2 3 2 3 6 6 6 7 4 7Output4Mô tảCó thể bắt giữ 4 phần tử 6, 2, 7 và 8.SolutionTham Khảo Tại : http://dataurbia.com/12iACodeTham Khảo Tại : http://dataurbia.com/12YN",
              url: "/spoj/spoj-v8org-to-chuc-doi-lap"
            }
            ,

            {
              title: "[SPOJ] DQUERY - D-query",
              author: "rknguyen",
              category: ["spoj"],
              tag: ["spoj", "mo"],
              content: "Link bài gốc : http://vnoi.info/problems/show/DQUERY/Đề bài :Cho một dãy số n phần tử a1, a2, …, an và một số các truy vấn-d. Một truy vấn-d là một cặp (i, j) (1 ≤ i ≤ j ≤ n). Với mỗi truy vấn-d (i, j), bạn cần trả về số phần tử phân biệt nằm trong dãy con ai, ai+1, …, aj.Input  Dòng 1: n (1 ≤ n ≤ 30000).  Dòng 2: n số a1, a2, …, an (1 ≤ ai ≤ 106).  Dòng 3: q (1 ≤ q ≤ 200000), số lượng truy vấn-d.  Trong q dòng sau, mỗi dòng chứa 2 số i, j biểu thị một truy vấn-d (1 ≤ i ≤ j ≤ n).OutputVới mỗi truy vấn-d (i, j), in ra số phần tử phân biệt thuộc dãy con ai, ai+1, …, aj trên một dòng.Ví dụInput51 1 2 1 331 52 43 5Output323 SolutionTham Khảo Tại : http://dataurbia.com/12ZOCodeTham Khảo Tại : http://dataurbia.com/12Yx",
              url: "/spoj/spoj-dquery-d-query"
            }
            ,

            {
              title: "[SPOJ] NKCITY - Xây dựng thành phố",
              author: "rknguyen",
              category: ["spoj"],
              tag: ["spoj", "kruskal"],
              content: "Link bài gốc : http://vnoi.info/problems/show/NKCITY/Đề bài :Nước Anpha đang lập kế hoạch xây dựng một thành phố mới và hiện đại. Theo kế hoạch, thành phố sẽ có N vị trí quan trọng, được gọi là N trọng điểm và các trọng điểm này được đánh số từ 1 tới N. Bộ giao thông đã lập ra một danh sách M tuyến đường hai chiều có thể xây dựng được giữa hai trọng điểm nào đó. Mỗi tuyến đường có một thời gian hoàn thành khác nhau.Các tuyến đường phải được xây dựng sao cho N trọng điểm liên thông với nhau. Nói cách khác, giữa hai trọng điểm bất kỳ cần phải di chuyển được đến nhau qua một số tuyến đường. Bộ giao thông sẽ chọn ra một số tuyến đường từ trong danh sách ban đầu để đưa vào xây dựng sao cho điều kiện này được thỏa mãn.Do nhận được đầu tư rất lớn từ chính phủ, bộ giao thông sẽ thuê hẳn một đội thi công riêng cho mỗi tuyến đường cần xây dựng. Do đó, thời gian để hoàn thành toàn bộ các tuyến đường cần xây dựng sẽ bằng thời gian lâu nhất hoàn thành một tuyến đường nào đó.Yêu cầuGiúp bộ giao thông tính thời gian hoàn thành các tuyến đường sớm nhất thỏa mãn yêu cầu đã nêu.Input      Dòng đầu tiên chứa số N và M (1 ≤ N ≤ 1000; 1 ≤ M ≤ 10000).        M tiếp theo, mỗi dòng chứa ba số nguyên u, v và t cho biết có thể xây dựng tuyến đường nối giữa trọng điểm u và trọng điểm v trong thời gian t. Không có hai tuyến đường nào nối cùng một cặp trọng điểm.  OutputMột số nguyên duy nhất là thời gian sớm nhất hoàn thành các tuyến đường thỏa mãn yêu cầu đã nêu.Ví dụInput5 71 2 21 5 12 5 11 4 31 3 25 3 23 4 4Output3SolutionTham Khảo Tại : http://dataurbia.com/1245CodeTham Khảo Tại : http://dataurbia.com/120Q",
              url: "/spoj/spoj-nkcity-xay-dung-thanh-pho"
            }
            ,

            {
              title: "[SPOJ] QMAX2 - Giá trị lớn nhất ver2",
              author: "La Hoàng Phong",
              category: ["spoj"],
              tag: ["spoj", "data-structure"],
              content: "Link bài gốc : http://vnoi.info/problems/show/QMAX2/Đề bài :Giống bài QMAX (http://vnoi.info/problems/show/QMAX/) .Input      n: số phần tử của dãy (n &lt;= 50000).- m: số lượng biến đổi và câu hỏi (m &lt;= 100000).    +) biến đổi có dạng: 0 x y value    +) câu hỏi có dạng : 1 x y.  OutputGhi ra trả lời cho lần lượt từng câu hỏi.ExampleInput:6 30 1 3 30 4 6 41 1 6Output:4Solution :Tham Khảo Tại : http://dataurbia.com/10AYCode :Tham Khảo Tại : http://dataurbia.com/104N",
              url: "/spoj/spoj-qmax2-gia-tri-lon-nhat-ver2"
            }
            ,

            {
              title: "[SPOJ] QMAX - Giá trị lớn nhất",
              author: "La Hoàng Phong",
              category: ["spoj"],
              tag: ["spoj", "data-structure"],
              content: "Link bài gốc : http://vnoi.info/problems/show/QMAX/Đề bài :Cho một dãy gồm n phần tử có giá trị ban đầu bằng 0.Cho m phép biến đổi, mỗi phép có dạng (u, v, k): tăng mỗi phần tử từ vị trí u đến vị trí v lên k đơn vị.Cho q câu hỏi, mỗi câu có dạng (u, v): cho biết phần tử có giá trị lớn nhất thuộc đoạn [u, v]Giới hạnn, m, q &lt;= 50000k &gt; 0Giá trị của một phần tử luôn không vượt quá 2^31-1InputDòng 1: n, mm dòng tiếp theo, mỗi dòng chứa u, v, k cho biết một phép biến đổiDòng thứ m+2: pp dòng tiếp theo, mỗi dòng chứa u, v cho biết một phép biến đổiOutputGồm p dòng chứa kết quả tương ứng cho từng câu hỏi.ExampleInput:6 21 3 24 6 313 4Output:3SolutionTham Khảo Tại : http://dataurbia.com/zzQCodeTham Khảo Tại : http://dataurbia.com/zrZ",
              url: "/spoj/spoj-qmax-gia-tri-lon-nhat"
            }
            ,

            {
              title: "[SPOJ] HEAP1 - Một chút về Huffman Tree",
              author: "La Hoàng Phong",
              category: ["spoj"],
              tag: ["spoj", "data-structure", "heap"],
              content: "Link bài gốc : http://vnoi.info/problems/show/HEAP1/Đề bàiMột người nông dân muốn cắt 1 thanh gỗ có độ dài L của mình thành N miếng , mỗi miếng có độ dài là 1 số nguyên dương A[i] ( A[1] + A[2] + … A[N] = L ) . Tuy nhiên để cắt một miếng gỗ có độ dài là X thành 2 phần thì ông ta sẽ mất X tiền . Ông nông dân này không giỏi tính toán lắm , vì vậy bạn được yêu cầu lập trình giúp ông ta cho biết cần để dành ít nhất bao nhiêu tiền thì mới có thể cắt được tấm gỗ như mong muốn .Lưu ý : Kết quả có thể vượt longint ( trong Pascal ) và vượt long ( trong C++ ) đấy nhé .InputDòng 1 : 1 số nguyên dương T là số bộ test . T nhóm dòng tiếp theo mô tả các bộ test , mỗi nhóm dòng gồm 2 dòng :Dòng 1 : số nguyên dương N ( 1 ≤ N ≤ 20000 ) .Dòng 2 : N số nguyên dương A[1] ,…, A[N] . ( 1 ≤ A[i] ≤ 50000 )OutputKết quả mỗi test ghi ra trên 1 dòng , ghi ra 1 số nguyên dương duy nhất là chi phí tối thiểu cần để cắt tấm gỗ .ExampleInput:141 2 3 4Output:19Giải thíchĐầu tiên cắt miếng gỗ thành 2 phần có độ dài 6 và 4 . Sau đó cắt tiếp miếng có độ dài 6 -&gt; 3 và 3 . Cắt 1 miếng 3 thành 2 phần có độ dài 1 , 2 . Như vậy chi phí là 10 + 6 + 3 = 19.SolutionTham Khảo Tại : http://dataurbia.com/zVXCodeTham Khảo Tại : http://dataurbia.com/zUR",
              url: "/spoj/spoj-heap1-mot-chut-ve-huffman-tree"
            }
            ,

            {
              title: "[SPOJ] LQDGONME - Dãy con chung dài nhất (new ver)",
              author: "Accepted Problems",
              category: ["spoj"],
              tag: ["spoj", "dp"],
              content: "Link đề gốc:http://vnoi.info/problems/show/LQDGONME/Đề bài:Cho m dãy là hoán vị của n số tự nhiên đầu tiênTìm độ dài dãy con chung dài nhất của m dãy đóInputDòng đầu chứa số hai số nguyên n và m (1≤n≤1000,1≤m≤10)M dòng sau mỗi dòng chứa n số nguyên là dãy hoán vị của n số tự nhiên đầu tiênOutputĐưa là độ dài lớn nhất của dãy con chungVí dụ:Input:5 31 5 3 4 21 3 4 2 53 1 5 4 2Output:3Dãy con chung dài nhất là 1,4,2Solution:Tham khảo tại: http://dataurbia.com/zd4Code:Tham khảo tại: http://dataurbia.com/yUI",
              url: "/spoj/spoj-lqdgonme-day-con-chung-dai-nhat-new-ver"
            }
            ,

            {
              title: "[SPOJ] NKMAXSEQ - Dãy con dài nhất",
              author: "CVHvn",
              category: ["spoj"],
              tag: ["SPOJ", "data-structure", "Dp"],
              content: "Link đề bài: http://vnoi.info/problems/show/NKMAXSEQ/Đề bài:Cho dãy số nguyên a1, a2, …, an.Dãy số ai, ai+1, …, aj với 1 ≤ i ≤ j ≤ n được gọi là dãy con của dãy số đã cho và khi đó, j-i+1 được gọi là độ dài, còn ai+ai+1…+aj được gọi là trọng lượng của dãy con này.Yêu cầu: cho số nguyên p, trong số các dãy con của dãy số đã cho có trọng lượng không nhỏ hơn p hãy tìm dãy con có độ dài lớn nhất.Input:Dòng đầu tiên ghi hai số nguyên n và p cách nhau bởi dấu cách.Dòng thứ i trong số n dòng tiếp theo chứa số nguyên ai là số hạng thứ i của dãy số đã cho, i = 1, 2, …, n.Output:Ghi ra số nguyên k là độ dài của dãy con tìm được (qui ước: nếu không có dãy con nào thỏa mãn điều kiện đặt ra thì k = -1).Giới hạn:Trong tất cả các test: 1 ≤ n ≤ 50000; |ai| ≤ 20000; |p| ≤ 10^9. Có 50% số lượng test với n ≤ 2000.Soltution: http://dataurbia.com/uFRCode: http://dataurbia.com/tax",
              url: "/spoj/spoj-nkmaxseq-day-con-dai-nhat"
            }
            ,

            {
              title: "[SPOJ] SPSEQ - Sequences",
              author: "CVHvn",
              category: ["spoj"],
              tag: ["spoj", "Dp", "data-structure", "binary-search"],
              content: "Link đề bài: http://vnoi.info/problems/show/SPSEQ/Đề bài:W. là 1 dãy các số nguyên dương. Nó có các đặc điểm sau:  Độ dài của dãy là 1 số lẻ : L = 2*N + 1  N + 1 số nguyên đầu tiên của dãy tạo thành 1 dãy tăng  N + 1 số nguyên cuối của dãy tạo thành 1 dãy giảm  Không có 2 số nguyên nào cạnh nhau trong dãy có giá trị bằng nhauVí dụ: 1, 2, 3, 4, 5, 4, 3, 2, 1 là 1 dãy W. độ dài 9. Tuy nhiên, dãy 1, 2, 3, 4, 5, 4, 3, 2, 2 không là 1 dãy W.Yêu cầu: Trong các dãy con của dãy số cho trước, tìm dãy W. có độ dài dài nhất.Input:Dòng 1: số nguyên dương N (N &lt;= 100000), độ dài dãy số.Dòng 2: N số nguyên dương ai(ai &lt;= 10^9).Output1 số nguyên dương duy nhất là độ dài dãy W. dài nhất.ExampleInput:101 2 3 4 5 4 3 2 1 10Output:9Input:191 2 3 2 1 2 3 4 3 2 1 5 4 1 2 3 2 2 1Output:9Solution:http://dataurbia.com/pXdCode:http://dataurbia.com/pKp",
              url: "/spoj/spoj-spseq-sequences"
            }
            ,

            {
              title: "[Lý thuyết đồ thị cơ bản] Phần 2: Tìm kiếm theo chiều rộng trên đồ thị - Breadth-First Search (BFS)",
              author: "Phương Nguyễn",
              category: ["article"],
              tag: ["lý-thuyết-đồ-thị-cơ-bản", "graph"],
              content: "Phần trước: [Lý thuyết đồ thị cơ bản] Phần 1: Giới thiệuLấy một bài toán đơn giản: ta có một trạng thái của khối rubik 3 * 3.Ta muốn thực hiện ít bước nhất để hoàn thành khối rubik này. Vậy phải làm sao?Ta sẽ quy đổi bài toán này thành một bài toán trên đồ thị: mỗi một đỉnh trên đồ thị là một trạng thái của rubik, và hai đỉnh được nối với nhau bởi một cạnh không trọng số nếu như từ trạng thái này có thể trực tiếp chuyển sang trạng thái kia. Vậy ta cần tìm đường đi ngắn nhất từ nút hiện tại tới nút kết quả.Rơi vào trường hợp khác ta lại muốn biết tất cả các đường đi từ u tới v. Hoặc có thể là tìm tất cả đường đi từ u tới một nút nào đó khác. Hoặc ta muốn duyệt tất cả các nút của đồ thị hay các cạnh của đồ thị…Các vấn đề này sẽ được giải quyết bằng các thuật toán tìm kiếm trên đồ thị. Có nhiều thuật toán tìm kiếm trên đồ thị, bài viết này sẽ nói về thuật toán tìm kiếm theo chiều rộng (Breadth-First Search - BFS).Thuật toán tìm kiếm theo chiều rộng thường dùng cho hai mục đích: tìm kiếm đường đi từ một đỉnh gốc tới một đỉnh khác hoặc ngược lại, hoặc tìm kiếm đường đi từ một đỉnh gốc tới tất cả các đỉnh khác. Trong đồ thị không có trọng số hoặc tất cả trọng số bằng nhau, đường đi này sẽ là ngắn nhất có thể. Thuật toán này còn được dùng để tìm các thành phần liên thông của đồ thị, hoặc kiểm tra đồ thị hai phía, …Thuật toán:Thuật toán sử dụng một cấu trúc dữ liệu hàng đợi (queue) để lưu trữ thông tin trung gian thu được trong quá trình tìm kiếm. Queue là một cấu trúc cho phép lưu trữ các dữ liệu vào và xuất dữ liệu ra theo thứ tự đi vào (first-in, first-out - FIFO):  Thêm đỉnh gốc vào queue và đánh dấu đỉnh gốc.  Nếu queue chưa rỗng, lấy ra đỉnh u đầu tiên khỏi queue. Xét các đỉnh v kề với đỉnh u          Nếu đỉnh v đã được đánh dấu thì bỏ qua.      Nếu v chưa được đánh dấu thì thêm đỉnh v vào queue và đánh dấu đỉnh v.        Nếu queue rỗng, dừng quá dình tìm kiếm.Cài đặt bằng C++:vector&lt;int&gt; g[maxn]; // vector lưu trữ đỉnh kềqueue&lt;int&gt; s; // hàng đợiint cl[maxn]; // mảng đánh dấuvoid bfs(int u) // u là đỉnh xuất phát{    s.clear(); // dọn sạch hàng đợi    s.push(u); // bỏ đỉnh xuất phát vào    cl[u] = 1; // đánh dấu đỉnh xuất phát    while(!s.empty()) // chừng nào hàng đợi còn chưa rỗng    {        int u = s.front(); // lấy ra đỉnh ở đầu queue        s.pop(); // bỏ đỉnh ở đầu queue ra khỏi queue        for(int v : g[u]) // với mỗi đỉnh v kề với đỉnh u        {            if(cl[v]==0) // nếu đỉnh v chưa được đánh dấu            {                s.push_back(v); // bỏ đỉnh v vào queue                cl[v]=1; // đánh dấu đỉnh v            }\t}    }}Khi áp dụng, tùy theo yêu cầu xử lí đồ thị mà người lập trình cần sửa đổi cho phù hợp.Phân tích thuật toán:  Không gian: Nếu V là tập hợp của đồ thị và |V| là số đỉnh của đồ thị thì không gian cần dùng của thuật toán là 2|V| ô nhớ.  Thời gian: Nếu V và E là tập hợp các đỉnh và cung của đồ thị, thì thời gian thực thi của thuật toán là O(|E| + |V|) vì trong trường hợp xấu nhất, mỗi đỉnh và cung của đồ thị được thăm đúng một lần. O(|E| + |V|) nằm trong khoảng từ O(|V|) đến O(|V|^2), tùy theo số cung của đồ thị.Hệ quả:Sau khi BFS để tìm đường đi từ một đỉnh u tới tất cả các đỉnh v khác trong đồ thị, nếu ta gọi pre[v] là nút dẫn tới đỉnh v trong quá trình bfs với mọi v là một đỉnh thuộc đồ thị, ta sẽ có được đường đi từpre[v] —–&gt; vpre[pre[v]] —–&gt; vpre[pre[pre[v]]] —–&gt; v…u —–&gt; vlà ngắn nhất.Phần sau: [Lý thuyết đồ thị cơ bản] Phần 3: Tìm kiếm theo chiều sâu trên đồ thị - Depth-First Search (DFS)",
              url: "/article/ly-thuyet-do-thi-co-ban-tim-kiem-theo-chieu-rong-tren-do-thi-breadth-first-search-bfs"
            }
            ,

            {
              title: "[SPOJ] QTSEQ - Dãy số QT",
              author: "Nicky.Rio",
              category: ["spoj"],
              tag: ["dp", "spoj"],
              content: "Link gốchttp://vnoi.info/problems/show/QTSEQ/Đề bàiMột vụ tai nạn giao thông vừa xảy ra ngoài phố. Mọi người tò mò chen lấn vòng trong vòng ngoài để xem. Rất đông người xem vụ tai nạn như:khanh_can_k7, nhungngoisao, chicuong123, harry_porter_7, mr_ntt, manhboyak6. Một anh đến chậm không tài nào vào xem được. Tức quá, anh ta liền hét toáng lên:  Tôi là bố kẻ bị nạn đây!Mọi người kinh ngạc quay lại nhìn và vội vã giãn ra cho anh ta vào. “Kẻ bị nạn” là một… chú chó vừa bị xe cán chết.Ngại ngùng, anh ta chạy về nhà, than khóc. Và ông tiên hellosirius hiện ra ban cho anh ta 1 điều ước. Anh ta ước rằng mọi người trên thế giới sẽ quên hết mọi chuyện trong hôm nay. Tuy nhiên, theo định luật bảo toàn năng lượng cũng như định luật bảo toàn tính mạng ông tiên buộc chú phải giải bài toán sau mới giúp chú thực hiện điều ước. Nhanh chóng chú giải được bài toán ông đưa ra tuy nhiên, lần này ông buộc chú phải chiến đấu với hiệp sĩ đẹp trai n_cqt và blackstar. Để chiến thắng hiệp sĩ cách duy nhất là giải được bài toán hiệp sĩ đưa ra (vì hiệp sĩ không những đẹp trai, học giỏi mà còn khỏe mạnh vô đối nữa ). Đề bài của hiệp sĩ như sau:Cho dãy số nguyên A gồm N phần tử A1,A2,…,An. Tìm cặp chỉ số i,j thỏa mãn:            DSEQ =      (A1+ A2+ … + Ai) - (Aj+ Aj+1+ … + An)      đạt giá trị lớn nhất (với 1 ≤ i &lt; j ≤ N).      Hãy giúp anh bạn khốn khổ của chúng ta hoàn thành điều ước!Input:Dòng đầu là số nguyên dương N; (2 ≤ N ≤ 10^6).              Dòng tiếp theo chứa N số nguyên A1, A2, …, An; (      Ai      &lt;10^9), các số cách nhau một dấu cách.      Output:Gồm một dòng chứa 2 số nguyên là DSEQ lớn nhất tìm được( do hiệp sĩ n_cqt yêu cầu ) và số cặp chỉ số thỏa mãn (hai số cách nhau một dấu cách) ( do hiệp sĩ blackstar yêu cầu )Ví dụInput51 -2 3 -4 -7Output13 1Lưu ý: 50% số test N&lt;= 5000Solutionhttp://dataurbia.com/maoCode mẫuhttp://ideone.com/BNYqU2",
              url: "/spoj/spoj-qtseq-day-so-qt"
            }
            ,

            {
              title: "[SPOJ] QUEENNB - Quân Hậu",
              author: "Nicky.Rio",
              category: ["spoj"],
              tag: ["dp", "spoj"],
              content: "Đề gốchttp://vnoi.info/problems/show/QUEENNB/Đề bàiMất ngủ vì không có đối thủ trong môn cờ vua, KHUELD quyết định chế tạo một robot để chơi cờ với mình. Một trong những việc đầu tiên là phải “dạy” robot biết quy tắc không chế bàn cờ của quân hậu.Xét bàn cờ vua hình chữ nhật kích thước 𝑚 × 𝑛 được chia làm lưới ô vuông đơn vị. Các hàng của bàn cờ được đánh số từ 1 tới 𝑚 từ trên xuống và các cột của bàn cờ được đánh số từ 1 tới 𝑛 từ trái quá phải, ô nằm trên giao của hàng 𝑖 và cột 𝑗 được gọi là ô (𝑖,𝑗)Trên bàn cờ, tại một số ô có đặt vật cản. Quân hậu ở một ô có thể không chế một ô khác nếu đoạn thẳng nối tâm hai ô đó song song với một trong hai cạnh bàn cờ hoặc đi qua đỉnh ô vuông có quân hậu đangđứng, đồng thời đoạn thẳng nối tâm hai ô không được chứa tâm bất kỳ ô nào chứa vật cản. Ta quy ước rằng quân hậu phải đặt vào ô không có vật cản và cũng khống chế luôn ô nó đang đứng.Yêu cầu:Cho biết tình trạng bàn cờ, với mỗi ô (𝑖,𝑗) không chứa vật cản, hãy “dạy” cho robot của KHUELD biết có bao nhiêu ô trên bàn cờ mà đặt hậu ở đó sẽ không chế được ô (𝑖,𝑗)Dữ liệu:  Dòng 1 chứa hai số nguyên dương 𝑚, 𝑛 ≤ 1000  𝑚 dòng tiếp theo , dòng thứ 𝑖 chứa 𝑛 ký tự liền nhau, ký tự thứ 𝑗 là dấu “.” (chấm) nếu ô (𝑖,𝑗) là ô trống, là dấu # nếu ô (𝑖,𝑗) có đặt vật cản.Kết quả:Ghi ra 𝑚 dòng, dòng 𝑖 in ra 𝑛 số nguyên, số nguyên thứ 𝑗 là số ô trên bàn cờ mà khi đặt quân hậu vào ô đó có thể khống chế được ô (𝑖,𝑗).Các số trên một dòng của phải ghi cách nhau bởi dấu cách.Ví dụInput4 3.#..#......#Output4 0 35 0 57 7 67 5 0Solutionhttp://dataurbia.com/m5HCode mẫuhttp://dataurbia.com/lxG",
              url: "/spoj/spoj-queennb-quan-hau"
            }
            ,

            {
              title: "[SPOJ] INCVN - INCSEQ VN",
              author: "CVHvn",
              category: ["spoj"],
              tag: ["SPOJ", "data-structure", "dp"],
              content: "Link đề bài: http://vnoi.info/problems/show/INCVN/Đề bài:Cho 1 dãy số gồm N(0 &lt; N ≤ 10000) số tự nhiên S1,S2,…,Sn (0 ≤ S[i] ≤ 100000), Hãy đếm số lượng dãy con tăng có độ dài K(0 &lt; k ≤ 50).InputDòng đầu tiên là hai số tự nhiên N và K.N dòng tiếp sau mô tả dãy S.OutputSố lượng dãy con thỏa mãn theo Module 5000000.Solution: http://adf.ly/1ni7cnCode: http://adf.ly/1ni6lP",
              url: "/spoj/spoj-incvn-incseq-vn"
            }
            ,

            {
              title: "[C++ Cơ bản] Phần 2: Giới thiệu về C++",
              author: "Admin Tổng Quản",
              category: ["article"],
              tag: ["cpp-cơ-bản", "programming"],
              content: "Phần trước: [C++ Cơ bản] Phần 1: Bản chất của lập trìnhĐịnh nghĩa C++ của trang tutorialspoint.com là:C++ là một ngôn ngữ lập trình định kiểu tĩnh, biên dịch, đa chức năng, đa hình và phân biệt chữ thường - chữ hoa, hỗ trợ lập trình thủ tục, lập trình hướng đối tượng và dữ liệu trừu tượng.Hãy cùng giải thích từng phần một của định nghĩa trên:  Ngôn ngữ lập trình định kiểu tĩnh (statically typed): là ngôn ngữ lập trình xác định tất cả các kiểu dữ liệu trong mã nguồn vào thời điểm dịch. Nếu xảy ra sai sót về kiểu dữ liệu (ví dụ: gán giá trị là 1 xâu kí tự - string cho một biến kiểu số nguyên) thì bộ dịch sẽ báo lỗi và chương trình sẽ không được dịch. C++ là ngôn ngữ lập trình định kiểu tĩnh, trong khi một số ngôn ngữ khác như Javascript là ngôn ngữ định kiểu động - các biến trong chương trình có thể có bất cứ kiểu dữ liệu nào.  Biên dịch (complied): là ngôn ngữ phải đi qua một bộ dịch (complier) trước khi trở thành một chương trình hệ điều hành có thể dùng. Biên dịch khác với thông dịch là ngôn ngữ thông dịch sẽ đi qua một trình thông dịch (interpreter) theo từng dòng code một trong thời gian thực để thực hiện chương trình. C++ là ngôn ngữ biên dịch, Javascript là ngôn ngữ thông dịch.  Đa chức năng (general-purpose): là ngôn ngữ có thể sử dụng cho nhiều mục đích, do cấu trúc của nó không bắt buộc nó phải chạy trong một môi trường cụ thể nào cả.  Đa hình (free-form): là ngôn ngữ không quan trọng về vấn đề sắp đặt các kí tự trong mã nguồn, miễn là chúng đúng cú pháp. Các dấu cách và kí tự xuống dòng không ảnh hưởng tới quá trình dịch, chúng chỉ có tác dụng chia cách các đối tượng trong mã nguồn và để mã nguồn dễ đọc hơn. Do đó, việc đặt nhiều dấu cách hay xuống dòng đúng chỗ là không bắt buộc, cho dù được khuyến khích để code dễ đọc, dễ bảo trì hơn.  Phân biệt chữ thường - chữ hoa (case-sensitive): các yếu tố trong ngôn ngữ có phân biệt chữ thường - hoa. Ví dụ abc và ABC là hai tên biến của 2 biến khác nhau.  Lập trình thủ tục (procedural programming): là mô hình lập trình mà chương trình được tổ chức như là các thủ tục xử lý dòng dữ liệu từ trên xuống dưới.  Lập trình hướng đối tượng (object oriented programming): là mô hình lập trình mà chương trình được tổ chức như là một tập hợp các đối tượng, mỗi đối tượng có các tính chất (dữ liệu) và phương thức (chương trình con) để giao tiếp với chính nó và với các đối tượng khác.  Dữ liệu trừu tượng (generic programming): là khả năng lập trình cho phép người dùng đặt các kiểu dữ liệu sẽ-được-xác-định-về-sau trong thuật toán. Ví dụ: khi viết cấu trúc vector để lưu trữ dữ liệu, ta có thể đặt kiểu dữ liệu trừu tượng cho cấu trúc vector ban đầu, và khai báo kiểu dữ liệu được lưu trữ riêng cho từng cá thể vector về sau.C++ được đánh giá là ngôn ngữ bậc trung, vì nó có các tính chất và chức năng của cả ngôn ngữ bậc thấp và cao.C++ được phát triển bởi Bjarne Stroustrup từ năm 1979 tại Bell Labs, Murray Hill, New Jersey, để cải tiến cho ngôn ngữ C và được đặt tên ban đầu là C có Class, nhưng về sau đổi thành C++ vào năm 1983.C++ là một tập hợp cha của C, và bất cứ chương trinh C hợp lệ nào cũng là chương trình C++ hợp lệ.Các thư viện chuẩnNgôn ngữ C++ tiêu chuẩn bao gồm 3 phần:  Phần ngôn ngữ gốc bao gồm các yếu tố cấu thành nên chương trình như các biến, kiểu dữ liệu, toán tử, vân vân…  Thư viện C++ chuẩn (Standard Library, viết tắt là std) cung cấp các hàm và lệnh liên quan tới xử lý file, string, vân vân…  Thư viện Template C++ chuẩn (Standard Template Library, viết tắt là STL) cung cấp các cấu trúc dữ liệu như set, vector, map, …Phương pháp học C++Điều quan trọng nhất khi học C++ là tập trung vào các khái niệm, thay vì vào các chi tiết kĩ thuật. Nên nhớ rằng ngôn ngữ cũng chỉ là cách giải thích thuật toán của con người để máy tính có thể hiểu được - nắm vững khái niệm sẽ giúp ta nhanh chóng chuyển đổi kiến thức từ ngôn ngữ này sang ngôn ngữ khác, thay vì nhớ một cách máy móc cách câu lệnh.Đừng chỉ đọc lý thuyết, hãy đem những kiến thức mới học vào thực hành. Bắt đầu từ những chương trình nhỏ và đơn giản; tới khi kết thúc series này, bạn sẽ có đủ kiến thức để áp dụng C++ vào những công việc phức tạp hơn như lập trình thi đấu hoặc sản xuất ứng dụng.Điều cuối cùng nhưng không kém phần quan trọng, đó là đừng ngại ngần đem những thắc mắc của mình lên các diễn đàn lớn để hỏi, hoặc tìm kiếm trên Google. Bạn cũng có thể comment những thắc mắc của mình ở ngay dưới mục comment của bài viết để được nhóm trợ giúp.Ứng dụng của C++C++ được sử dụng bởi hàng nghìn lập trình viên trên nhiều lĩnh vực khác nhau. Một ứng dụng quan trọng của C++ là để viết các chương trình điều khiển phần cứng (driver) hoặc các ứng dụng xử lý trực tiếp phần cứng trong thời gian thực.C++ cũng được sử dụng rộng rãi để giảng dạy và nghiên cứu, vì cấu trúc gọn gàng của nó rất tốt cho việc giải thích các khái niệm cơ bản của lập trình.Bất cứ ai đã sử dụng các thiết bị Macintosh của Apple hoặc PC chạy Windows đều đã gián tiếp sử dụng C++, vì giao diện người dùng chính của các hệ điều hành này đều được viết bằng C++.C++ được đánh giá là ngôn ngữ lập trình phổ biến thứ 4, theo đánh giá của spectrum.ieee.org.Phần sau: [C++ Cơ bản] Phần 3: Thiết lập môi trường làm việc - Giới thiệu về Code::Blocks",
              url: "/article/c-co-ban-phan-2-gioi-thieu-ve-c"
            }
            ,

            {
              title: "[SPOJ] VMRESTO - Bé và bảng số",
              author: "Nguyễn Minh Quân",
              category: ["spoj"],
              tag: ["spoj", "implementation"],
              content: "Link đề gốc: http://vnoi.info/problems/show/VMRESTO/Đề bàiBé năm nay mới 7 tuổi, nhưng đã thể hiện niềm đam mê với Toán học. Bé rất thích chơi với những bảng sốN*N - các hàng được đánh số từ0tớiN-1từ trên xuống dưới và các cột được đánh số từ0tớiN-1từ trái sang phải. Đặc biệt bé tỏ ra vô cùng hứng thú với những bảng số kỳ diệu - những bảng số có tổng mỗi hàng, tổng mỗi cột, tổng đường chéo chính và tổng đường chéo phụbằng nhau.Đường chéo chính gồm những ô nằm trên hàngi, cộti. Đường chéo phụ gồm những ô nằm trên hàngi, cộtN-i-1.Ví dụ. Xét bảng 3*3:2 9 47 5 36 1 8Bảng này có tổng của mỗi hàng là:  2 + 9 + 4 = 15  7 + 5 + 3 = 15  6 + 1 + 8 = 15Tổng mỗi cột là:  2 + 7 + 6 = 15  9 + 5 + 1 = 15  4 + 3 + 8 = 15Tổng đường chéo chính và đường chéo phụ là:  2 + 5 + 8 = 15  6 + 5 + 4 = 15Vì tổng mỗi hàng, mỗi cột và 2 đường chéo đều bằng nhau và bằng 15, nên bảng số này được gọi là bảng số kỳ diệu.Hôm nay, bé được cô tặng 1 bảng số kỳ diệuN*N. Bé thích lắm. Nhưng để thử thách bé, cô đã xóa tất cả các số trên đường chéo từ góc trên trái xuống góc phải dưới (đường chéo chính). Bạn có thể giúp bé khôi phục lại bảng không?InputDòng đầu: Chứa số nguyên dươngN.Ndòng tiếp, mỗi dòng chứa đúngNsố nguyên thể hiện bảng. Trong đó, số ở hàngi, cộti bằng 0 (thể hiện số đã bị xóa).OutputGồmNdòng, mỗi dòng chứa đúngNsố nguyên thể hiện bảng ban đầu.Giới hạn  Trong tất cả các test, ta có 1&lt;N&lt;=100.  Các số còn lại trong input có trị tuyệt đối không quá1012.  Trong 20% test (tương ứng với 20% số điểm),Nlà sốchẵn.  Trong 40% test (tương ứng với 40% số điểm), các số trong bảng ban đầu có trị tuyệt đối không quá2000.  Trong quá trình thi, bài của bạn chỉ được chấm với test ví dụ, và nếu bạn ra kết quả đúng, điểm sẽ được hiển thị là 100.SolutionHereCode mẫuHere",
              url: "/spoj/spoj-vmresto-be-va-bang-so"
            }
            ,

            {
              title: "[SPOJ] INTEGER7 - Integers",
              author: "CVHvn",
              category: ["spoj"],
              tag: ["Diophantine", "Math", "spoj"],
              content: "Link đề bài : http://vnoi.info/problems/show/INTEGER7/Đề bài :Tìm hai số nguyên không âm x1 và x2 thỏa mãn a1 * x1 + b1 = a2 * x2 + b2 và x1 + x2 là nhỏ nhất. Biết rằng luôn tồn tại số x1, x2 thỏa mãn.InputGồm 1 dòng 4 số nguyên a1, b1, a2, b2 (các số nguyên không âm trong phạm vi [0..2^31 - 1]).OutputGhi ra 2 số x1, x2 thỏa mãn yêu cầu đề bài.Solution : http://dataurbia.com/iKQCode : http://dataurbia.com/iJF",
              url: "/spoj/spoj-integer7-integers"
            }
            ,

            {
              title: "[SPOJ] INCSEQ - Increasing Subsequences",
              author: "houtaru",
              category: ["spoj"],
              tag: ["spoj", "dp", "data-structure", "bit"],
              content: "Link đề bài : http://www.vnoi.info/problems/show/INCSEQ/Đề bài :Cho 1 dãy N phần tử (1 &lt;= N &lt;= 10^4). Đếm số dãy con tăng độ dài k (1 &lt;= k &lt;= 50 &amp;&amp; k &lt;= N).Input :  Dòng đầu gồm 2 số n, k  N dòng tiếp theo gồm số của dãy.Output :  Gồm 1 dòng là kết quả của bài toán.Example :Input:4 312210Output:2Solution: http://dataurbia.com/f8ECode: http://dataurbia.com/f8q",
              url: "/spoj/spoj-incseq-increasing-subsequences"
            }
            ,

            {
              title: "[SPOJ] VMDAOBIT - Đảo bit",
              author: "Nguyễn Minh Quân",
              category: ["spoj"],
              tag: ["spoj", "implementation"],
              content: "Link đề gốc: http://vnoi.info/problems/show/VMDAOBIT/Đề bàiCho một bảng kích thước M * N. Các hàng được đánh số từ 1 đến M từ trên xuống dưới. Các cột được đánh số từ 1 đến N từ trái sang phải. Mỗi ô của bảng có giá trị là0hoặc1. Bạn được thực hiện thao tác: Chọn một hình vuông 3*3 nằm trọn vẹn trong bảng và đảo bit tất cả các ô trong hình vuông đó (từ 1 chuyển về 0, hoặc từ 0 chuyển về 1). Mỗi hình vuông 3*3 không được chọn quá một lần.Nhiệm vụ của bạn là tìm một dãy ít thao tác nhất sao cho sau khi thực hiện thì bảng chỉ còn chứa số0. In ra tọa độ ô trái trên của các hình vuông3*3 với tọa độ hàng tăng dần (nếu hai ô có cùng tọa độ hàng thì hình vuông nào có tọa độ cột của ô trái trên nhỏ hơn sẽ được in trước). Nếu không thể đưa bảng về toàn số 0 thì in ra-1. Nếu có nhiều phương án, bạn có thể in ra phương án bất kỳ.Input  Dòng 1: Chứa 2 số nguyênMvàN(M,N≤ 100).  Mdòng tiếp theo: mỗi dòng chứaNsố0hoặc1.Output  Dòng đầu chứa sốK- số thao tác bạn thực hiện (nếu không tồn tại dãy thao tác thỏa mãn yêu cầu thì chỉ in ra duy nhất số -1).  Kdòng tiếp theo mô tảKthao tác được thực hiện, mỗi dòng chứa  2 số nguyên dương là tọa độ ô trái trên của các hình vuông3*3.Giới hạn  Tất cả các test có M, N≤ 100.  Trong 40% test (tương ứng với 40% số điểm), M*N≤ 18.  Trong quá trình thi, bài của bạn chỉ được chấm với test ví dụ. Nếu được chấm đúng, kết quả sẽ được hiện là 100.SolutionHereCode mẫuHere",
              url: "/spoj/spoj-vmdaobit-dao-bit"
            }
            ,

            {
              title: "[SPOJ] RBULL - VOI 2016 - Trại bò tót",
              author: "Nguyễn Minh Quân",
              category: ["spoj"],
              tag: ["spoj", "implementation", "dp", "voi"],
              content: "Linh đề gốc : http://vnoi.info/problems/show/RBULL/Đề bàiÔng Bảo là chủ của một trang trại, đang nuôi một đàn bò trên khu đất hình chữ nhật chia thành lưới mxn ô vuông đơn vị. Các hàng của lưới được đánh số từ 1 tới m từ trên xuống, và các cột của lưới được đánh số từ 1 tới n từ trái qua phải. Ô nằm trên giao điểm của hàng i và cột j được gọi là ô (i, j). Tại tâm của một số ô đã cắm cọc, mỗi cọc để buộc một con bò. Để bảo vệ đàn bò tót quý của mình khỏi những tên trộm, ông Bảo thuê Hùng tìm một thửa đất có dạng hình thoi (mà theo quan niệm của ông Bảo là biểu tượng cho may mắn) trong khu đất để nhốt đàn bò của mình. Thửa đất hình thoi có tâm tại ô (x0,y0) và bán kính là r là tập hợp tất cả các ô có tọa độ (x, y) thỏa mãn |x – x0| + |y – y0| &lt;= r. Do bò tót là các con vật rất hung dữ, nên ông Bảo yêu cầu trong thửa đất tìm được không có hai ô có cọc nào lại có cạnh chung.Yêu cầu: Giúp Hùng xác định thửa đất có dạng hình thoi nằm trọng vẹn trong khu đất với số cọc cột bò là nhiều nhất đáp ứng yêu cầu của ông Bảo.Dữ liệu:      Dòng đầu tiên chứa 2 số nguyên m và n xác định kích thước của khu đất của ông Bảo.        Dòng  thứ i trong m dòng sau chứa n kí tự liền nhau, mỗi kí tự xác định trạng thái của một thửa đất: ‘*’ nếu ô đất có cắm cọc và ‘.’ nếu ô đất đó không cắm cọc.  Kết quả:  Đưa ra 4 số nguyên S, x0, y0, r được ghi cách nhau một dấu cách, trong đó: S là tổng số cọc trong thửa đất được chọn; x0, y0là tọa độ tâm và r là bán kính của thửa đất đó. Nếu có nhiều lời giải hãy đưa ra một lời giải bất kỳ.SolutionHereCode mẫuHere",
              url: "/spoj/spoj-rbull-voi-2016-trai-bo-tot"
            }
            ,

            {
              title: "[Lý thuyết đồ thị cơ bản] Phần 1: Giới thiệu",
              author: "Phương Nguyễn",
              category: ["article"],
              tag: ["lý-thuyết-đồ-thị-cơ-bản", "graph"],
              content: "Trong toán học và tin học, đồ thị là đối tượng nghiên cứu cơ bản của lý thuyết đồ thị. Một cách không chính thức, đồ thị là một tập các đối tượng gọi là đỉnh nối với nhau bởi các cạnh. Thông thường, đồ thị được vẽ dưới dạng một tập các điểm (đỉnh, nút) nối với nhau bởi các đoạn thẳng (cạnh). Tùy theo ứng dụng mà một số cạnh có thể có hướng.Sơ lược các khái niệm cơ bản về đồ thịMột cách không chính thức, đồ thị là một tập các đối tượng được gọi là các đỉnh nối với nhau bởi các cạnh.Một đồ thị kí hiệu làTrong đó:      \\( V \\) là tập các đỉnh của đồ thị. Đặt \\( \\mid V \\mid = n \\) (số đỉnh).        \\( E \\) là tập các cạnh của đồ thị. Đặt \\( \\mid E \\mid = m \\) (số cạnh).  Đỉnh:Đỉnh biểu diễn các đối tượng trong đồ thị, thường được đánh dấu bằng các số hoặc kí hiệu bằng các chữ cái in thường u,v,…Cạnh:Cạnh nối đỉnh x với đỉnh y là một tập gồm hai phần tử \\( {x, y} \\), thường được vẽ dưới dạng một đoạn thẳng nối hai đỉnh.Cạnh có hướng (cung):Là một cặp đỉnh có thứ tự. Trong mỗi cặp có thứ tự đó, đỉnh thứ nhất được gọi là đỉnh đầu, đỉnh thứ hai là đỉnh cuối.Cạnh vô hướng:Không quan tâm đến hướng và coi hai đỉnh như nhau.Khuyên:Là một cạnh nối một đỉnh với chính nó.Hai cạnh song song:Là hai cạnh cùng nối hai đỉnh u, v.Đồ thị có hướng:Là đồ thị mà tất cả các cạnh trong đồ thị đều có hướng.Đồ thị vô hướng:Là đồ thị mà tất cả các cạnh trong đồ thị đều vô hướng.Đơn đồ thị:Là đồ thị không có khuyên và không có cạnh song song.Đa đồ thị:Là đồ thị không phải là đơn đồ thị.Bậc:Trong đồ thị vô hướng, bậc của đỉnh v trong đồ thị G, ký hiệu \\( d_G(u) \\), là số cạnh liên thuộc với v, trong đó, khuyên được tính hai lần.Ta có định lí:Giả sử \\( G=(V, E) \\) là đồ thị vô hướng, khi đó tổng các bậc đỉnh trong V sẽ bằng 2 lần số cạnh.Hệ quả: Trong đồ thị vô hướng, số đỉnh bậc lẻ là chẵn.Trong đồ thị có hướng, ta định nghĩa bán bậc ra của u là số cung đi ra khỏi nó, kí hiệu \\( d^+_G(u) \\), bán bậc vào của u là số cung đi ra khỏi nó, kí hiệu \\( d^-_G(u) \\).Giả sử \\( G=(V, E) \\) là đồ thị có hướng, khi đó tổng các bán bậc vào bằng tổng các bán bậc ra và bằng số cung của đồ thị.Đường đi và chu trình:Một dãy các đỉnh P = (p0,p1,…,pk) sao cho (Pi-1, Pi) ∊ E, ∀i: 1&lt;=i&lt;=k được gọi là một đường đi.Một đường đi là chu trình khi p0 = pk.Liên thông:Một đồ thị vô hướng là liên thông nếu tồn tại đường đi giữa hai cặp đỉnh bất kì thuộc đồ thị.Một đồ thị có hướng là liên thông nếu phiên bản vô hướng của đồ thị đó là liên thông.Đồ thị phẳng:Đồ thị phẳng là đồ thị có thể được vẽ trên mặt phẳng sao cho không có hai đỉnh nào trùng nhau và các cạnh nào trùng nhau hoặc cắt nhau.Công thức Euler:Giả sử đồ thị vô hướng liên thông \\( G=(V, E) \\) là đồ thị phẳng, với n đỉnh và m cạnh chia mặt phẳng thành e phần thìBiểu diễn đồ thị trên máy tính:Có nhiều cách để biểu diễn đồ thị trên máy tính, tùy thuộc vào tính chất của đồ thị hoặc thuật toán áp dụng với đồ thị… Ta cũng có thể lưu kèm theo các thông tin như trọng số, giá trị phù hợp với từng cạnh. Dưới đây là một vài cách phổ biến.Ma trận kề:Tạo một ma trận A kích thước n*n trong đó n là số đỉnh của đồ thị. Ta gán a[u][v] = 0 nếu có cạnh cạnh nối hai đỉnh u, v.Nếu đồ thị là đa đồ thị, ta có thể gán a[u][v] = số cạnh nối u và v.Định nghĩa và gán tùy theo lập trình viên hiểu là vô hướng hay có hướng, đơn đồ thị hay đa đồ thị.  Ưu điểm:          Để kiểm tra hai đỉnh u, v có kề nhau không, ta chỉ cần kiểm tra trong độ phức tạp \\( O(1) \\).        Nhược điểm:          Dù đồ thị có nhiều cạnh hay ít cạnh thì cũng phải mất n*n ô nhớ để lưu.      Để duyệt tất cả các đỉnh kề với u, ta phải duyệt tất cả các đỉnh v ∊ V cho dù đỉnh u kề với ít hoặc không kề với đỉnh nào khác.      Biểu diễn bằng ma trận kề thường được dùng khi đồ thị có ít đỉnh, hoặc đồ thị dày, nhiều cạnh, hoặc thuật toán để thao tác trên đồ thị yêu cầu.Danh sách cạnh:Với đồ thị \\( G=(V, E) \\) có n đỉnh, m cạnh, ta có thể liệt kê tất cả các cạnh của đồ thị bằng một danh sách tương ứng, mỗi phần tử của mảng tương ứng là một cặp (u,v) là một cạnh thuộc E, tùy theo người lập trình định nghĩa là có hướng hay vô hướng.  Ưu điểm:          Với đồ thị thưa, ta chỉ cần mất m (số lượng cạnh) ô nhớ để lưu đồ thị.        Nhược điểm:          Khi cần kiểm tra hai đỉnh u,v có kề nhau hay không, ta không thể kiểm tra nhanh trong //( O(1) //) như cách lưu bằng ma trận kề, mặc dù tùy theo cách lưu danh sách cạnh mà ta có thể kiểm tra trong //( O(logn) //) hoặc ít hơn.      Danh sách kề:Với mỗi đỉnh của đồ thị, ta lưu một danh sách các đỉnh kề với đỉnh đó.  Ưu điểm:          Với phương pháp này, việc duyệt tất cả các đỉnh kề với đỉnh u vô cùng dễ dàng.        Nhược điểm:          Khi cần kiểm tra hai đỉnh u,v có kề nhau hay không, ta không thể kiểm tra nhanh trong \\( O(1) \\) như cách lưu bằng ma trận kề, mặc dù tùy theo cách lưu danh sách cạnh mà ta có thể kiểm tra trong \\( O(logn) \\) hoặc ít hơn.      Phần sau: [Lý thuyết đồ thị cơ bản] Phần 2: Tìm kiếm theo chiều rộng trên đồ thị - Breadth-First Search (BFS)",
              url: "/article/ly-thuyet-do-thi-co-ban-phan-1-gioi-thieu"
            }
            ,

            {
              title: "Phép nhân Ấn Độ và phép tính lũy thừa",
              author: "Phương Nguyễn",
              category: ["article"],
              tag: ["algorithm", "math"],
              content: "Cho một bài toán đơn giản sau: Tính giá trị của \\( (3 * 10 ^ 9) * (3 * 10 ^ 9) \\), lấy mod \\( 10 ^ 9 \\). Ta có thể nhanh chóng tính ra kết quả của phép toán này bằng việc mod cả hai giá trị cho \\( 10 ^ 9 \\), rồi sau đó nhân chúng lại với nhau và mod lại thêm lần nữa.Nhưng nếu giá trị lấy mod là \\( 10^{18} \\) thì sao? Khi đó phép nhân của hai thừa số sẽ vượt quá khả năng biểu diễn của kiểu số nguyên 64 bit, phép toán sẽ sai hoàn toàn. Phương pháp nhân Ấn Độ sẽ được dùng để giải quyết những trường hợp như vậy.Phép nhân Ấn ĐộThuật toán đơn giản như sau: để tính \\( a * b \\) ta sẽ tính  \\( a * \\frac{b}{2} + a * \\frac{b}{2} \\) nếu b chẵn  \\( a * \\frac{b}{2} + a * \\frac{b}{2} + a \\) nếu b lẻCó rất nhiều cách code. Dưới đây là một cách viết đệ quy://C++long long nhan(long long a,long long b){    if (b == 0)         return 0;    long long t = nhan(a, b / 2);     \t    t = (t + t) % mod;     if (b % 2 == 1)         t = (t + a) % mod;} Khi đó, để tính giá trị \\( a * b \\) ta chỉ cần gọi hàm nhan(a, b).Đánh giá độ phức tạpDo sau mỗi lần gọi hàm nhan, giá trị của b bị giảm đi một nửa, nên thuật toán chỉ mất thời gian \\( O(log2(b)) \\).Phép tính lũy thừaBằng việc sửa đổi code, phương pháp này có thể được áp dụng để giải một bài toán tương tự, đó là tìm số mũ cực lớn của một số cho trước.Để tính \\( a ^ b \\) ta sẽ tính  \\( a ^ \\frac{b}{2} * a ^ \\frac{b}{2} \\) nếu b chẵn  \\( a ^ \\frac{b}{2} * a ^ \\frac{b}{2} * a \\) nếu b lẻ//C++long long mu(long long a,long long b){    if (b == 0)         return 0;    long long t = mu(a, b / 2);     \t    t = (t * t) % mod;     if (b % 2 == 1)         t = (t * a) % mod;} Độ phức tạp của thuật toán này cũng chỉ là \\( O(log2(b)) \\). Chú ý nếu lấy số mod lớn thì phải áp dụng nhân Ấn Độ thay vì phép nhân thông thường, độ phức tạp sẽ trở thành \\( O(log2(b) ^ 2) \\).",
              url: "/article/phep-nhan-an-do-va-phep-tinh-luy-thua"
            }
            ,

            {
              title: "[SPOJ] VO17TV - Tin nhắn kỳ diệu",
              author: "itsjustwinds",
              category: ["spoj"],
              tag: ["binary-search", "spoj"],
              content: "Đề: http://vnoi.info/problems/show/VO17TV/Ngoại tình là một trong những việc làm bị xã hội gay gắt nhất. Có ba kiểu ngoại tình chủ yếu: Tán vợ hàng xóm, … vợ bạn và cưới cô em vợ. Có những vụ ngoại tình cưới em vợ đã đi vào thi ca Việt Nam mà giờ đây chúng ta ai cũng biết.Thúy Vân sau khi kết hôn với “chồng” của chị gái mình, để xóa đi mọi dấu tích của mối tình cũ, đã cố gắng xóa mọi tin nhắn trước kia giữa chồng mình và chị gái. (Ghi chú: trong truyện, Thúy Vân mang họ Vương chứ không phải họ G*** như ngày nay). Chồng cô, dù đã có vợ nhưng vẫn không quên nổi mối tình xưa, lén lút giấu vợ giữ lại N tin nhắn của người yêu cũ. Trong lúc vợ mải mê công tác tại huyện Lạc Rang, TP Bắp Rang, anh ta vẫn lôi ra đọc lại N tin nhắn này.Có những lời lẽ được trao qua gửi lại rất nhiều lần. Kim Trọng gọi một đoạn tin nhắn là Kiều dị (kỳ diệu), nếu như nó là xâu con liên tiếp của ít nhất K trong số N tin nhắn kia. Anh ta muốn tìm ra đoạn tin nhắn kỳ diệu dài nhất, và khắc cốt ghi tâm đoạn này.InputDòng đầu tiên chứa hai số nguyên dương N và K.N dòng sau, mỗi dòng chứa nội dung của một tin nhắn, là một xâu gồm các chữ cái in hoa trong tiếng AnhOutputGồm một số nguyên duy nhất là độ dài tin nhắn kỳ diệu dài nhất tìm được.Giới hạnTrong tất cả các test, 1 &lt;= K &lt;= N &lt;= 50.Trong 20% số test, tổng độ dài các tin nhắn không quá 70.Trong 50% số test, tổng độ dài các tin nhắn không quá 1000.Trong 100% số test, tổng độ dài các tin nhắn không quá 100000.Trong lúc thi bài của bạn chỉ được chấm với test ví dụ.ExampleInput:3 2ABCBBBBCCCACCOutput:2Hướng dẫnhttp://dataurbia.com/RUBCodehttp://dataurbia.com/RUb",
              url: "/spoj/spoj-vo17tv-tin-nhan-ky-dieu"
            }
            ,

            {
              title: "[SPOJ] QBDIVSEQ - Chia dãy",
              author: "Accepted Problems",
              category: ["spoj"],
              tag: ["spoj"],
              content: "Link đề gốc:http://vnoi.info/problems/show/QBDIVSEQ/Đề bài:Dãy số M phần tử B được gọi là dãy con của dãy số A gồm N phần tử nếu tồn tại một mã chuyển C gồm M phần tử thoả mãn B[i]=A[C[i]] với mọi I = 1…M và 1 ≤ C[1] &lt; C[2] &lt; … &lt; C[m] ≤ N.Một cách chia dãy A thành các dãy con “được chấp nhận” nếu các dãy con này là các dãy không giảm và mỗi phần tử của dãy A thuộc đúng một dãy con.Yêu cầu: Bạn hãy chia dãy con ban đầu thành ít dãy con nhất mà vẫn “được chấp nhận”.InputDòng đầu tiên ghi số N là số phần tử của dãy A. ( N ≤ 105)N dòng tiếp theo ghi N số tự nhiên là các phần tử của dãy A. ( Ai≤ 109)OutputGhi một duy nhất là số lượng dãy con ít nhất thỏa mãn.Ví dụ:Input:41546Output:2Solution:Tham khảo tại: http://dataurbia.com/RDHCode:Tham khảo tại: http://dataurbia.com/RF0Code đã được nộp và AC trên SPOJ, sử dụng bộ dịch của C++11",
              url: "/spoj/spoj-qbdivseq-chia-day"
            }
            ,

            {
              title: "[SPOJ] VMRR - RR",
              author: "itsjustwinds",
              category: ["spoj"],
              tag: ["spoj"],
              content: "Đề: http://vnoi.info/problems/show/VMRR/Có một điều bí mật, mà xưa nay chỉ được lưu truyền giữa các admin VNOI, là RR có những sở thích rất khác người. Không chỉ dừng lại ở việc ngồi ngắm bảng rank của các kỳ thi trên mạng hàng tiếng đồng hồ hay ngồi học thuộc tên của các coder nổi tiếng thế giới, RR còn có sở thích tìm tên mình trong những chuỗi văn bản dài…Nhiều khi, việc tìm tên mình mất rất nhiều thời gian, thậm chí có thể tốn nhiều ngày mà vẫn đếm nhầm. Các bạn hãy giúp RR giải quyết vấn đề này một cách tổng quát hơn nhé.Yêu cầuCho một xâu S và 2 ký tự X và Y. Đếm xem chuỗi con XY xuất hiện bao nhiêu lần trong S (hai ký tự X và Y không cần liên tiếp nhưng cần xuất hiện đúng thứ tự (X trước Y)).Input  Dòng 1: Xâu S.  Dòng 2: X và Y.Output  Gồm 1 số nguyên duy nhất là kết quả của bài toán.Giới hạn  Xâu S chứa không quá 10^6ký tự.  Tất cả các ký tự trong đề bài có mã ASCII từ 32 đến 255.Chấm bàiBài của bạn sẽ được chấm trên thang điểm 100. Điểm mà bạn nhận được sẽ tương ứng với % test mà bạn giải đúng.Trong quá trình thi, bài của bạn sẽ chỉ được chấm với 2 test ví dụ có trong đề bài.Khi vòng thi kết thúc, bài của bạn sẽ được chấm với bộ test đầy đủ.ExampleInput 1:R_R_RROutput 1:1Input 2:BAABOutput 2:0Hướng dẫnhttp://dataurbia.com/R4qCodehttp://dataurbia.com/R5Q",
              url: "/spoj/spoj-vmrr-rr"
            }
            ,

            {
              title: "[SPOJ] IOIBIN - Các thùng nước",
              author: "CVHvn",
              category: ["spoj"],
              tag: ["DSU", "SPOJ", "data-structure"],
              content: "Link bài viết: http://vnoi.info/problems/show/IOIBIN/Đề bài:Có N thùng nước được đánh số từ 1 đến N, giữa 2 thùng bất kỳ đều có một ống nối có một van có thể khóa hoặc mở. Ở trạng thái ban đầu tất cả các van đều đóng.Bạn được cho một số yêu cầu, trong đó mỗi yêu cầu có 2 dạng:Dạng X Y 1 có ý nghĩa là bạn cần mở van nối giữa 2 thùng X và Y.Dạng X Y 2 có ý nghĩa là bạn cần cho biết với trạng thái các van đang mở / khóa như hiện tại thì 2 thùng X và Y có thuộc cùng một nhóm bình thông nhau hay không? Hai thùng được coi là thuộc cùng một nhóm bình thông nhau nếu nước từ bình nàycó thể chảy đến được bình kia qua một số ống có van đang mở.InputDòng đầu tiên ghi một số nguyên dương P là số yêu cầu.Trong P dòng tiếp theo, mỗi dòng ghi ba số nguyên dương X, Y, Z với ý nghĩa có yêu cầu loại Z với 2 thùng X và Y.OutputVới mỗi yêu cầu dạng X Y 2 (với Z = 2) bạn cần ghi ra số 0 hoặc 1 trên 1 dòng tùy thuộc 2 thùng X và Y không thuộc hoặc thuộc cùng một nhóm bình.Giới hạn1 ≤ N ≤ 100001 ≤ P ≤ 50000Solution:http://dataurbia.com/OqSCode:http://dataurbia.com/PBz",
              url: "/spoj/spoj-ioibin-cac-thung-nuoc"
            }
            ,

            {
              title: "[SPOJ] KMEDIAN - Above the Median",
              author: "Nicky.Rio",
              category: ["spoj"],
              tag: ["spoj", "bit", "dp"],
              content: "Link gốchttp://vnoi.info/problems/show/KMEDIAN/Đề bài (tiếng Anh, không nói cũng biết =)) )Farmer John has lined up his N (1 ≤ N ≤ 100,000) cows in a row to measure their heights; cow i has height H_i (1 ≤ H_i ≤ 1,000,000,000) nanometers. FJ believes in precise measurements! He wants to take a picture of some contiguous subsequence of the cows to submit to a bovine photography contest at the county fair.The fair has a very strange rule about all submitted photos: a photograph is only valid to submit if it depicts a group of cows whose median height is at least a certain threshold X (1 ≤ X ≤ 1,000,000,000).For purposes of this problem, we define the median of an array A[0…K] to be A[ceiling(K\\/2)] after A is sorted, where ceiling(K/2) gives K/2 rounded up to the nearest integer (or K/2 itself, it K/2 is an integer to begin with). For example the median of {7, 3, 2, 6} is 6, and the median of {5, 4, 8} is 5.Please help FJ count the number of different contiguous subsequences of his cows that he could potentially submit to the photography contest.Input  Line 1: Two space-separated integers: N and X.  Lines 2..N+1: Line i+1 contains the single integer H_i.Output  Line 1: The number of subsequences of FJ’s cows that have median at least X. Note this may not fit into a 32-bit integer.ExampleInput4 6 10 5 6 2 Output7Giải thíchCó 10 dãy con liên tiếp, nhưng chỉ có 7 dãy con thõa mãn có trung vị &gt;= 6. Đó là {10}, {6}, {10, 5}, {5, 6}, {6, 2}, {10, 5, 6}, {10, 5, 6, 2}.Solutionhttp://dataurbia.com/R2FCode mẫuhttp://dataurbia.com/Ql0",
              url: "/spoj/spoj-kmedian-above-the-median"
            }
            ,

            {
              title: "[SPOJ] QBBUILD - Xây dựng đường",
              author: "Joker",
              category: ["spoj"],
              tag: ["spoj", "graph"],
              content: "Link bài gốc:http://vnoi.info/problems/show/QBBUILD/Đề bài:Vua Peaceful vừa khai hoang một vùng đất để lập ra đất nước Peace, lúc đầu chỉ có N thành phố (được đánh số từ 1 đến N) và không có con đường nào.Vua Peace chọn ra 4 thành phố đặc biệt để làm trung tâm kinh tế và 4 thành phố này phải được liên thông với nhau. Chi phí xây dựng các con đường không phải nhỏ vì thế nhà vua muốn sử dụng chi phí ít nhất để xây dựng các con đường sao cho 4 thành phố đặc biệt đó vẫn liên thông.Bạn được biết chi phí ước tính để xây dựng một số con đường và bạn hãy chọn một số con đường để xây dựng để theo đúng ý nhà vua biết rằng luôn tồn tại ít nhất một phương án xây dựng đường sao cho 4 thành phố đặc biệt liên thông.InputDòng đầu tiên ghi số nguyên dương N là số lượng các thành phố.( 1 ≤ N ≤ 100 )Dòng thứ hai ghi 4 số nguyên là số hiệu của 4 thành phố đặc biệt.Trong một số dòng tiếp theo, mỗi dòng ghi 3 số nguyên u, v và c với ý nghĩa muốn xây dựng một con đường hai chiều nối trực tiếp giữa 2 thành phố u và v thì chi phí là c. ( 1 ≤ c ≤ 5000 )OutputGồm 1 dòng duy nhất là tổng chi phí nhỏ nhất để xây dựng hệ thống đường.Ví dụ:Input:52 3 4 11 2 101 5 15 2 11 4 14 3 33 2 2Output:5Solution:Tham khảo tại:http://dataurbia.com/PUBCode:Tham khảo tại: http://dataurbia.com/PQd",
              url: "/spoj/spoj-qbbuild-xay-dung-duong"
            }
            ,

            {
              title: "[SPOJ] MROADS - Roads Repair",
              author: "Nicky.Rio",
              category: ["spoj"],
              tag: ["spoj", "tree", "dfs", "deque", "binary-search", "dp"],
              content: "Link gốchttp://vnoi.info/problems/show/MROADS/Đề bàiCó N thành phố và N-1 cặp đường nối chúng, có duy nhất 1 đường nối 2 thành phố khác nhau.Đường đã bị xuống cấp và với mỗi đường ta biết 2 số A, B : A(s) thời gian để đi qua đường này và B(s) là thời gian ít nhất để đi qua đường này nếu nâng cấp hết cả đường.Có 1 lượng tiền đầu tư để sửa đường, với mỗi đoạn đường, kết quả sẽ tỉ lệ với lượng tiền đầu tư. Đầu tư 1 euro cho 1 đoạn đường sẽ giảm thời gian trên đoạn đường đó đi 1s. Tuy nhiên nó không thể giảm quá thời gian tối thiểu B của đoạn đường này.Cần phân bố lượng tiền trên cho các đoạn đường khác nhau để thời gian cần thiết đi từ thành phố 1 tới thành phố xa nhất (đi mất nhiều thời gian nhất sau khi thực hiện mọi sửa chữa) là nhỏ nhất có thể.Xác định thời gian nhỏ nhất này.InputDòng đầu gồm 2 số nguyên N và K, 2 ≤ N ≤ 100 000, 0 ≤ K ≤ 1 000 000, số thành phố và lượng tiền (euros)Sau đó là N-1 dòng, mỗi dòng 4 số nguyên X, Y, A và B, 0 ≤ B ≤ A ≤ 10 000. Nghĩa là có đường đi từ nối X và Y với 2 thông tin A và B như trên.OutputThời gian nhỏ nhất cần tìm theo yêu cầu đề bài.SampleInput 13 200 1 2 200 100 2 3 450 250Output 1450Input 25 11 1 2 10 5 1 3 3 2 1 4 9 6 3 5 7 3Output 26Input 311 12 1 2 7 5 1 3 20 15 2 4 10 8 2 5 5 3 2 6 6 2 4 7 3 0 4 8 7 2 5 9 8 4 5 10 9 8 5 11 6 5 Output 317Solutionhttp://dataurbia.com/PguCode mẫuhttp://dataurbia.com/PEA",
              url: "/spoj/spoj-mroads-roads-repair"
            }
            ,

            {
              title: "[SPOJ] BARICAVN - BARICA ",
              author: "G",
              category: ["spoj"],
              tag: ["spoj", "sorting"],
              content: "Link đề gốc: http://vnoi.info/problems/show/BARICAVNĐề bài:  Barica là một con cóc không bình thường. Barica sống trong một cái ao, nơi có N lá sen bềnh bồng trên mặt nước. Những lá sen được đánh số từ 1 đến N. Nhìn từ trên xuống, mỗi lá sen đc xem như một điểm trên hệ trục tọa độ Oxy. Barica có thể nhảy từ lá sen có tọa độ (x1;y1) đến tọa độ (x2,y2) nếu:  x2 &gt; x1 và y1 = y2 hoặc  y2 &gt; y1 và x1 = x2  Với mỗi lá sen, chúng ta biết được số lượng ruồi gần đó. Barica có thể dùng lưỡi tóm gọn tất cả những con ruồi gần lá sen mà nó đang đứng.Barica thu được một đơn vị năng lượng với mỗi con ruồi mà nó bắt được và mất K đơn vị năng lượng cho mỗi bước nhảy từ lá sen này sang lá sen khác. Barica không thể thực hiện cú nhảy nếu năng lượng hiện tại của nó nhỏ hơn K.  Barica muốn đi từ lá sen 1 đến lá sen N và tích trữ được nhiều năng lượng nhất có thể khi đang ở lá sen N. Năng lượng của Barica ban đầu bằng 0 và dĩ nhiên nó phải lấy năng lượng từ lá sen 1 để thực hiện cú nhảy.Hãy tìm năng lượng lớn nhất mà Barica có thể có được tại lá sen N.Dữ liệu :  Dòng đầu là số N và K (N &lt;= 300 000; K &lt;= 1000) cách nhau bởi khoảng trắng  N dòng sau mỗi dòng chứa 3 số x_i, y_i, F_i với x_i và y_i là tọa độ lá sen thứ i và F_i là số ruồi ở lá sen i. (0 &lt;= x_i, y_i &lt;= 100 000; 0 &lt;= F_i &lt;= 1000)  Lưu ý: không có hai lá sen nào trùng tọa độ và luôn tồn tại ít nhất một đường đi từ 1 tới N.Kết quả :  Một dòng duy nhất là năng lượng cao nhất mà Barica có thể có được khi kết thúc ở lá sen thứ N.Solution :HereCode :Here",
              url: "/spoj/spoj-baricavn-barica"
            }
            ,

            {
              title: "[SPOJ] NKPOS - Người đưa thư",
              author: "Nguyễn Minh Quân",
              category: ["spoj"],
              tag: ["spoj", "graph"],
              content: "Link đề gốc: http://vnoi.info/problems/show/NKPOS/Đề bàiMột bưu tá ở vùng quê cần chuyển thư cho người dân ở các ngôi làng cũng như ở trên các con đường nối giữa các ngôi làng. Bạn cần giúp bưu tá tìm hành trình đi qua mỗi ngôi làng và mỗi con đường ít nhất một lần (dữ liệu vào đảm bảo một hành trình như vậy tồn tại). Tuy nhiên, mỗi hành trình còn được gắn với một chi phí. Người dân ở các ngôi làng đều muốn bưu tá đến làng mình càng sớm càng tốt. Vì vậy mỗi ngôi làng đã thỏa thuận với bưu điện, nếu làng i là làng thứ k phân biệt được thăm trên hành trình và k ≤ wi, làng i sẽ trả wi– k euros cho bưu điện. Nếu k &gt; wi, bưu điện đồng ý trả k - wieuros cho ngôi làng. Ngoài ra, bưu điện còn trả bưu tá một euro khi đi qua mỗi con đường trên hành trình.Có n ngôi làng, được đánh số từ 1 đến n. Bưu điện được đặt ở ngôi làng số một, do đó hành trình cần bắt đầu và kết thúc tại ngôi làng này. Mỗi ngôi làng được đặt ở giao điểm của hai, bốn, hoặc tám con đường. Có thể có nhiều đường nối giữa hai ngôi làng. Con đường có thể là một vòng nối một ngôi làng với chính nó.Yêu cầu: Viết chương trình xác định một hành trình đi qua mỗi ngôi làng và mỗi con đường ít nhất một lần, sao cho tổng lợi nhuận của bưu điện là lớn nhất (hay tổng thiệt hại là bé nhất).Dữ liệu  Dòng đầu tiên chứa 2 số nguyên n, m, cách nhau bởi khoảng trắng; n (1 ≤ n ≤ 200), là số ngôi làng và m là số con đường.  Mỗi dòng trong số n dòng sau chứa một số nguyên dương. Dòng thứ i+1 chứa số wi, 0 ≤ wi≤ 1000, xác định chi phí được trả bởi làng i.  Mỗi dòng trong số m dòng sau chứa hai số nguyên dương cách nhau bởi khoảng trắng, mô tả một con đường nối hai ngôi làng.Kết qủa  Dòng đầu tiên chứa số nguyên dương k, độ dài của hành trình.  Dòng thứ hai theo chứa k+1 số cho biết các ngôi làng được thăm theo thứ tự trên hành trình, cách nhau bởi khoảng trắng, trong đó v1=vk+1=1.SolutionHereCode mẫuHere",
              url: "/spoj/spoj-nkpos-nguoi-dua-thu"
            }
            ,

            {
              title: "[SPOJ] QBGAME - Trò chơi trên ma trận",
              author: "Joker",
              category: ["spoj"],
              tag: ["spoj", "bitmask"],
              content: "Link bài gốc:http://vnoi.info/problems/show/QBGAME/Đề bài:Ngày nay các nhà khoa học đã nghĩ ra 1 trò chơi trên ma trận rất thú vị. Thông qua đó có thể đo IQ một cách khá hiệu quả. Trò chơi được mô tả như sau:Bạn có 1 ma trận A kích thước 8 x N trên đó gồm các số nguyên là điểm của các ô đó. Người ta sẽ yêu cầu bạn chọn 1 tập khác rỗng các ô trên ma trận này sau đó tính tổng điểm trên những ô này. Trong những ô được chọn không có hai ô nào kề cạnh. IQ của người chơi sẽ tỉ lệ thuận với số điểm nhận được. Sherry tham gia trò chơi và đạt kết quả khá tốt.Và bây giờ Sherry muốn biết tổng điểm lớn nhất nhận được trong trò chơi này là bao nhiêu. Bạn hãy giúp sherry nhé !!!InputDòng 1 là số nguyên N ( 1 &lt;= N &lt;= 10000 )8 dòng tiếp theo: Mỗi dòng gồm n số nguyên. Số nguyên ở hàng i, cột j là Aij( |Aij| &lt;= 108)OutputGồm 1 dòng duy nhất là số điểm lớn nhất tìm được.Ví dụ:Input:2-22 2-33 4556 -60-8 -3879 66-10 -2399 461 -55Output279Solution:Tham khảo tại: http://dataurbia.com/KVDCode:Tham khảo tại: http://dataurbia.com/KQQ",
              url: "/spoj/spoj-qbgame-tro-choi-tren-ma-tran"
            }
            ,

            {
              title: "[SPOJ] NETWRKNB - Mạng máy tính",
              author: "La Hoàng Phong",
              category: ["spoj"],
              tag: ["data-structure", "dfs"],
              content: "Link đề bài gốc : http://vnoi.info/problems/show/NETWRKNB/Đề bài :Những ngày nghỉ tại NTU là thời gian để ANHNT ngẫm nghĩ về các cấu trúc mạng máy tính. Mạng mà ANHNT đang nghiên cứu gồm có 𝑛 máy tính đánh số từ 1 tới 𝑛 và 𝑛 − 1 dây cáp mạng đánh số từ 1 tới 𝑛 − 1. Dây cáp thứ 𝑖 nối giữa hai máy tính 𝑢𝑖 , 𝑣𝑖 và cho phép truyền tin giữa hai máy này theo cả hai chiều với độ tin cậy là 𝑤𝑖 .Ta nói máy 𝑠 và máy 𝑡 có thể truyền tin cho nhau nếu như tồn tại đường truyền tin là dãy 𝑠 =𝑥1, 𝑥2, … , 𝑥𝑘 = 𝑡 sao cho các máy 𝑥1, 𝑥2, … , 𝑥𝑘 hoàn toàn phân biệt và giữa máy 𝑥𝑖 và 𝑥𝑖+1 có cáp nối trựctiếp (∀𝑖 = 1,2, … , 𝑘 − 1). Mạng đảm bảo việc truyền tin giữa hai máy bất kỳ.ANHNT đang loay hoay trả lời 𝑚 câu hỏi, mỗi câu hỏi thuộc một trong hai dạng:      𝑃 𝑎 𝑏 𝑐: Cần cho biết trên đường truyền tin từ máy a tới máy b có bao nhiêu cáp nối mà độ tin cậy nhỏ hơn hoặc bằng c        𝑇 𝑘 𝑐: Cần cho biết nếu cắt bỏ dây cáp thứ k thì trong số những dây cáp có thể truyền tin từ máy 𝑣𝑘, có bao nhiêu cáp nối mà độ tin cậy nhỏ hơn hoặc bằng c  Yêu cầu:Cho mạng máy tính, và danh sách các câu hỏi, hãy giúp ANHNT trả lời tất cả các câu hỏi đó.Dữ liệu:Vào từ file văn bản NETWORK.INP:      Dòng 1 chứa hai số nguyên dương 𝑛, 𝑚 ≤ 105    𝑛 − 1 dòng tiếp theo, dòng thứ 𝑖 chứa ba số nguyên dương 𝑢𝑖, 𝑣𝑖, 𝑤𝑖(∀𝑖: 1 ≤ 𝑢𝑖, 𝑣𝑖 ≤ 𝑛; 𝑤𝑖 ≤ 109)      𝑚 dòng tiếp theo mỗi dòng ghi một câu hỏi, ký tự đầu dòng ∈ {𝑃, 𝑇} cho biết loại câu hỏi          Nếu ký tự đầu dòng là 𝑃, tiếp theo là ba số nguyên dương 𝑎, 𝑏, 𝑐 ứng với dạng câu hỏi 𝑃 𝑎 𝑏 𝑐(1 ≤ 𝑎, 𝑏 ≤ 𝑛; 𝑐 ≤ 10^9)      Nếu ký tự đầu dòng là 𝑇, tiếp theo là hai số nguyên dương 𝑘, 𝑐 ứng với dạng câu hỏi 𝑇 𝑘 𝑐 (1 ≤𝑘 &lt; 𝑛; 𝑐 ≤ 10^9)      Các số trên một dòng của input file được ghi cách nhau bởi dấu cách.Kết quả :Ghi ra file văn bản NETWORK.OUT 𝑚 dòng, mỗi dòng ghi một số nguyên duy nhất là đáp số chomột câu hỏi theo đúng thứ tự đã cho.Ví dụNETWORK.INP6 31 2 12 3 22 4 44 5 34 6 5P 1 5 3T 1 4T 5 1NETWORK.OUT23050% số điểm ứng với các test có 𝑛, 𝑚 ≤ 200050% số điểm ứng với các test có 𝑛, 𝑚 ∈ [20000,100000]Solution :Tham Khảo Tại : http://dataurbia.com/Kt8Code :Tham Khảo Tại : http://dataurbia.com/Kwp",
              url: "/spoj/spoj-netwrknb-mang-may-tinh"
            }
            ,

            {
              title: "[SPOJ] KQUERY - K-query ",
              author: "La Hoàng Phong",
              category: ["spoj"],
              tag: ["spoj", "data-structure"],
              content: "Link đề bài gốc : http://www.vnoi.info/problems/show/KQUERY/Đề bài :Truy vấn-kCho một dãy n phần tử a1, a2, …, anvà một số các truy vấn-k. Một truy vấn-k là một bộ ba (i, j, k) (1 ≤ i ≤ j ≤ n). Với mỗi truy vấn-k (i, j, k), bạn phải trả về số phần tử lớn hơn k nằm trong dãy con ai, ai+1, …, aj.Dữ liệu  Dòng 1: n (1 ≤ n ≤ 30000).  Dòng 2: n số a1, a2, …, an(1 ≤ ai≤ 10^9).  Dòng 3: q (1 ≤ q ≤ 200000), số truy vấn-k.  Trong q dòng tiếp theo, mỗi dòng chứa 3 số i, j, k thể hiện một truy vấn-k (1 ≤ i ≤ j ≤ n, 1 ≤ k ≤ 10^9).Kết quả  Với mỗi truy vấn-k (i, j, k), in ra số phần tử lớn hơn k trong dãy con ai, ai+1, …, aj trên một dòng.Ví dụDữ liệu55 1 2 3 432 4 14 4 41 5 2 Kết quả203 Solution :Tham khảo tại : http://dataurbia.com/2pHCode :Tham khảo tại : http://dataurbia.com/2sa",
              url: "/spoj/spoj-kquery-k-query"
            }
            ,

            {
              title: "[C++ Cơ bản] Phần 1: Bản chất của lập trình",
              author: "Admin Tổng Quản",
              category: ["article"],
              tag: ["cpp-cơ-bản", "programming"],
              content: "Phần trước: [C++ Cơ bản] Phần 0: Giới thiệu series bài viếtTrước khi bắt đầu vào nội dung chính của series, mình muốnnói qua một chút về bản chất của công việc lập trình, hay cụ thể hơn là Làm thế nào mà máy tính của bạn hiểu đượcchương trình của bạn.Câu trả lời ngắn: Chương trình máy tính đưa ra chỉ thị đểmáy tính của bạn làm việc. Câu trả lời này đúng, nhưng nếu chỉ tới đó thôi thìchưa đủ để giải thích nhiều hiện tượng trong lập trình.Câu trả lời dài sẽ là như thế này:Máy tính của bạn chỉ hiểu được đúng hai trạng thái bật và tắt.Một chiếc máy tính thật ra chỉ là một tập hợp tầm vài tỷ transistor, và bất cứnhững gì nó có thể làm được đều là nhờ việc bật tắt các transistor một cách hợplý. Chúng ta sử dụng mã nhị phân (binary code) 0 và 1 để mã hóa các trạng tháibật và tắt đó - mỗi tập hợp 8 bit 0 - 1 sẽ tương ứng với 8 transistor và bằng 1byte.Tất nhiên, vấn đề nảy sinh là chúng ta không thể viết hết chỗbinary code bằng sức trâu được. Và đây lý do tại sao các ngôn ngữ lập trình rađời.Ngôn ngữ lập trìnhĐây là ví dụ cho một đoạn code C++#include &lt;iostream&gt;using namespace std;int main(){    cout &lt;&lt; \"Hello World!\";    return 0;}Định nghĩa đơn giản thì một ngôn ngữ lập trình là một tập hợpcác quy tắc ngữ pháp quy định cách viết code theo ngôn ngữ đó. Hàng nghìn ngônngữ lập trình ra đời giúp cho chúng ta có thể viết ra ứng dụng, trang web, chếtạo robot, vân vân… một cách đơn giản và tiện lợi thay vì phải đụng chạm tớibinary code.Ngôn ngữ bậc thấp và ngôn ngữ bậc caoNgôn ngữ bậc thấp thì đơn giản và gần hơn so với binarycode, trong khi ngôn ngữ bậc cao lại phức tạp hơn và có nhiều tính năng hơn.Ngôn ngữ bậc thấp viết ra chương trình chạy nhanh hơn, trong khi ngôn ngữ bậccao thì dễ viết hơn vì chúng gần gũi hơn với ngôn ngữ tự nhiên của con người.Phần lớn ngôn ngữ lập trình dùng trong sản xuất là ngôn ngữbậc cao. C++ được đánh giá là ngôn ngữ bậc trung, vì nó bao gồm tính năng của cảhai chuẩn ngôn ngữ trên.Tại sao chúng ta có nhiều ngôn ngữ lập trình đến thế?Lý do đầu tiên, đó là do mỗi ngôn ngữ có điểm mạnh và điểm yếucủa nó. Ruby và Javascript thích hợp cho việc phát triển website. Java và C++thường được sử dụng cho việc phát triển ứng dụng kinh doanh - kiểm toán. Pythonvà R được sử dụng trong phân tích dữ liệu, vân vân…Lý do thứ hai, một ngôn ngữ phát triển được là nhờ có cộng đồngxung quanh hộ trợ cho nó. Stack Overflow sử dụng C#, vì đó là ngôn ngữ mà cácnhà sáng lập ra trang web biết. Các ngôn ngữ như Java hay C++ được sử dụng nhiều,bởi vì có một số lượng khổng lồ thư viện và công cụ xây dựng xung quanh chúng,bởi những người sử dụng chúng. Các tổ chức và công ty công nghệ cũng chi tiền đểđầu tư cho các ngôn ngữ lập trình của riêng họ. Kết quả là số lượng ngôn ngữ lậptrình ngày càng gia tăng.Lý do cuối cùng, đó là sở thích của mỗi lập trình viên. Ngônngữ lập trình suy cho cùng cũng là một ngôn ngữ để con người diễn đạt ý tưởng củamình cho máy tính hiểu. Chỉ riêng với công việc làm web thôi, bạn có thể sử dụngRuby, Java, Python, C#, Go, JavaScript, nhiều lắm… Mỗi người có một khẩu vịkhác nhau, và điều đó giúp cho các ngôn ngữ lập trình đa dạng hơn.Chương trìnhMột chương trình máy tính thực chất chỉ là một file văn bản,được viết bằng một ngôn ngữ lập trình. Đoạn code trong chương trình máy tính đượcgọi là mã nguồn (source code). Mỗi ngôn ngữ lập trình có một số định dạng mở rộngnhất định cho file chương trình của mình, ví dụ như .cpp của C++ hoặc .py củaPython.Để viết một file chương trình, bạn chỉ cần một chương trìnhsoạn thảo văn bản đơn giản (như Notepad – trình soạn thảo văn bản cài sẵn trên hệđiều hành Windows), viết source code vào đó và lưu lại ở định dạng tương ứng.Trong lập trình thực tế, chúng ta sử dụng các IDE (Integrated development environment, phần mềmmôi trường phát triển tích hợp) để viết chương trình một cách tiện lợi. Cácchương trình IDE thường tích hợp các tính năng như trình dịch chương trình(complier), trình debug, gợi ý cú pháp, vân vân… ngay trong chương trình để ngườidùng có thể soạn thảo chương trình dễ dàng hơn. Một số IDE nổi tiếng bao gồmVisual Studio của Microsoft, IntelliJ IDEA hay PyCharm của JetBrains, vv…Trong series bàiviết này, chúng ta sử dụng Code::Blocks IDE để viết chương trình C++.Làm sao để chạy các chương trình được viết ra?Điều này tùy vàotừng ngôn ngữ lập trình. Ví dụ, một chương trình JavaScript sẽ được chạy trựctiếp trên các trình duyệt như Chrome, chương trình PHP sẽ được chạy trên web servernhư LAMP, trong khi chương trình C++ sau khi được biên dịch (comply) sẽ trởthành một file chương trình mà hệ điều hành có thể sử dụng ngay được (như file.exe đối với Windows).Chuyện gì xảy ra khi chương trình được chạy?Như đã nói ởtrên, chương trình máy tính không hiểu trực tiếp ngôn ngữ lập trình. Khi ta chạymột chương trình, máy tính sẽ phải:1.      Dịchchương trình máy tính từ ngôn ngữ lập trình sang ngôn ngữ Assembly. Assembly làmột ngôn ngữ lập trình ở mức độ cực thấp, sử dụng các từ ngữ và số để biểu diễncác dãy bit. Tùy vào ngôn ngữ, bước này sẽ được thực hiện bởi một trình biên dịch(complier) - chương trình dịch toàn bộ file lệnh cùng một lúc - hoặc thông dịch(interpreter) - chương trình dịch từng dòng code một, theo thời gian thực.2.      Dịchtừ ngôn ngữ Assembly sang ngôn ngữ máy. Ngôn ngữ máy là một loạt các chỉ thị đượcxử lý trực tiếp bởi CPU của thiết bị để thực hiện các hành động trên máy.3.      Dịchtừ ngôn ngữ máy sang binary code.Điều thú vị của quá trình này là nó đảm bảo rằng công việc lập trình sẽ không bao giờ biến mất, ngay kể cả khi chúng ta có những trí tuệ nhân tạo có khả năng viết thuật toán tốt hơn con người. Ngay kể cả khi điều đó xảy ra, mọi thứ cũng chỉ giống như khi chúng ta di chuyển từ ngôn ngữ bậc thấp lên ngôn ngữ bậc cao - con người vẫn sẽ là tác nhân giải thích và quyết định chức năng của phần mềm, dù cho là bằng ngôn ngữ lập trình hay bằng ngôn ngữ con người đi chăng nữa.Bài viết có dựa vào nguồn tham khảo tại http://www.codeconquest.com/what-is-coding/how-does-coding-work/và https://stackoverflow.blog/2015/07/29/why-are-there-so-many-programming-languages/Phần sau: [C++ Cơ bản] Phần 2: Giới thiệu về C++",
              url: "/article/c-co-ban-phan-1-ban-chat-cua-lap-trinh"
            }
            ,

            {
              title: "[C++ Cơ bản] Phần 0: Giới thiệu series bài viết",
              author: "Admin Tổng Quản",
              category: ["article"],
              tag: ["cpp-cơ-bản", "programming"],
              content: "“Từ IOI 2019 là sẽkhông được sử dụng Pascal rồi, phải làm sao đây??”“Đăng ký nhập học Côngnghệ thông tin rồi, nhưng không biết tí gì về lập trình cả, phải làm sao đây??”Thì tiếp thu cái mới chứ sao.Đó là bản chất của ngành Công nghệ thông tin rồi - công nghệluôn thay đổi và bạn phải liên tục đón nhận cái mới để không trở nên lỗi thời.“Nhưng giờ phải bắt đầu từ đâu?”Bài viết này là bài viết đầu tiên trong series C++ Cơ bản, vớimục đích hỗ trợ các bạn nắm được những kiến thức nền tảng của một trong nhữngngôn ngữ lập trình được sử dụng nhiều nhất trên thế giới. Series này nhắm tớinhững người chưa có kiến thức về lập trình, hoặc có một chút ít kinh nghiệm vớilập trình máy tính. Qua series này, các bạn sẽ học được:  C++ là gì và có ứng dụng như thế nào.  Cách viết một chương trình C++ cơ bản.  Thư viện chuẩn của C++ (STL) là gì? Một số template quan trọng của STL.  Lập trình hướng đối tượng là gì? Làm sao để lập trình hướng đối tượng với C++?  Ứng dụng C++ vào lập trình ứng dụng thực tế.Tuy tác giả bài viết đã cố gắng hết sức, song vẫn có thể cónhiều thiếu sót, hy vọng sẽ nhận được sự đóng góp của bạn đọc để các bài viết củamình trở nên chất lượng và hữu dụng hơn cho mọi người. :)Series bài viết có tham khảo nội dung từ trang tutorialspoint.com và Wikipedia.Phần sau: [C++ Cơ bản] Phần 1: Bản chất của lập trình",
              url: "/article/c-co-ban-phan-0-gioi-thieu-series-bai-viet"
            }
            ,

            {
              title: "[SPOJ] COND - Quan hệ",
              author: "Accepted Problems",
              category: ["spoj"],
              tag: ["spoj"],
              content: "Link đề gốc:http://vnoi.info/problems/show/COND/Đề bài:Xét một tập N đối tượng có thể so sánh được (2&lt;=n&lt;=10). Giữa 2 đối tượng a và b có thể tồn tại 1 trong 3 quan hệ phân loại:a = b; a &lt; b; a &gt; b;Như vậy, với 3 đối tượng (a, b, c) có thể tồn tại 13 quan hệ phân loại như sau:a = b = c; a = b &lt; c; c &lt; a = b; a &lt; b = cb = c &lt; a; a = c &lt; b; b &lt; a = c; a &lt; b &lt; ca &lt; c &lt; b; b &lt; a &lt; c; b &lt; c &lt; a; c &lt; a &lt; bc &lt; b &lt; a;Cho số n, hãy xác định số lượng quan hệ phân loại khác nhau.InputGồm nhiều số n. Mỗi số trên 1 dòng. Kết thúc file là -1.OutputVới mỗi n, đưa ra số lượng quan hệ phân loại tìm được, mỗi số trên 1 dòng (không có dòng trống).Ví dụInput:23-1Output:313Solution:Tham khảo tại: http://dataurbia.com/GBaCode:Tham khảo tại: http://dataurbia.com/G5t(Code đã được nộp và AC trên SPOJ, sử dụng bộ dịch của C++11)",
              url: "/spoj/spoj-cond-quan-he"
            }
            ,

            {
              title: "[SPOJ] VECTOR - Tổng vector",
              author: "Accepted Problems",
              category: ["spoj"],
              tag: ["spoj", "dp"],
              content: "Link đề bài gốc:http://vnoi.info/problems/show/VECTOR/Đề bài:Trong mặt phẳng tọa độ có N véc tơ. Mỗi một véc tơ được cho bởi hai chỉ số x và y. Tổng của hai véc tơ (xi, yi) và (xj, yj) được định nghĩa là một véc tơ (xi+ xj, yi+ yj). Bài toán đặt ra là cần chọn một số véc tơ trong N véc tơ đã cho sao cho tổng của các vec tơ đó là véc tơ (U, V).Yêu cầu: Đếm số cách chọn thoả mãn yêu cầu bài toán đặt ra ở trên.InputDòng thứ nhất ghi số N (0 ≤ N ≤ 30).N dòng tiếp theo, dòng thứ i ghi các số nguyên xi, yi lần lượt là hai chỉ số của véc tơ thứ i. (|xi|, |yi| ≤ 100).Dòng cuối cùng ghi số hai số nguyên U V (|U|, |V| ≤ 109).OutputGồm một số duy nhất là số cách chọn thoả mãn.Ví dụ:Input:40  0-1  22  53  32  5Output:4Solution:Tham khảo tại: http://dataurbia.com/FlkCode:Tham khảo tại: http://dataurbia.com/Fkv(Code đã được nộp và AC trên SPOJ, sử dụng bộ dịch của C++11)",
              url: "/spoj/spoj-vector-tong-vector"
            }
            ,

            {
              title: "[SPOJ] NKLEAVES - Leaves",
              author: "Nguyễn Minh Quân",
              category: ["spoj"],
              tag: ["spoj", "dp", "geometry"],
              content: "Link đề gốc: http://vnoi.info/problems/show/NKLEAVES/Một ngày thu đẹp trời, Radu và Mars nhận ra rằng khu vườn của họ chứa đầy lá rụng. Họ quyết định gom lá thành đúng K đống lá.Biết rằng khu vườn có dạng một đường thẳng. 2 người đã thiết lập một hệ tọa độ với gốc ở điểm đầu của khu vườn.Có N chiếc lá nằm thẳng hàng với trọng lượng khác nhau, khoảng cách giữa 2 chiếc lá liên tiếp là 1. Nghĩa là, chiếc lá đầu tiên có tọa độ 1, chiếc lá thứ 2 có tọa độ 2,…, chiếc lá thứ N có tọa độ N. Ban đầu, 2 người đang đứng ở tọa độ N.Radu và Mars thực hiện việc gom lá trong khi rời khỏi khu vườn, do đó những chiếc lá chỉ có thể di chuyển về bên trái. Chi phí di chuyển một chiếc lá bằng tích của trọng lượng chếc lá và khoảng cách di chuyển. Hiển nhiên, một trong K đống lá sẽ nằm ở tọa độ 1, tuy nhiên những đống còn lại có thể nằm ở bất kỳ vị trí nào.Yêu cầu: tìm chi phí nhỏ nhất để gom N chiếc lá thành đúng K đống lá.Dữ liệu  Dòng đầu tiên chứa 2 số nguyên dương N và K, cách nhau bởi 1 khoảng trắng.  Dòng thứ i trong số N dòng tiếp theo chứa 1 số nguyên dương cho biết trọng lượng của chiếc lá thứ i.Kết quảIn ra 1 số nguyên là chi phí nhỏ nhất để gom N chiếc lá lại thành đúng K đống lá.Giới hạn  0 &lt; N ≤ 100000  0 &lt; K ≤ 10, K &lt; N  Trọng lượng của mỗi chiếc lá không vượt quá 1000.SolutionHereCode mẫuHere",
              url: "/spoj/spoj-nkleaves-leaves"
            }
            ,

            {
              title: "[SPOJ] RELINETS - Reliable Nets",
              author: "houtaru",
              category: ["spoj"],
              tag: ["spoj", "bitmask", "dsu", "graph"],
              content: "Link đề bài: http://www.vnoi.info/problems/show/RELINETS/Đề bài:Cho đồ thị n đỉnh m cạnh mỗi cạnh có trọng số c. Bạn phải tạo 1 đồ thị sao cho bỏ đi 1 cạnh bất kì đồ thị vẫn liên thông. trọng số của đồ thị = tổng các trọng số cạnh. Tính trọng số bé nhất của đồ thị đảm bảo yêu cầu bài toán.Input:Gồm nhiều test case:n, m - số đỉnh và số cạnh. m = n = 0 =&gt; kết thúc bộ test.m dòng tiếp theo, u - v - w là cạnh nối đỉnh u - v có trọng số wOutput:Mỗi test case gồm 1 dòng : Nếu có đáp án thì xuất : “The minimal cost for test case p is c.” - p là thứ tự của test case, c là đáp án của bài toán. Ngược lại, xuất : “There is no reliable net possible for test case p.”.Giới hạn:n &lt;= 15, m &lt;= 20Solution: http://dataurbia.com/5x3Code: http://dataurbia.com/5y8",
              url: "/spoj/spoj-relinets-reliable-nets"
            }
            ,

            {
              title: "[SPOJ] NETACCEL - Tăng tốc mạng máy tính",
              author: "houtaru",
              category: ["spoj"],
              tag: ["spoj", "dijkstra"],
              content: "Link bài gốc : http://vnoi.info/problems/show/NETACCEL/Đề bài :Cho mạng máy tính gồm N máy và M liên kết hai chiều giữa các máy. Các máy được đánh số từ 1 đến N. Máy của Bờm là máy 1 còn máy của Cuội là máy N. Mỗi đường nối cần tốn một giá trị thời gian khác nhau để dữ liệu truyền qua. Tốc độ kết nối giữa hai máy là độ dài đường truyền dữ liệu ngắn nhất giữa hai máy đó.Tốc độ kết nối của mạng khá chậm khiến Bờm và Cuội không thể chơi Dota được, do đó Bờm quyết định mua K thiết bị tăng tốc mạng. Thiết bị tăng tốc mạng được gắn vào các đường truyền dữ liệu giữa hai máy. Mỗi thiết bị sẽ làm giảm thời gian truyền dữ liệu của đường truyền đi một nửa.Hãy giúp Bờm đặt các thiết bị tăng tốc sao cho tốc độ kết nối giữa máy của Bờm và Cuội là nhanh nhất có thể để hai bạn có thể chơi Dota mà không bị lag!Dữ liệuDòng đầu chứa 3 số N, M, K.M dòng tiếp theo, mỗi dòng chứa 3 số x, y, c mô tả một đường truyền dữ liệu: x, y là số hiệu của hai máy tính, còn c là thời gian truyền dữ liệu.Giới hạn1 &lt;= N &lt;= 10001 &lt;= M &lt;= 100,0001 &lt;= K &lt;= 101 &lt;= c &lt;= 1,000,000Kết quảIn ra 1 số duy nhất là tốc độ kết nối nhanh nhất có thể sau khi đã lắp đặt các thiết bị tăng tốc, làm tròn đến 2 chữ số thập phân.Solution : http://simizer.com/qKVCode : http://simizer.com/qJk",
              url: "/spoj/spoj-netaccel-tang-toc-mang-may-tinh"
            }
            ,

            {
              title: "[SPOJ] CHAIN - Strange Food Chain",
              author: "houtaru",
              category: ["spoj"],
              tag: ["spoj", "dsu", "data-structure"],
              content: "Link bài gốc : http://www.vnoi.info/problems/show/CHAIN/Đề bài :Cho 3 loại động vật A, B, C. A ăn B, B ăn C, C ăn A.Có n con vật, mỗi con là 1 trong 3 loại trên.Có 2 thông tin :  1 x y : x, y chung 1 loại  2 x y : x ăn yCác thông tin có thể đúng hoặc sai. Thông tin bị sai khi là 1 trong các trường hợp sau:  x hoặc y &gt; n  x có thể ăn x  thông tin này xung đột với các thông tin đúng khác.Input :  Dòng đầu tiên là t - số testcase  t dòng tiếp theo : gồm n, k - số loại động vật, số thông tin. k dòng tiếp theo là 3 số D x, y (1 &lt;= D &lt;= 2) là các thông tin.Output :Gồm t dòng, mỗi dòng là số thông tin bị sai.Solution : http://simizer.com/vNoCode : http://simizer.com/vYb",
              url: "/spoj/spoj-chain-strange-food-chain"
            }
            ,

            {
              title: "[SPOJ] PBCDEM - Đếm dãy",
              author: "houtaru",
              category: ["spoj"],
              tag: ["spoj", "bignum", "dp"],
              content: "Link bài gốc : http://vnoi.info/problems/show/PBCDEM/Đề bài :Đếm số dãy tăng dần(độ dài dãy phải &gt;=2)có các phần tử nguyên dương mà tổng đúng bằng nGiới hạnn&lt;=4000Dữ liệu vàoGhi duy nhất số nDữ liệu raGhi ra số cách.Solution : http://simizer.com/q8HCode : http://simizer.com/q9D",
              url: "/spoj/spoj-pbcdem-dem-day"
            }
            ,

            {
              title: "[SPOJ] MILITARY - Câu chuyện người lính",
              author: "Nicky.Rio",
              category: ["spoj"],
              tag: ["spoj", "convex-hull"],
              content: "Link gốchttp://vnoi.info/problems/show/MILITARY/Đề bài“Tôi vẫn nhớ chiến trường Điện Biên năm đó rất ác liệt, rất nhiều người lính đã ngã xuống. Tại vùng căn cứ này, địch cho xây dựng lô cốt, hàng rào dây thép gai rất nhiều , vòng trong nối vòng ngoài, tạo thành nhiều vòng bảo vệ … “Đó là dòng hồi tưởng của 1 người lính già đã từng tham gia chiến dịch Tây Bắc lịch sử. Lần theo những trang sử được ghi chép lại, người ta biết rằng tướng Đờ Cát lúc đầu chưa chọn vị trí để đặt sở chỉ huy mà tìm cách thiết lập các vòng bảo vệ bằng dây thép gai nối các cứ điểm lại với nhau, sau đó sẽ chọn đặt sở chỉ huy tại vị trí an toàn nhất là ở vị trí mà có nhiều vòng bảo vệ bao quanh nhất. Mỗi 1 vòng bảo vệ là 1 đa giác không tự cắt tạo thành bằng cách nối 1 số cứ điểm lại với nhau bằng dây thép gai, 1 cứ điểm thuộc về không quá 1 vòng bảo vệ, các vòng bảo vệ phải được thiết lập sao cho giữa 2 vòng bảo vệ bất kỳ X và Y thì phần diện tích chung của X và Y = Min( diện tích X, diện tích Y ) hoặc = 0. Trên mặt phẳng toạ độ, các cứ điểm được coi như các điểm có toạ độ nguyên. Bạn hãy xác định xem, sở chỉ huy của tướng Đờ Cát sẽ được bảo vệ tối đa bởi mấy vòng bảo vệ.InputDòng 1: số nguyên N là số cứ điểm. ( 1 ≤ N ≤ 4000 ).N dòng tiếp theo, dòng thứ i gồm 2 số nguyên xi, yi tương ứng là toạ độ của cứ điểm i . Các toạ độ đều là số nguyên dương ≤ 10000 .OutputGồm 1 dòng duy nhất ghi ra số lượng vòng bảo vệ tối đa mà sở chỉ huy của tướng Đờ Cát có thể được bao bọc .ExampleInput4100 100200 100100 200300 300Output1Giải thíchTa nối cứ điểm 1, 2, 3, 4 lại tạo thành 1 vòng bảo vệ, đặt trụ sở chỉ huy bên trong thì ra được đáp án. Ngoài ra còn có các phương án khác là nối cứ điểm 1, 2, 3 tạo thành 1 vòng bảo vệ, nối cứ điểm 2, 3, 4 thành 1 vòng bảo vệ, … nhưng tất cả các phương án này thì khi chọn vị trí đặt trụ sở chỉ huy thì vẫn tối đa = 1.Solutionhttp://dataurbia.com/3wwCode mẫuhttp://dataurbia.com/3pY",
              url: "/spoj/spoj-military-cau-chuyen-nguoi-linh"
            }
            ,

            {
              title: "[SPOJ] QBPAL - Đếm chuỗi đối xứng",
              author: "Accepted Problems",
              category: ["spoj"],
              tag: ["spoj", "string", "palindrome"],
              content: "Link bài gốc: http://vnoi.info/problems/show/QBPAL/Trong một buổi học viết chữ, Bờm phát hiện trong một số từ khi bỏ đi một số ký tự thì đọc ngược hay đọc xuôi đều giống nhau.Ví dụ từ IOICAMP, khi xóa đi các chữ cái C,A,M,P, thì còn lại IOI là một từ đối xứng.Bờm cảm thấy thú vị, và cậu tiếp tục thử xóa các ký tự khác, kết quả là có thêm nhiều từ đối xứng nữa: II, I, O, C… Nhưng nếu với một từ dài, cứ thử từng cách xóa như vậy thì thật mất thời gian. Bạn hãy viết chương trình giúp Bờm tính số cách xóa sao cho từ thu được đối xứng. Hai cách xóa chỉ khác nhau bởi thứ tự xóa các ký tự thì coi như trùng nhau.InputMột dòng duy nhất là từ cần tính số cách xóa, từ này chỉ chứa các chữ cái in hoa A, B, .., Z. ( Độ dài từ không quá 120 )OutputMột số duy nhất là số cách xóa.Ví dụInput:IOICAMPOutput:9Solution:Tham khảo tại: http://dataurbia.com/3OOCode:Tham khảo tại: http://dataurbia.com/3PP",
              url: "/spoj/spoj-qbpal-dem-chuoi-doi-xung"
            }
            ,

            {
              title: "[SPOJ] ADS - Quảng cáo",
              author: "Accepted Problems",
              category: ["spoj"],
              tag: ["spoj", "dfs"],
              content: "Link đề gốchttp://vnoi.info/problems/show/ADS/Đề bài:Nhân dịp Tết sắp đến công ty Jelly-for-Kids quyết định tăng cường việc quảng bá sản phẩm đến người tiêu dùng. Vì thế giám đốc marketing, ông Fruit-Jelly muốn gửi đi số lượng nhân viên tối đa có thể, làm nhiệm vụ tiếp thị tại đại lý trong thành phốTrong thành phố có m con đường, n đại lý bán kẹo (đánh số từ 1 đến n). Mỗi con đường chỉ nối trực tiếp giữa 2 đại lý, và được ký hiệu bằng chỉ số của 2 đại lý mà nó nối. Đồng thời, giữa 2 đại lý bất kỳ có không quá 1 con đường nối chúngÔng Fruit-Jelly nghĩ rằng, ông ta sẽ quản lý nhân viên dễ hơn nếu xếp mỗi người tiếp thị trên những hành trình có tính chất thứ tự. Tức là những đại lý bán kẹo trên hành trình đó thỏa các điều kiện sauCó đường nối trực tiếp giữa 2 đại lý liên tiếp nhau trên hành trìnhTừ một đại lý bất kỳ trong hành trình có thể đi qua tất cả các đoạn đường trong hành trình đó rồi trở về nơi xuất phát mà không đi qua đoạn đường nào quá một lầnHành trình phân công cho mỗi nhân viên phải có ít nhất một đoạn đường chưa có nhân viên nào khác đi tiếp thị.Mỗi nhân viên chỉ di chuyển trên hành trình mà anh ta được phân công. Hãy tính số lượng nhân viên tối đa mà ông Fruit-Jelly có thể xếp việc, và hành trình cụ thể mà mỗi người được xếp.InputDòng đầu là 2 số tự nhiên N và M (N&lt;=2000) (M&lt;=5000)Trong M dòng tiếp theo, mỗi dòng ghi 2 số nguyên mô tả một đoạn đường, mỗi đoạn đường được mô tả bởi chỉ số của 2 đại lý mà nó nối.OutputDòng đầu tiên ghi Q là số lượng nhân viên tối đa tìm đượcVí dụ:Input:5 61 22 44 53 51 32 3Output:2Solution:Tham khảo tại: http://dataurbia.com/2uqCode:Tham khảo tại:http://dataurbia.com/32f(Code đã được nộp và AC trên SPOJ, sử dụng bộ dịch của C++11)",
              url: "/spoj/spoj-ads-quang-cao"
            }
            ,

            {
              title: "[SPOJ] PERIODNB - Kiểm tra tin học",
              author: "Nicky.Rio",
              category: ["spoj"],
              tag: ["spoj", "deque", "dp"],
              content: "Link gốchttp://vnoi.info/problems/show/PERIODNB/Đề bàiDạy tin học cơ sở luôn là công việc vất vả ngay cả với những giáo viên nhiều kinh nghiệm như thầy HUNGNT. Trong giờ bài tập tin học, có 𝑛 học sinh ngồi quanh một bàn tròn, các học sinh được đánh sốtừ 1 tới 𝑛 theo chiều kim đồng hồ. Xuất phát từ một vị trí từ đầu buổi học, thầy HUNGNT phải đi một vòng quanh bàn theo chiều kim đồng hồ để hướng dẫn từng bạn theo đúng thứ tự thầy đi qua. Mỗi bạn được thầy hướng dẫn đúng Δ micro giây (μs) và sau đó bắt tay vào lập trình ngay trong khi thầy chuyển sang hướng dẫn bạn kế tiếp theo chiều kim đồng hồ…, thời gian di chuyển của thầy coi như không đáng kể.Do biết rõ kỹ năng lập trình của từng bạn, thầy HUNGNT có thể ước lượng chính xác rằng bạn học sinh thứ 𝑖 sau khi được thầy hướng dẫn sẽ cần đúng 𝑎𝑖 μs để viết xong chương trình của mình (∀𝑖 = 1,2, … , 𝑛). Vấn đề là thầy muốn kết thúc buổi học càng sớm càng tốt, muốn vậy, việc chọn học sinh nào hướng dẫnđầu tiên phải được tính toán kỹ lưỡng…Yêu cầu: Bạn được cho biết số 𝑛, giá trị Δ, dãy 𝐴 = (𝑎1, 𝑎2, … , 𝑎𝑛). Hãy giúp thầy HUNGNT chọn vị trí xuất phát sao cho thời gian từ lúc bắt đầu buổi học cho tới khi tất cả các học sinh viết xong chương trình của mình là nhỏ nhất.Để tránh việc phải đọc một lượng dữ liệu quá lớn, dãy 𝐴 sẽ được cho bởi ba số nguyên dương 𝑝, 𝑞, 𝑚, trong đó mỗi phần tử 𝑎𝑖 được xác định theo công thức:𝑎𝑖 = (𝑝 ∗ 𝑖) mod 𝑚 + 𝑞 (∀𝑖: 1 ≤ 𝑖 ≤ 𝑛)Dữ liệu:  Dòng 1 chứa hai số nguyên dương 𝑛, Δ (𝑛 ≤ 5.10^6; Δ ≤ 10^9)  Dòng 2 chứa ba số nguyên dương 𝑝, 𝑞, 𝑚 xác định dãy 𝐴 (𝑝, 𝑞, 𝑚 ≤ 10^9)Các số trên một dòng của input file được ghi cách nhau bởi dấu cách.Kết quả:Ghi ra một số nguyên duy nhất là thời gian (tính bằng μs) từ lúc bắt đầu buổi học cho tới khi tất cả các học sinh viết xong chương trình theo phương án tìm được.Ví dụInput5 32 1 9Output18Giải thíchΔ = 3; Dãy 𝐴 = (3,5,7,9,2).Phương án tối ưu: Thầy bắt đầu với học sinh 2,Thời điểm viết xong chương trình của từng học sinh như sau:Học sinh 2: 3 + 5 = 8Học sinh 3: 6 + 7 = 13Học sinh 4: 9 + 9 = 18Học sinh 5: 12 + 2 = 14Học sinh 1: 15 + 3 = 1840% số điểm ứng với các test có 𝑛 ≤ 10^330% số điểm ứng với các test có 𝑛 ∈ [10^4, 10^5]30% số điểm ứng với các test có 𝑛 ∈ [10^6, 5.10^6]Solutionhttp://dataurbia.com/3TdCode mẫuhttp://dataurbia.com/3KF",
              url: "/spoj/spoj-periodnb-kiem-tra-tin-hoc"
            }
            ,

            {
              title: "[SPOJ] VMSUBSTR - Vườn cây của ba",
              author: "itsjustwinds",
              category: ["spoj"],
              tag: ["brute-force", "spoj"],
              content: "Đề: http://vnoi.info/problems/show/VMSUBSTR/Sau một năm học cày cuốc vất vả; Hè này Huy quyết định mời các bạn về quê chơi. Huy sẽ dẫn các bạn đi leo núi, ngắm cảnh… và sẽ mở một buổi chiêu đãi các bạn tài nhà mình. “Nhà rộng và đẹp lắm, có cả một vườn cây ăn trái sum xuê !” - Huy giới thiệu về ngôi nhà của mình.Sau khi kì kèo với ba, Huy đã xin được hái trái trong vườn đãi các bạn. Nhưng với một điều kiện: Huy chỉ được hái trái những LOẠI cây mà ba qui định. Vườn cây chia thành L khu đất liên tiếp nằm thẳng hàng (được đánh số thứ tự từ 1 đến L từ đầu vườn đến cuối vườn), mỗi khu chỉ trồng duy nhất một cây. Nhà Huy có rất nhiều nhân công, mỗi nhân công sẽ chấp nhận làm việc trên những khu đất liên tiếp.Vì muốn đãi các bạn thật nhiều trái cây, nên Huy sẽ tận dụng hái hết TẤT CẢ những cây được ba cho phép. Nhưng mắc nỗi phải dẫn các bạn đi chơi ròi, nên không có thời gian hái trái cây. Nên Huy sẽ nhờ đến các nhân công.Bạn tính xem Huy sẽ phân công ít nhất bao nhiêu nhân công để thực hiện kế hoạch chiêu đãi trái cây của mình? Biết rằng mỗi nhân công sẽ hái hết tất cả trái cây ở các khu đất mình được phân vào.Input  Dòng 1: Gồm 1 số nguyên dương duy nhất: L - số khu đất trong khu vườn.  Dòng 2: Chứa xâu S gồm đúng L chữ cái Latin (in thường hoặc hoa), miêu tả khu vườn của Huy. Mỗi chữ cái cho biết loại cây được trồng ở khu đất tương ứng  Dòng 3: Q - số trường hợp mà bạn phải xứ lý.  Q dòng tiếp, mỗi dòng mô tả một trường hợp và gồm các chữ cái Latin (in thường hoặc hoa). Mỗi chữ đại diện cho một loại cây được phép sử dụng.Output  Với mỗi trường hợp, ghi ra 1 dòng duy nhất là số nhân công ít nhất cần nhờ đến.Chấm điểm  Bài của bạn sẽ được chấm trên thang điểm 100. Điểm mà bạn nhận được sẽ tương ứng với % test mà bạn giải đúng.  Trong quá trình thi, bài của bạn sẽ chỉ được chấm với 1 test ví dụ có trong đề bài.  Khi vòng thi kết thúc, bài của bạn sẽ được chấm với bộ test đầy đủ.Giới hạn  L ≤ 1,000,000;  Q ≤ 100,000;  Số ký tự trong mỗi query không quá 52. Trong mỗi query, các ký tự không lặp lại  Trong 50% số test, L ≤ 1000, Q ≤ 1000;ExampleInput:7abacaba3acbabOutput:322Giải thích  Với trường hợp ‘ac’, Huy chỉ hái những cây loại ‘a’ và ‘c’. Nên Huy cần nhờ ít nhất 3 nhân công lo 3 phần ‘a’, ‘aca’, ‘a’;  Với trường hợp ‘b’, Huy cần nhờ ít nhất 2 nhân công lo 2 phần ‘b’;  Với trường hợp ‘ab’, Huy cần nhờ ít nhất 2 nhân công lo 2 phần ‘aba’;Hướng dẫnhttp://dataurbia.com/ydCodehttp://dataurbia.com/10E",
              url: "/spoj/spoj-vmsubstr-vuon-cay-cua-ba"
            }
            ,

            {
              title: "[SPOJ] LEM5 - ARITHMETIC PROGRESSION",
              author: "itsjustwinds",
              category: ["spoj"],
              tag: ["brute-force", "spoj"],
              content: "Đề: http://vnoi.info/problems/show/LEM5/Cho 1 dãy gồm N số nguyên Ai. Một cấp số cộng là 1 dãy con B của dãy A thoả mãn: B[i]= B[i-1]+ D ( D là công sai &amp; 1 &lt;= D &lt;= 100 )Yêu cầu: Bạn hãy tìm 1 cấp số cộng dài nhấtInputDòng 1: N ( 1 &lt;= N &lt;= 10^5)N dòng tiếp theo: dòng thứ i là số nguyên Ai( |Ai| &lt;= 10^9)OutputGồm 1 dòng duy nhất là số phần tử của cấp số cộng dài nhất tìm đượcExampleInput:10 110320530794011Output:6Hướng dẫnhttp://dataurbia.com/ZICodehttp://dataurbia.com/Zr",
              url: "/spoj/spoj-lem5-arithmetic-progression"
            }
            ,

            {
              title: "Lợi và hại của việc tập trung đơn lẻ vào Lập trình thi đấu",
              author: "Admin Tổng Quản",
              category: ["article"],
              tag: ["programming", "competitive-programming"],
              content: "Câu hỏi gốc trên Quora: Lợi thế và bất lợi của việc chỉ có kĩ năng Lập trình thi đấu là gì?Nick WuMấy cái lợi thế hả:  Code của bạn có ít bug hơn. Chả có cảm giác nào bằng được cảm giác viết một cái chương trình hoàn chỉnh, chạy thử thành công trên các bộ test nhỏ, và submit AC trong lần đầu tiên. Sau thời gian dài, tôi cũng bắt đầu nhận thấy mình có thể viết được những chương trình không bug trong lần đầu tiên nhiều hơn.  Bạn code nhanh hơn. Thực tế mà nói thì code nhanh không phải là yếu tố quan trọng đối với tôi, nhưng bạn bè của tôi hay trêu đùa rằng họ muốn cắt bỏ luôn tay của tôi đi để tôi có thể code ở một tốc độ bình thường hơn.  Kĩ năng debug của bạn trở nên đỉnh cao. Đây không chỉ là về việc tham gia lập trình thi đấu - Tôi đã debug cho rất nhiều các GUI hay ứng dụng OOP do dù chẳng hề có kinh nghiệm với cái đầu tiên.  Bạn không phải lo lắng về việc cài đặt chương trình. Tôi nhận ra điều này ở trong lớp học, khi bài tập về nhà của bọn tôi có thể được gọi ngắn gọn là bài “hãy chọn cấu trúc dữ liệu đúng”. Theo kiểu bạn nhìn vào đó và phán “Chúng ta nên đặt 1 cái priority queue ở đây”. Bạn sẽ luyện tập được trực cảm cho những thứ như vậy.  Bạn có thể được lên Youtube! Nếu như bạn thích fame và vinh quang. Hoặc đối với trường hợp của tôi thì là sự xấu hổ tới thiên thu.Michal DanilákDisadvantages  Bạn sinh ra nghiện ganh đua. Ở ngoài đời thật, bạn sẽ nhanh chóng mất đi động lực khi không có ai để ganh đua cùng cả.  Bạn sẽ quen với những cái mục tiêu và phần thưởng ngắn hạn. Trong cuộc thi, thắng thua được quyết định trong vài tiếng đồng hồ. Trong đời thực bạn có thể phải mất tới hàng tháng để dự án bạn làm sinh ra thành quả cho bạn. Vẫn là vấn đề mất đi động lực.  Bạn chưa từng bao giờ làm ra một cái gì có ích cả. Bạn không biết được cái cảm giác khi chương trình bạn tạo ra đang giúp ích cho ai đó và mọi người biết ơn điều đó.  Bạn chưa từng kiếm ra đồng nào cả, nếu như bạn không thuộc vào số ít đỉnh cao. Bạn cũng không biết tới cảm xúc khi có ai đó sẵn sàng trả tiền cho chương trình của bạn.  Bạn là một chuyên gia giải quyết vấn đề. Nhưng tìm ra vấn đề còn khó và quan trọng hơn nhiều. Dữ liệu đầu vào thực tế sẽ chẳng bao giờ kiểu “các số nguyên từ 1 tới 50, tính cả 2 đầu”.  Bạn biết ngôn ngữ lập trình, nhưng bạn không biết framework nào cả. Học framework thì thực dụng hơn, tốn thời gian hơn và chán nản hơn, và bạn phải làm việc đó suốt ngày!  Không có hệ thống nào có thể báo rằng solution của bạn đã hoàn chỉnh cả. Kể cả khi bạn sử dụng unittest, đôi lúc trong quá trình sản xuất, code của bạn vẫn có thể sai được. Rồi bạn sửa nó, và vài tháng sau nó lại sai. Và rồi tiếp nữa…  Có nhiều cách để solution của bạn sai. Trong thi đấu chúng ta có WA (Wrong Answer), TLE (Time Limit Exceeded) hoặc RuntimeError. Ở ngoài đời thực, chương trình của bạn là một phần của cả hệ thống lớn. Khi chạy một mình nó có thể đúng, nhưng nó vẫn có thể sai khi chạy cùng cả hệ thống. Và kể cả khi nó đã chạy đúng rồi, bạn cũng có thể phạm phải nhiều sai lầm trong thiết kế mà bạn sẽ phải trả giá trong tương lai.  Trong khi thi đấu, bạn là người chơi đơn lẻ. Kể cả khi tham gia các cuộc thi như ACM, mọi người thường hay chia bài tập dành cho từng người. Ở ngoài đời thật, bạn không chỉ phải giải quyết vấn đề cùng cả đội, bạn còn phải dùng chung codebase!  Bạn thường có thói quen lập trình xấu. Không xài OOP, không có hiểu biết gì về design pattern, thích cách giải quyết lươn lẹo hơn, vân vân…  Thuật toán Viterbi, bộ lọc Bloom, Machine Learning, Giải thuật di truyền, xử lý ảnh - bạn chẳng bao giờ phải dùng mấy thứ đó trong thi đấu, nhưng chúng lại là những thứ quan trọng nhất trong thực tế.Advantages  Bạn có trực cảm cho các vấn đề yêu cầu tới thuật toán. Bạn có thể tự tin chỉ ra vấn đề nào có thể xử lý được hoặc cần phải được định nghĩa lại.  Bạn có thể vượt qua vòng phòng vấn vào các công ty IT trong cuộc ganh đua với tầm 30+ người. Những cuộc phỏng vấn này thường xoay quanh thuật toán, mà bạn đã luyện tập suốt về thuật toán rồi còn gì.  Được vị trí cao trong các cuộc thi giúp bạn có được sự kính nể (và nhiều áo T-shirt free nữa).Bài học rút ra là gì?Giống như mẹ của bạn thường hay nói “Mày học suốt là tù người đấy” (nếu mẹ bạn có nói như thế), cái gì cũng có lợi và hại của nó cả. Lập trình thi đấu là một công cụ hiệu quả để bạn có thể rèn luyện kĩ năng lập trình của mình, nhưng bạn cũng không nên tập trung thái quá vào nó - trừ khi bạn đang chuẩn bị cho một kì thi lập trình quan trọng. Tự tìm hiểu, mày mò về những ứng dụng thực tế của lập trình sẽ giúp bạn có được một nền tảng cân bằng hơn, thích nghi dễ dàng hơn với sự thay đổi của công nghệ. :))",
              url: "/article/loi-va-hai-cua-viec-tap-trung-don-le-vao-lap-trinh-thi-dau"
            }
            ,

            {
              title: "[SPOJ] BINARY - Số nhị phân có nghĩa",
              author: "itsjustwinds",
              category: ["spoj"],
              tag: ["math", "spoj"],
              content: "Đề: http://vnoi.info/problems/show/BINARY/Cho số nguyên không âm N (N &lt; 2^31). Hãy xác định xem trong phạm vi từ 0 tới N có bao nhiêu số mà trong dạng biểu diễn nhị phân của nó có đúng K chữ số 0 có nghĩa.Ví dụ: N = 18, K = 3 có 3 số:  8 = 1000  17 = 10001  18 = 10010InputGồm một số dòng, mỗi chứa hai số nguyên N và K cách nhau một dấu cách.OutputỨng với mỗi bộ N, K ở Input đưa ra số lượng tìm được.ExampleInput:18 38 1    Output:34Hướng dẫnhttp://simizer.com/uaTWARNING!!! suy nghĩ kĩ trước khi đọc codeCodehttp://simizer.com/ubX",
              url: "/spoj/spoj-binary-so-nhi-phan-co-nghia"
            }
            ,

            {
              title: "[SPOJ] MINROAD - Con đường Tùng Trúc",
              author: "Joker",
              category: ["spoj"],
              tag: ["spoj"],
              content: "Link đề bài gốc:http://vnoi.info/problems/show/MINROAD/Đề bài:Địa điểm du lịch Dailai nổi tiếng với con đường Tùng-Trúc. Đó là một con đường dài và thẳng, dọc bên đường người ta trồng rất nhiều cây tùng và cây trúc. Với mục đích tạo điểm nhấn cho con đường, Ban quản lý khu du lịch muốn chọn một đoạn đường mà dọc theo nó có ít nhất a cây tùng và có ít nhất b cây trúc để trang trí. Sau khi khảo sát, Ban quản lý ghi nhận được vị trí của từng cây tùng và cây trúc. Trên con đường có tất cả n cây, không có hai cây nào ở cùng một vị trí. Cây thứ i ở ị trí có khoảng cách đến vị trí bắt đầu của con đường là d_i (i = 1, 2, …, n). Với kinh phí có hạn, Ban quản lý muốn chọn một đoạn đường thỏa mãn điều kiện đã nêu với độ dài là ngắn nhất.Yêu cầuCho a, b và vị trí của n cây. Hãy tìm đoạn đường có độ dài ngắn nhất mà dọc theo đoạn đường đó có ít nhất a cây tùng và b cây trúc.Input  Dòng đầu chứa 3 số nguyên dương n, a, b (a + b &lt;= n)  Dòng thứ i trong n dòng tiếp theo mỗi dòng chứa hai số nguyên dương d_i (d_i &lt;= 10^9) trong đó d_i là khoảng cách của cây tính từ vị trí bắt đầu của con đường, k_i = 1 nếu cây thứ i là cây tùng, k_i = 2 nếu là cây trúc.  Các số trên cùng một dòng được ghi cách nhau ít nhất một dấu cách.OutputGhi ra một số nguyên là độ dài đoạn đường ngắn nhất tìm được, quy ước ghi số -1 nếu không tồn tại đoạn đường nào thỏa mãn điều kiện đặt ra.Ví dụ:Input:7 2 220 230 125 135 160 265 210 1Output:35Solution:Tham khảo tại: http://simizer.com/18oCCode:Tham khảo tại: http://simizer.com/18jF",
              url: "/spoj/spoj-minroad-con-duong-tung-truc"
            }
            ,

            {
              title: "[SPOJ] KPLANK - Bán dừa",
              author: "Joker",
              category: ["spoj"],
              tag: ["spoj"],
              content: "Link đề bài gốc:http://vnoi.info/problems/show/KPLANK/Đề bài:Nếu các bạn biết câu chuyện thương tâm “ăn dưa leo trả vàng” của Pirate hẳn đã phải khóc hết nước mắt khi anh ấy, vì lòng thương chim, đã bán rẻ trái dưa leo siêu bự của mình.Dưa leo cũng đã bị chim to lấy đi rồi, Pirate giờ chuyển sang nghề bán dừa để bù lỗ. Bất đắc dĩ thôi, vì trên đảo toàn là dừa…Nhưng mà bán cái gì thì đầu tiên cũng phải có biển hiệu đã. Pirate quyết định lùng sục trên đảo các mảnh ván còn sót lại của những con tàu đắm để ghép lại thành tấm biển. Cuối cùng anh cũng tìm được N tấm ván hình chữ nhật, tấm thứ i có chiều rộng là 1 đơn vị và chiều dài là aiđơn vị. Pirate dựng đứng chúng trên mặt đất và dán lại với nhau để được một mảnh ván to hơn (xem hình minh họa).Việc cuối cùng chỉ là đem mảnh ván này đi cưa thành tấm biển thôi. Nhưng hóa ra đây lại là công việc khó khăn nhất. Pirate rất thích hình vuông và muốn tấm biển của mình càng to càng tốt, nhưng khổ nỗi trên đảo lại không có nhiều dụng cụ đo đạc. Không êke, không thước đo độ, nên Pirate chỉ còn cách dựa vào cạnh của N tấm ván ban đầu để cưa cho thẳng thôi. Pirate chỉ có thể cưa theo những đoạn thẳng chứa một cạnh nào đó (dọc hoặc ngang) của các tấm ván.Hãy giúp anh ấy cưa được tấm biển lớn nhất có thể.InputDòng thứ nhất: ghi số nguyên N - số tấm ván.N dòng tiếp theo: mô tả độ cao của các tấm ván theo thứ tự trái sang phải sau khi đã dán lại.OutputMột số nguyên duy nhất là độ dài cạnh của tấm biển lớn nhất có thể cưa được.Ví dụ:Input:75243314Output:3Solution:Tham khảo tại: http://simizer.com/191D#Code:Tham khảo tại: http://simizer.com/18vT",
              url: "/spoj/spoj-kplank-ban-dua"
            }
            ,

            {
              title: "[SPOJ] QBSCHOOL - Đến trường",
              author: "rknguyen",
              category: ["spoj"],
              tag: ["spoj", "dijkstra", "dp"],
              content: "Link đề gốc:http://vnoi.info/problems/show/QBSCHOOL/Đề bài:Ngày 27/11 tới là ngày tổ chức thi học kỳ I ở trường ĐH BK. Là sinh viên năm thứ nhất, Hiếu không muốn vì đi muộn mà gặp trục trặc ở phòng thi nên đã chuẩn bị khá kỹ càng. Chỉ còn lại một công việc khá gay go là Hiếu không biết đi đường nào tới trường là nhanh nhất.Thường ngày Hiếu không quan tâm tới vấn đề này lắm cho nên bây giờ Hiếu không biết phải làm sao cả. Bản đồ thành phố là gồm có N nút giao thông và M con đường nối các nút giao thông này. Có 2 loại con đường là đường 1 chiều và đường 2 chiều. Độ dài của mỗi con đường là một số nguyên dương.Nhà Hiếu ở nút giao thông 1 còn trường ĐH BK ở nút giao thông N. Vì một lộ trình đường đi từ nhà Hiếu tới trường có thể gặp nhiều yếu tố khác như là gặp nhiều đèn đỏ, đi qua công trường xây dựng, … phải giảm tốc độ cho nên Hiếu muốn biết là có tất cả bao nhiêu lộ trình ngắn nhất đi từ nhà tới trường. Bạn hãy lập trình giúp Hiếu giải quyết bài toán khó này.Dữ liệu:  Dòng đầu tiên chứa số nguyên N và M (1 ≤ N ≤ 5100, 1 ≤ M ≤ 20000)  M dòng tiếp theo, mỗi dòng chứa 4 số nguyên dương K, U, V, L. Trong đó:  K = 1 có nghĩa là có đường đi một chiều từ U đến V với độ dài L.  K = 2 có nghìa là có đường đi hai chiều giữa U và V với độ dài L.Kết quả:Ghi hai số là độ dài đường đi ngắn nhấn và số lượng đường đi ngắn nhất. Biết rằng số lượng đường đi ngắn nhất không vượt quá phạm vì int64 trong pascal hay long long trong C++.Ví dụ:Input:3 21 1 2 32 2 3 1Output:4 1Solution:Tham khảo tại: http://simizer.com/yzzCode:Tham khảo tại: http://simizer.com/z3L",
              url: "/spoj/spoj-qbschool-den-truong"
            }
            ,

            {
              title: "[SPOJ] VOTREE - Cây",
              author: "La Hoàng Phong",
              category: ["spoj"],
              tag: ["spoj", "data-structure"],
              content: "Link Bài Gốc : http://vnoi.info/problems/show/VOTREE/Đề Bài :Cho cây gồm N đỉnh, có gốc ở đỉnh 1. (N ≤ 70,000). Bạn cần trả lời Q truy vấn, mỗi truy vấn gồm 2 số u, v. Bạn cần tìm đỉnh xa gốc nhất, mà là tổ tiên của tất cả các đỉnh u, u+1, …, v.Input  Dòng 1: Số nguyên dương N và Q.  N-1 dòng tiếp theo, mỗi dòng chứa 2 số nguyên dương u và v, thể hiện có 1 cạnh nối giữa 2 đỉnh u và v. (u ≠ v, 1 ≤ u, v ≤ N).  Q dòng tiếp theo, mỗi dòng gồm 2 số nguyên dương u và v (1 ≤ u ≤ v ≤ N), thể hiện 1 truy vấn.OutputVới mỗi truy vấn, in ra 1 dòng duy nhất là đáp số của truy vấn.Giới hạn  Trong 30% số test, 1 ≤ N, Q ≤ 1000.  Trong tất cả các test, 1 ≤ N, Q ≤ 70,000.  Thời gian chạy: 1s. Thời gian chạy cho test ví dụ: 0.5sChú ý:  Trong thời gian thi, bài của bạn chỉ được chấm với test đề bài.  Nếu bài của bạn chạy đúng trên máy mình, nhưng sai khi nộp lên SPOJ, bạn có thể kiểm tra ở ideone. Chú ý khi submit lên ideone, để chế độ Secret để người khác không đọc được code của bạn.Ví dụInput:5 31 22 33 43 52 51 34 5Output:213Giải Thích Ví Dụ :  Truy vấn 1: Tìm tổ tiên chung gần nhất của các đỉnh được đánh số từ 2 đến 5, ở đây có thể thấy 2 là tổ tiên chung gần nhất của các đỉnh 2,3,4,5.  Truy vấn 2: Tìm tổ tiên chung gần nhất của các đỉnh được đánh số từ 1 đến 3, ở đây có thể thấy 1 là tổ tiên chung gần nhất của các đỉnh 1,2,3.  Truy vấn 3: Tìm tổ tiên chung gần nhất của các đỉnh được đánh số từ 4 đến 5, ở đây có thể thấy 3 là tổ tiên chung gần nhất của các đỉnh 4,5.Solution:Tham khảo tại : http://simizer.com/w59Code:Tham khảo tại : http://simizer.com/w8B",
              url: "/spoj/spoj-votree-cay"
            }
            ,

            {
              title: "[SPOJ] JEWELNB - Trang sức",
              author: "Nicky.rio",
              category: ["spoj"],
              tag: ["spoj", "IT"],
              content: "Link bài gốchttp://vnoi.info/problems/show/JEWELNB/Đề bàiCác thương nhân kinh doanh đồ trang sức tại các địa điểm dọc nước ta từ Bắc xuống Nam. Trong đó, các địa điểm buôn bán được đánh số từ 1 đến 𝑛 dọc theo nước ta. Tùy thuộc vào nhu cầu mua mà giá của các đồ trang sức thay đổi theo từng ngày. Qua thống kê, người ta biết hiện có 𝑚 loại đồ trang sức khác nhau được bán trong các ngày vừa qua, trong đó loại thứ 𝑖 được biết với các thông tin như sau:Ngày đầu tiên, đồ trang sức 𝑖 được bán từ địa điểm 𝑠𝑖.Ngày cuối cùng, đồ trang sức 𝑖 sẽ được bán đến địa điểm 𝑒𝑖(1 ≤ 𝑠𝑖 ≤ 𝑒𝑖 ≤ 𝑛)Mỗi ngày thương nhân sẽ chuyển địa điểm bán sang địa điểm kế tiếp theo hướng xuống dưới phía Nam.Như vậy, các địa điểm bán đồ trang sức 𝑖 sẽ là: 𝑠𝑖, 𝑠𝑖 + 1, … , 𝑒𝑖 − 1, 𝑒𝑖Ngày đầu tại vị trí 𝑠𝑖, giá chào bán của nó là 𝑣𝑖(1 ≤ 𝑣𝑖 ≤ 10^9)Mỗi ngày giá loại trang sức 𝑖 sẽ cộng thêm một lượng là 𝑑𝑖(|𝑑𝑖| ≤ 10^9). Tức là, giá tại địa điểm 𝑠𝑖 là 𝑣𝑖, giá tại 𝑠𝑖 + 1 là 𝑣𝑖 + 𝑑𝑖 ,…, giá tại 𝑒𝑖 là 𝑣𝑖 + (𝑒𝑖 − 𝑠𝑖) ∗ 𝑑𝑖.KHUONGND là một nhà thống kê thị trường và anh ta muốn nhờ bạn cho biết giá đồ trang sức cao nhấtđược bán tại tất cả các địa điểm dựa vào thông tin của các đồ trang sức đã biếtDữ liệu:  Dòng 1 chứa hai số nguyên dương 𝑛, 𝑚 ≤ 2.10^5  𝑚 dòng tiếp theo, dòng thứ 𝑖 chứa bốn số nguyên dương 𝑠𝑖, 𝑒𝑖, 𝑣𝑖 và 𝑑𝑖 lần lượt thể hiện thông tin của loại đồ trang sức lần lượt là vị trí bán ban đầu 𝑠𝑖, vị trí bán kết thúc 𝑒𝑖, giá chào bán ban đầu 𝑣𝑖 và lượng giá bán thay đổi 𝑑𝑖 theo mỗi ngày. Dữ liệu vào đảm bảo giá bán các loại đồ trang sức luôn dương.Các số trên một dòng của input file được ghi cách nhau bởi dấu cáchKết quả:Ghi ra 𝑛 dòng, dòng thứ 𝑖 ghi một số nguyên duy nhất là giá đồ trang sức đắt nhất bán tại vị trí 𝑖, nếu tại ví trí 𝑖 không có đồ trang sức nào được bán thì dòng 𝑖 ghi số 0Ví dụInput6 44 4 3 11 2 5 15 6 1 16 6 1 1Output560312Giới hạn: 30% số điểm ứng với các test có 𝑛 × 𝑚 ≤ 5000^2Solutionhttp://simizer.com/trYCode mẫuhttp://simizer.com/tYn",
              url: "/spoj/spoj-jewelnb-trang-suc"
            }
            ,

            {
              title: "[SPOJ] LQDRACE - Race (IOI 2011)",
              author: "Nguyễn Minh Quân",
              category: ["spoj"],
              tag: ["spoj", "ioi", "centroid-decomposition"],
              content: "Link đề gốchttp://vnoi.info/problems/show/LQDRACE/Đề bàiKết hợp với IOI, thành phố Pattaya sẽ tổ chức cuộc đua: Olympic quốc tế về đua tốc độ (IOR) 2011.Là nhà tổ chức, chúng ta phải tìm ra vòng đua tốt nhất cho cuộc thi tốc độ này.Ở vùng Pattaya-Chonburi, có N thành phố được nối với nhau bởi mạng gồm N-1 đường cao tốc. Mỗi đường cao tốc đều cho phép đi theo cả hai chiều nối hai thành phố phân biệt và có độ dài đo bởi kilomet là số nguyên. Ngoài ra có đúng một đường đi giữa cặp hai thành phố bất kỳ. Nghĩa là, có đúng một cách đi từ một thành phố này đến một thành phố khác dọc theo dãy các đường cao tốc không qua bất cứ thành phố nào quá một lần.IOR có qui tắc đặc biệt đòi hỏi vòng đua phải dài đúng K kilomet, bắt đầu và kết thúc ở hai thành phố phân biệt. Rõ ràng là không có đường cao tốc (và vì thế cũng không có thành phố) nào có thể được sử dụng quá một lần trên vòng đua để ngăn ngừa đụng độ. Để cực tiểu ảnh hưởng đến giao thông, vòng đua phải chứa một số ít nhất đường cao tốc có thể.Yêu cầuBạn hãy cho biết số lượng đường cao tốc nhỏ nhất trên vòng đua hợp qui tắc có độ dài đúng bằng K. Nếu không tìm được vòng đua như vậy, kết quả sẽ là -1.Input  Dòng đầu ghi số N, K.  N-1 dòng tiếp theo mỗi dòng ghi 3 số u, v, l - đường cao tốc nối thành phố u và v, độ dài l (l &lt;= 10^6).Output  1 số nguyên duy nhất là kết quả của bài toán.Giới hạn  1 ≤ N ≤ 2 * 10^5  1 ≤ K ≤ 10^6Solution: HereCode mẫu:Here",
              url: "/spoj/spoj-lqdrace-raceioi-2011"
            }
            ,

            {
              title: "[SPOJ] WEATHER - Điều kiện thời tiết",
              author: "Joker",
              category: ["spoj"],
              tag: ["spoj", "graph"],
              content: "Link đề gốc:http://vnoi.info/problems/show/WEATHER/Đề bài:Hãng hàng không OlympAirways thực hiện các chuyến bay giữa n sân bay được đánh số từ 1 đến n. Hệ thống các chuyến bay được thiết lập sao cho giữa 2 sân bay bất kỳ được phục vụ bởi hãng luôn có một đường bay bao gồm một hoặc nhiều chuyến bay trực tiếp giữa hai sân bay. Mỗi chuyến bay thực hiện việc di chuyển giữa hai thành phố theo cả hai chiều.Trung tâm điều khiển của hãng đưa ra khái niệm độ dính kết giữa cặp hai sân bay A và B được xác định như là số lượng các chuyến bay mà việc không thực hiện một trong số chúng (các chuyến bay khác vẫn thực hiện bình thường) dẫn đến không thể bay từ sân bay A đến sân bay B.Một nghiên cứu cho biết rằng, trong điều kiện thời tiết xấu, tổng độ dính kết giữa các cặp sân bay phải đạt đến một giá trị nhất định thì hệ thống đường bay mới được gọi là an toàn.Yêu cầu: Hãy giúp trung tâm điều khiển tính tổng độ dính kết giữa mọi cặp sân bay.Dữ liệu:  Dòng đầu tiên chứa số nguyên n (1 ≤ n ≤ 100)  Dòng thứ hai chứa số nguyên m (1 ≤ m ≤ 5000) - số lượng các chuyến bay  Mỗi dòng trong số m dòng tiếp theo chứa thông tin về một chuyến bay, bao gồm hai số nguyên dương trong khoảng từ 1 đến n: chỉ số của hai sân bay được nối bởi chuyến bay.Kết qủa:In ra 1 số nguyên duy nhất là tổng độ dính kết giữa mọi cặp sân bay (A, B) (với A &lt; B).Ví dụ:Input:551 24 24 53 23 1Output:10Solution:Tham khảo tại: http://simizer.com/s2rCode;Tham khảo tại: http://simizer.com/rrG",
              url: "/spoj/spoj-weather-dieu-kien-thoi-tiet"
            }
            ,

            {
              title: "[SPOJ] QTREEV - Một bài tập về cây",
              author: "itsjustwinds",
              category: ["spoj"],
              tag: ["dp", "tree", "spoj"],
              content: "Đề: http://vnoi.info/problems/show/QTREEV/Cho một đồ thị cây có N đỉnh N-1 cạnh, gốc của cây là đỉnh 1, mỗi đỉnh có một trọng số không âm là Ai. Dễ dàng nhận thấy, ngoại trừ đỉnh 1, các đỉnh còn lại đều có một đỉnh cha và nhận nó làm đỉnh con. Từ mảng A người ta tiến hành xây dựng mảng P như sau:Pu=Au nếu như đỉnh u đó không có đỉnh con, ngược lại Pu=Au*max(Pv1, Pv2…Pvm) với v1,v2…vm lần lượt là các đỉnh con trực tiếp có cạnh nối với u. Nhiệm vụ của bạn là tính P1.InputDòng 1: Gồm một số nguyên N và M(1≤N≤10^5, 1≤M≤10^18).Dòng 2: Gồm N số nguyên A1… AN với Ai là trọng số của đỉnh thứ i. (Ai≤10^18).N-1 dòng tiếp theo, mỗi dòng gồm hai số nguyên u và v, thể hiện cạnh nối giữa u và v (1≤u,v≤N).OutputMột số nguyên duy nhất là P1, do kết quả có thể rất lớn nên chỉ cần in ra phần dư cho một số nguyên M ExampleInput:3 10001 2 31 21 3Output:3Hướng dẫnhttp://simizer.com/tPSWarning !!!!!! suy nghĩ trước khi đọc codeCodehttp://simizer.com/pL2",
              url: "/spoj/spoj-qtreev-mot-bai-tap-ve-cay"
            }
            ,

            {
              title: "[SPOJ] PERREC - Perfect Rectangles",
              author: "itsjustwinds",
              category: ["spoj"],
              tag: ["data-structure", "spoj"],
              content: "Đề:http://vnoi.info/problems/show/PERREC/Cho 1 bảng kích thước N * N được chia thành các ô vuông đơn vị. Mỗi ô vuông có thể có màu đen hoặc trắng. Bây giờ, định nghĩa 1 hình chữ nhật tốt là 1 hình chữ nhật có các cạnh song song với cạnh của bảng và chỉ chứa các ô vuông màu trắng. 1 hình chữ nhật được gọi là hoàn hảo, nếu nó là 1 hình chữ nhật tốt, và không tồn tại 1 hình chữ nhật tốt nào khác chứa nó (tức không thể mở rộng hình chữ nhật này sang trái, phải, trên hay dưới).Yêu cầu: Xác định số hình chữ nhật hoàn hảo của bảng đã cho.Lưu ý:Để giảm kích thước của input, bảng sẽ được tô màu theo quy tắc sau:  Ban đầu bảng chỉ chứa các ô vuông màu trắng.  Sinh 2 dãy số X và Y độ dài m theo quy tắc.  X[0] = x0 mod N, Y[0] = y0 mod N.  X[i] = (X[i – 1] * a + b) mod N, Y[i] = (Y[i – 1] * c + d) mod N với 1 &lt;= i &lt; m.trong đó x0, y0, a, b, c, d, m là các số được cho trước, và P mod Q kí hiệu là phần dư của phép chia P cho Q.  Tô đen các ô có tọa độ (X[0],Y[0]), (X[1],Y[1]),…, (X[m – 1],Y[m – 1]). (Tọa độ của bảng được đánh số từ 0 đến N – 1 theo thứ tự từ trái qua phải, và từ trên xuống dưới).Input:  1 dòng duy nhất gồm 8 số nguyên N,m,x0,a,b,y0,c,d như mô tả trong đề bài.Output:  1 dòng duy nhất ghi ra số lượng hình chữ nhật hoàn hảo thu được.Giới hạn:  0 &lt; N &lt;= 2000.  1 &lt;= m &lt;= 4000000.  0 &lt;= a, b, c, d, x0, y0 &lt;= 2000.  Time limit: 5s.input5 1 2 0 0 2 0 0output4input4 4 0 1 1 0 1 1output6input10 20 4 76 2 6 2 43output12Hướng dẫn:http://simizer.com/tLj!!!!!Waring !!!!! suy nghĩ trước khi đọc codeCodehttp://simizer.com/olO",
              url: "/spoj/spoj-perrec-perfect-rectangles"
            }
            ,

            {
              title: "[SPOJ] LEM3 - TRIP",
              author: "Joker",
              category: ["spoj"],
              tag: ["spoj", "dp"],
              content: "Link bài gốc:http://vnoi.info/problems/show/LEM3/Đề bài:Trong kì nghỉ hè năm nay Sherry được bố thưởng cho 1 tour du lịch quanh N đất nước tươi đẹp với nhiều thắng cảnh nổi tiếng ( vì sherry rất ngoan ). Tất nhiên sherry sẽ đi bằng máy bay.Giá vé máy bay từ đất nước i đến đất nước j là Cij( dĩ nhiên Cij có thể khác Cji). Tuy được bố thưởng cho nhiều tiền để đi du lịch nhưng sherry cũng muốn tìm cho mình 1 hành trình với chi phí rẻ nhất có thể để dành tiền mua quà về tặng mọi người ( Các chuyến bay của sherry đều được đảm bảo an toàn tuyệt đối ).Bạn hãy giúp Sherry tìm 1 hành trình đi qua tất cả các nước, mỗi nước đúng 1 lần sao cho chi phí là bé nhất nhé.Input:Dòng 1: N (5 &lt; N &lt; 16).Dòng thứ i trong N dòng tiếp theo: Gồm N số nguyên, số thứ j là Cij(0 &lt; Cij&lt; 10001).Output:Gồm 1 dòng duy nhất ghi chi phí bé nhất tìm được.#Ví dụ:Input:60 1 2 1 3 4 5 0 3 2 3 4 4 1 0 2 1 2 4 2 5 0 4 3 2 5 3 5 0 2 5 4 3 3 1 0 Output:8Solution:Tham khảo tại:http://simizer.com/o2cCode:Tham khảo tại: http://simizer.com/o00",
              url: "/spoj/spoj-lem3-trip"
            }
            ,

            {
              title: "[SPOJ] NUCLEAR - Hai nhà máy điện nguyên tử",
              author: "Joker",
              category: ["spoj"],
              tag: ["spoj", "data-structure"],
              content: "Link đề bài gốc:http://vnoi.info/problems/show/NUCLEAR/Đề bài:Hai nhà máy điện nguyên tử sẽ được xây dựng tại Byteland trong tương lai gần. Nhà máy điện thứ nhất có bán kính nguy hiểm là R1 và nhà máy điện thứ hai có bán kính nguy hiểm là R2. Để tránh bị nhiễm phóng xạ, tất cả các hộ gia đình cách nhà máy thứ nhất &lt;= R1 km hoặc cách nhà máy thứ hai &lt;= R2 km sẽ phải chuyển chỗ ở.Hai nhà máy sẽ được xây dựng cũng như các hộ gia đình đều nằm trên mặt phẳng với hệ tọa độ Descartes vuông góc , trong đó khoảng cách giữa hai điểm (x1,y1) và (x2,y2) được tính theo công thức:Có q đề án xây dựng, mỗi đề án đều phải cho biết bán kính nguy hiểm của mỗi nhà máy là một cặp giá trị . Nhiệm vụ của bạn là xác định số lượng gia đình phải chuyển chỗ ở ứng với mỗi đề án nếu đề án đó được thực thi.Dữ liệu:  Dòng 1 chứa số nguyên dương N là số hộ gia đìnhN dòng tiếp, dòng i chứa hai số nguyên (xi,yi) là tọa độ  của một hộ gia đình.  Dòng N+2 chứa 5 số nguyên ax,ay,bx,by là tọa độ của nhà máy thứ nhất, tọa độ của nhà máy thứ hai và số đề  án q.  q dòng tiếp theo, dòng thứ j chứa hai số nguyên R1, R2 lần lượt là bán kính nguy hiểm của nhà máy thứ nhất và bán kính nguy hiểm của nhà máy thứ hai trong đề án thứ j.Tất cả các số trong file dữ liệu đều là số nguyên không âm và không lớn hơn 2*10^5. Các số trên một dòng được ghi cách nhau ít nhất một dấu cách.Kết quả:Ghi ra q dòng, dòng thứ j ghi một số nguyên duy nhất là số hộ gia đình phải chuyển chỗ ở nếu đề án thứ j được thực thi.Ví dụ:Input:1195 7527 693 5124 1334 4965 6181 4977 33110 5091 22110 2557 42 97 36 231 2525 25Output:77Hình ảnh cho ví dụ:Solution:Tham khảo tại: http://simizer.com/nhxCode:Tham khảo tại: http://simizer.com/npX",
              url: "/spoj/spoj-nuclear-hai-nha-may-dien-nguyen-tu"
            }
            ,

            {
              title: "[SPOJ] MIXUP2 - Đàn bò hỗn loạn",
              author: "Nguyễn Minh Quân",
              category: ["spoj"],
              tag: ["spoj", "dp", "bitmask"],
              content: "Link đề gốchttp://vnoi.info/problems/show/MIXUP2/Đề bài:Mỗi trong N cô bò (4 &lt;= N &lt;= 16) của bác John có một số seri phân biệt S_i (1 &lt;= S_i &lt;= 25,000). Các cô bò tự hào đến nỗi mỗi cô đều đeo một chiếc vòng vàng có khắc số seri của mình trên cổ theo kiểu các băng đảng giang hồ.Các cô bò giang hồ này thích nổi loạn nên đứng xếp hàng chờ vắt sữa theo một thứ tự gọi được gọi là ‘hỗn loạn’.Một thứ tự bò là ‘hỗn loạn’ nếu trong dãy số seri tạo bởi hàng bò, hai số liên tiếp khác biệt nhau nhiều hơn K (1 &lt;= K &lt;= 3400). Ví dụ, nếu N = 6 và K = 1 thì 1, 3, 5, 2, 6, 4 là một thứ tự ‘hỗn loạn’ nhưng 1, 3, 6, 5, 2, 4 thì không (vì hai số liên tiếp 5 và 6 chỉ chênh lệch 1).Hỏi có bao nhiêu cách khác nhau để N cô bò sắp thành thứ tự ‘hỗn loạn’?Input      Dòng 1: Hai số N và K cách nhau bởi khoảng trắng.        Dòng 2..N+1: Dòng i+1 chứa một số nguyên duy nhất là số seri của cô bò thứ i: S_i  Output  Dòng 1: Một số nguyên duy nhất là số cách để N cô bò sắp thành thứ tự ‘hỗn loạn’. Kết quả đảm bảo nằm trong phạm vi kiểu số nguyên 64-bit.Solutionhttp://simizer.com/n5YCode mẫuhttp://simizer.com/n8t",
              url: "/spoj/spoj-mixup2-dan-bo-hon-loan"
            }
            ,

            {
              title: "[SPOJ] LATGACH4",
              author: "houtaru",
              category: ["spoj"],
              tag: ["spoj", "matrix-multiplication", "dp"],
              content: "Link đề bài:http://vnoi.info/problems/show/LATGACH4/Đề bài:Cho một hình chữ nhật kích thước 2xN (1&lt;=N&lt;10^9). Hãy đếm số cách lát các viên gạch nhỏ kích thước 1x2 và 2x1 vào hình trên sao cho không có phần nào của các viên gạch nhỏ thừa ra ngoài, cũng không có vùng diện tích nào của hình chữ nhật không được lát.InputGồm nhiều test, dòng đầu ghi số lượng test T ( T&lt;=100 ). T dòng sau mỗi dòng ghi một số N.OutputGhi ra T dòng là số cách lát tương ứng lấy phần dư cho 111539786.Solution:http://simizer.com/eyKCode:http://simizer.com/ezN",
              url: "/spoj/spoj-latgach4"
            }
            ,

            {
              title: "[SPOJ] ETF",
              author: "houtaru",
              category: ["spoj"],
              tag: ["spoj", "math"],
              content: "Link đề bài : http://vnoi.info/problems/show/ETF/Đề bài :φ(n) là số số nguyên tố cùng nhau với n.Cho nhiều testcase, tính giá trị φ(n)Solution:http://simizer.com/eoeCode:http://simizer.com/ep6",
              url: "/spoj/spoj-etf"
            }
            ,

            {
              title: "[SPOJ] KVIP",
              author: "houtaru",
              category: ["spoj"],
              tag: ["spoj", "dp"],
              content: "Link đề bài:http://vnoi.info/problems/show/KVIP/Đề bài:Trong rạp chiếu phim có N ghế dành cho N vị khách.Mỗi người lần lượt vào rạp xem phim và phải ngồi vào đúng chỗ của mình (người vào thứ i phải ngồi ghế thứ i).Tuy nhiên, có một ông khách VIP vào đầu tiên và được giành lấy một ghế bất kì. Mỗi người tiếp theo khi vào rạp thì ý thức hơn nên sẽ ngồi vào đúng chỗ (nếu ghế của họ chưa có người ngồi). Nhưng nếu chỗ của họ đã bị lấy mất thì họ được quyền chọn 1 ghế khác bất kì.Ta biết C[i,j] là độ hài lòng của vị khách thứ i khi ngồi vào ghế thứ j. Hãy tính giá trị lớn nhất có thể của tổng độ hài lòng của N vị khách.InputDòng đầu tiên là số nguyên dương N (1 &lt;= N &lt;= 1000);Dòng thứ i (trong N dòng tiếp theo) gồm N số nguyên. Số thứ j cho là giá trị C[i,j] (|C[i,j]| &lt;= 1.000.000.000);OutputMột số nguyên duy nhất là tổng lớn nhất có thể đạt được.Solution:http://simizer.com/egqCode:http://simizer.com/ehT",
              url: "/spoj/spoj-kvip"
            }
            ,

            {
              title: "[SPOJ] C11CAL - Tính toán",
              author: "houtaru",
              category: ["spoj"],
              tag: ["spoj", "matrix-multiplication", "data-structure"],
              content: "Link đề bài:http://vnoi.info/problems/show/C11CAL/Đề bài:Cho N, k, tính (1^k + 2^k + …. + N^k) mod 1000000007.Giới hạn : 1 &lt;= N &lt;= 109, 1 &lt;= k &lt;= 50.InputGồm nhiều dòng, mỗi dòng chứa 2 số N, k là những bộ test của bàiOutputGhi ra kết quả ứng với mỗi bộ testSolution:http://simizer.com/eKOCode:http://simizer.com/eKw",
              url: "/spoj/spoj-c11cal-tinh-toan"
            }
            ,

            {
              title: "[SPOJ] KDIFF - Trồng hoa",
              author: "houtaru",
              category: ["spoj"],
              tag: ["spoj", "deque", "data-structure"],
              content: "Link bài gốc:http://vnoi.info/problems/show/KDIFF/Đề bài:Pirate là một người rất yêu hoa. Anh ấy trồng một luống hoa trước cửa nhà mình. Luống hoa được chia thành các ô đất, mỗi ô đất trồng một bông hoa. Tuy nhiên, vì đang bị đau chân nên Pirate ấy không thể chăm sóc luống hoa một cách hoàn hảo nhất. Kết quả là các bông hoa của anh có xấu đẹp không đều nhau.Để cải thiện tình hình, Pirate quyết định chỉ để lại hai khóm hoa rời nhau, mỗi khóm gồm một số các bông hoa đứng liên tiếp nhau. Để ngôi nhà của mình trông thật xinh đẹp, hai khóm hoa kia phải được chọn lựa kỹ càng. Anh dùng đôi mắt thẩm mỹ tinh tường của mình (gọi là “sắc kế”) để đánh giá độ xinh đẹp của các bông hoa, được thể hiện bằng các số nguyên không âm. Căn cứ vào đó, một khóm hoa đạt tiêu chuẩn khi và chỉ khi chệnh lệch độ xinh đẹp giữa hai bông hoa bất kì trong khóm không quá một giá trị cho trước. Pirate muốn hai khóm hoa có càng nhiều bông hoa càng tốt. Bạn hãy giúp anh ấy xác định xem có thể chọn được nhiều nhất bao nhiêu bông nhé.InputDòng 1: Hai số nguyên N - số bông hoa trên luống hoa, K - chênh lệch độ xinh đẹp tối đa của hai bông hoa bất kì trong một khóm.N dòng tiếp theo: Mỗi dòng là một số nguyên thể hiện độ xinh đẹp của một bông hoa.OutputMột số nguyên duy nhất là số bông hoa được chọn của hai khóm hoa.Giới hạn1 ≤ N ≤ 3 * 10^5.30% số test có 1 ≤ N ≤ 30.50% số test có 1 ≤ N ≤ 10^3.Các số trong dữ liệu vào đều là số nguyên không âm không quá 10^9.Solution:http://simizer.com/c1vCode:http://simizer.com/c2j",
              url: "/spoj/spoj-kdiff-trong-hoa"
            }
            ,

            {
              title: "[SPOJ] AUCTION - Going Once, Going Twice, Gone!",
              author: "houtaru",
              category: ["spoj"],
              tag: ["SPOJ", "implementation"],
              content: "Link bài gốc:http://vnoi.info/problems/show/AUCTION/Đề bài :Chế độ ăn kiêng của đàn bò khiến cho nông trang của nông dân John dôi ra 1 số lượng cỏ khô, vì vậy anh ta muốn bán đấu giá số cỏ khô này để trang trải phần nào chi phí chăn nuôi. Anh ta có N (1 &lt;= N &lt;= 1,000) bó cỏ khô giống nhau; khách hàng sẽ đấu giá để mua đống cỏ này là M (1 &lt;= M &lt;= 1,000) nông dân khác sống gần đó.Mỗi một nông dân i sẽ cho nông dân John biết anh ta sẵn sàng trả P_i (1 &lt;= P_i &lt;= 1,000,000) đồng cho 1 bó cỏ khô. Mỗi một nông dân chỉ muốn mua 1 bó cỏ khô mà thôi.Để đảm bảo các nông dân không ghen tị với nhau, nông dân John sẽ đưa ra 1 mức giá cố định cho tất cả người đến mua và bán các bó cỏ khô cho những ai trả giá &gt;= mức giá đó, những người còn lại sẽ bị từ chối giao dịch.Hãy giúp nông dân John tính xem đặt mức giá nhỏ nhất là bao nhiêu để thu được nhiều tiền nhất có thể.Dữ liệu      Dòng 1: Hai số nguyên cách nhau bởi dấu cách: N và M        Dòng 2..M+1: Dòng i+1 chứa 1 số nguyên duy nhất: P_i  Kết quả  Dòng 1: 2 số nguyên cách nhau bởi dấu cách: giá bán của John và số tiền mà John thu được.Solution:http://simizer.com/aQiCode:http://simizer.com/aLy",
              url: "/spoj/spoj-auction-going-once-going-twice-gone"
            }
            ,

            {
              title: "[SPOJ] LEM4 - WHILE BLACK",
              author: "Nguyễn Minh Quân",
              category: ["spoj"],
              tag: ["spoj", "data-structure"],
              content: "Link bài gốc:http://vnoi.info/problems/show/LEM4/Đề bàiHồi còn bé sherry thường chơi với bố 1 trò chơi có tên gọi là White Black :DBố có 1 mảnh giấy HCN thật dài cỡ 1 x N chia thành N ô vuông bé dàn thành hàng ngang. Ban đầu ô vuông nào cũng có màu trắng. Quy tắc chơi sẽ là mỗi bước bố có thể tô màu 1 đoạn các ô vuông từ ô L đến ô R cùng 1 màu ( có thể là màu đen hoạc màu trắng ) 1 lúc sau tờ giấy sẽ có rất nhiều ô đen trắng đan xen nhau và câu hỏi của bố dành cho sherry là có bao nhiêu ô vuông màu trắng liên tiếp ( sao cho số lượng các ô này là nhiều nhất )sherry cũng thông minh lắm nên hôm nào cũng thắng ( tuy nhiên sherry chơi hơi chậm 1 chút ^^ ) Sao bạn không thử tham gia trò chơi này nhỉ :DInputDòng 1: N (1 &lt;= N &lt;= 10000)Dòng 2: M (1 &lt;= M &lt;= 100000) ( tổng số lần tô màu và số lần bố đố sherry )M dòng tiếp theo: Mỗi dòng có dạng:1 L R (1 &lt;= L &lt;= R &lt;= N) tô các ô vuông từ L -&gt; R màu trắng2 L R (1 &lt;= L &lt;= R &lt;= N) tô các ô vuông từ L -&gt; R màu đen3 đếm số lượng ô màu trắng liên tiếp dài nhấtOutputGồm 1 số dòng tương ứng với các câu trả lời của sherry cho câu hỏi của bốSolution: http://simizer.com/VxYCode mẫu:http://simizer.com/Vha",
              url: "/spoj/spoj-lem4-while-black"
            }
            ,

            {
              title: "[SPOJ] UPGRANET - VOI 2011 Nâng cấp mạng",
              author: "Joker",
              category: ["spoj"],
              tag: ["spoj", "graph"],
              content: "Link bài gốc:http://vnoi.info/problems/show/UPGRANET/Đề bài:Một hệ thống gồm n máy tính đánh số từ 1 đến n được kết nối thành một mạng bởi m đoạn cáp mạng đánh số từ 1 đến m. Đoạn cáp mạng thứ i có thông lượng wikết nối hai máy ui, vicho phép truyền dữ liệu theo cả hai chiều giữa hai máy này.Một dãy các máy x1, x2, …, xptrong đó giữa hai máy xjvà xj+1(j = 1, 2, …, p-1) có đoạn cáp nối được gọi là một đường truyền tin từ máy x1tới máy xp. Thông lượng của đường truyền tin được xác định như là thông lượng nhỏ nhất trong số các thông lượng của các đoạn cáp mạng trên đường truyền. Giả thiết là mạng được kết nối sao cho có đường truyền tin giữa hai máy bất kì và giữa hai máy có không quá một đoạn cáp mạng nối chúng.Người ta muốn nâng cấp mạng bằng cách tăng thông lượng của một số đoạn cáp nối trong mạng. Để tăng thông lượng của mỗi đoạn cáp mạng thêm một lượng d (d &gt; 0) ta phải trả một chi phí đúng bằng d. Việc nâng cấp mạng phải đảm bảo là sau khi hoàn tất, thông lượng của mỗi đoạn cáp mạng i đều bằng thông lượng của đường truyền tin có thông lượng lớn nhất từ máy ui tới máy vi.Yêu cầu:Tìm phương án nâng cấp các đoạn cáp mạng sao cho tổng chi phí nâng cấp là nhỏ nhất.Dữ liệu:      Dòng thứ nhất: Chứa hai số nguyên dương n, m (n, m &lt;= 10^5).        Dòng thứ i trong số m dòng tiếp theo chứa ba số nguyên dương ui, vi, wi(wi&lt;= 10^6),i = 1, 2, …, m.      Các số trên cùng một dòng được ghi cách nhau ít nhất một dấu cách.Kết quả:Ghi ra một số nguyên duy nhất là tổng chi phí nâng cấp theo phương án tìm được.Ví dụ:Input:6 71 2 61 3 52 4 33 4 94 5 44 6 85 6 7Output:5Solution:Tham khảo tại: http://simizer.com/a5NCode:Tham khảo tại: http://simizer.com/SoC",
              url: "/spoj/upgranet-voi-2011-nang-cap-mang"
            }
            ,

            {
              title: "[SPOJ] QVESCAPE - Help Conan 9 !",
              author: "Nguyễn Minh Quân",
              category: ["spoj"],
              tag: ["spoj", "graph", "shortest-path", "math"],
              content: "Link gốchttp://vnoi.info/problems/show/QVESCAPE/Đề bàiAnh Quang Vũ dạo này khá hư hỏng, suốt ngày cứ chơi bời lêu lổng nên đã bị bạn Như Quỳnh trừng phạt. Nhưng bạn Như Quỳnh rất nương tay nên chỉ thử anh anh Quang Vũ bằng cách ném vào ngục tối bởi vua bóng tối để xác định độ ngoan của anh ta. Cái ngục được tạo dáng thành một hình lập phương với những bức tường đá lớn. Những căn phòng được nối bởi những lối đi nên vì vậy toàn bộ ngục tối khi nhìn từ phía trên trông giống như một đường xoắn ốc. Những căn phòng đc đánh số như sau:… 15 14 135 4 3 126 1 2 117 8 9 10Sau một trận động đất lớn một số bức tường đã bị phá hủy và những lối đi mới được hình thành giữa những phòng kế bênAnh Quang Vũ đang ở phòng 1 . Ông ấy biết rằng lối thoát đc đặt ở phòng N, và muốn chạy thoát trong lúc mọi người đang hoảng loạn vì trận động đất, bởi vì vua bóng tối đang canh gác ngục tối, anh Quang Vũ muốn dùng con đường đi nhanh nhất để thoát khỏi ngục tối.Viết chương trình đưa ra vị trí của lối thoát N và danh sách những lối đi mới, xác định số đoạn đường phải đi nhỏ nhất mà anh Quang Vũ phải đi qua trước khi thóat khỏi ngục.InputDòng đầu tiên của input chứa một số nguyên N(1&lt;=N&lt;=10^15), phòng mà lối thoát ở đó.Dòng thứ hai chứa 1 số nguyên K (1&lt;=K&lt;=100000), số của con đường mới.Mỗi dòng K chứa 1 số nguyên B(4&lt;=B&lt;=10^15) nghĩa là một con đường mới được nối vào hai phòng A,B cạnh nhau, nơi mà A&lt;B. Số A không được đưa một cách chi tiết nhưng nó có thể xác định một cách duy nhất từ B (ví dụ nếu B là 20, thì A phải là 7), và một số phòng ko bao giờ là phòng B (2,3,5,7,10,13..v..v).OutputOutput chứa 1 số nguyên, số con đường nhỏ nhất mà anh Quang Vũ phải đi qua trước khi thoát.Nếu không thoát ra, anh Vũ sẽ bị tử ẹo tại hang động này, hy vọng các bạn sẽ giúp anh Vũ thoát khỏi hang.P/S: 50% số test có N&lt;=10^5Solution :http://simizer.com/T7SCode mẫu :http://simizer.com/Snm",
              url: "/spoj/spoj-qvescape-help-conan-9"
            }
            ,

            {
              title: "[SPOJ] XUCXAC - Xúc xắc",
              author: "itsjustwinds",
              category: ["spoj"],
              tag: ["graph", "spoj"],
              content: "Đề: http://vnoi.info/problems/show/XUCXAC/Một mặt bàn nằm ngang được chia làm lưới ô vuông, trong mỗi ô có ghi một số tự nhiên.Cho 1 con xúc xắc nằm vừa vặn trên một ô của lưới. Mỗi mặt của xúc xắc là một số từ 1 đến 6. Ban đầu, mặt trước là số 1, mặt trên là số 2 và mặt bên phải là số 3, các mặt đối diện có tổng số là 7. Mỗi lần, con xúc xắc có thể lăn về phía trái, phải, trước, sau. Mỗi lần tiếp xúc với mặt bàn, ta mất một chi phí bằng số ghi trên ô mà xúc xắc đang nằm trên nhân với số trên mặt của xúc xắc đang tiếp xúc với mặt bàn.Hãy tìm cách lăn từ một ô đến một ô khác trên mặt bàn để đạt chi phí nhỏ nhất.Dữ liệu  Dòng đầu ghi 2 số M, N lần lượt là số dòng và số cột của lưới ô trên mặt bàn.  M dòng sau, mỗi dòng ghi N số nguyên không quá 100 là số ghi trên các ô lưới của mặt bàn. Các dòng được liệt kê theo thứ tự từ xa đến gần, các số trên mỗi dòng liệt kê từ trái sang phải.  Dòng cuối ghi 2 cặp số lần lượt là tọa độ (dòng, cột) của ô bắt đầu và ô kết thúc.Kết quảGhi ra một số duy nhất là chi phí nhỏ nhất tìm được.Giới hạn1 ≤ M,N ≤ 50.Ví dụDữ liệu3 31 2 34 5 67 8 92 2 3 3Kết quả52Hướng dẫnhttp://simizer.com/tJICodehttp://simizer.com/Smx",
              url: "/spoj/spoj-xucxac-xuc-xac"
            }
            ,

            {
              title: "[SPOJ] LUBENICA - Lubenica",
              author: "La Hoàng Phong",
              category: ["spoj"],
              tag: ["data-structure", "heavy-light-decomposition"],
              content: "Link Bài Tập Gốc ( Tiếng Anh ) :http://www.spoj.com/problems/LUBENICAĐề Bài ( Tiếng Việt )Mạng lưới giao thông ở 1 nước bao gồm N thành phố (đánh số từ 1 đến N) và N-1 đường nối các thành phố với nhau. Có một đường đi duy nhất giữa mỗi cặp thành phố. Mỗi con đường có một độ dài xác định.Viết chương trình, với mỗi K cặp thành phố cho trước, tìm độ dài của con đường ngắn nhất và dài nhất trên đường đi giữa 2 thành phố này.Dữ liệuDòng đầu tiên chứa số nguyên N, 2 ≤ N ≤ 100 000.Mỗi dòng trong số N-1 dòng tiếp theo chứa 3 số nguyên A, B, C cho biết có một con đường độ dài C giữa thành phố A và thành phố B. Độ dài của mỗi con đường là số nguyên dương không vượt quá 1000000.Dòng tiếp theo chứa số nguyên K, 1 ≤ K ≤ 100 000.Mỗi dòng trong số K dòng tiếp theo chứa 2 số nguyên D và E - chỉ số của 2 thành phố cần truy vấn.Kết quảMỗi dòng trong số K dòng chứa 2 số nguyên - độ dài của con đường ngắn nhất và dài nhất trên đường nối giữa 2 thành phố tương ứng.Ví dụDữ liệu:52 3 1004 3 2001 5 1501 3 5032 43 51 2Kết quả:100 20050 15050 100Giải thích Ví dụ:      Truy vấn 1 : Từ đỉnh 2 đến đỉnh 4 đi qua gồm các cạnh: 2-3, 3-4. Các cạnh này có trọng số tối thiểu là 100 (2-3) trọng số tối đa là 200 (3-4)        Truy vấn 2:  Từ đỉnh 3 đến đỉnh 5 đi qua gồm các cạnh: 3-1, 1-5. Các cạnh này có trọng số tối thiểu là 50 (3-1) trọng số tối đa là 150 (1-5)        Truy vấn 3: Từ đỉnh 1 đến đỉnh 2 đi qua gồm các cạnh: 1-3, 3-2. Các cạnh này có trọng số tối thiểu là 50 (1-3) trọng số tối đa là 100 (3-2)  Solution : http://simizer.com/T0fCode Mẫu : http://simizer.com/T82",
              url: "/spoj/spoj-lubenica-lubenica"
            }
            ,

            {
              title: "[SPOJ] VOLIS - Dãy con không giảm dài nhất",
              author: "itsjustwinds",
              category: ["spoj"],
              tag: ["dp", "spoj"],
              content: "Link đề: http://vnoi.info/problems/show/VOLIS/Tóm tắt:cho 1 dãy a1 ,a2 ,…, an; với 1 số trong dãy, ta có thể tự nhiên cộng hoặc trừ đi một số d cho trước. nhiệm vụ của ta là tìm dãy con không giảm dài nhất có thể tạo thành sau khi thay đổi tùy ý.Giới Hạn  0 &lt; N ≤ 1000.  0 ≤ D ≤ 10^9.  0 ≤ a[i] ≤ 10^9.  Trong 30% số test, D = 0.ExampleInput:4 16 4 3 2Output:3Giải thích: Có thể biến đổi dãy thành 6 3 3 3.Hướng dẫnhttp://simizer.com/szzCodehttp://simizer.com/ROJ",
              url: "/spoj/spojvolis-day-con-khong-giam-dai-nhat"
            }
            ,

            {
              title: "[SPOJ] DHLOCO - Trò chơi lò cò",
              author: "Joker",
              category: ["spoj"],
              tag: ["spoj", "matrix-multiplication"],
              content: "Link gốc:http://vnoi.info/problems/show/DHLOCO/Đề bài:Carnaval Hạ Long 2015 với chủ đề “Hội tụ tinh hoa - Lan tỏa nụ cười”, điểm mới của lễ hội là sự song hành giữa biểu diễn nghệ thuật “Nơi tinh hoa hội tụ” và diễu hành đường phố “Nụ cười Hạ Long” với sự góp mặt của hơn 2000 diễn viên quần chúng. Có rất nhiều chương trình vui chơi được tổ chức, một trong những trò chơi thu hút được nhiều du khách tham gia đó là trò chơi nhảy lò cò, cụ thể: người chơi cần vượt qua một đoạn đường dài n mét, mỗi bước, người chơi có ba cách nhảy với độ dài bước nhảy tương ứng là 1 mét, 2 mét, 3 mét. Một cách đi chuyển đúng là dãy các bước nhảy có tổng đúng bằng n.Yêu cầu:Cho n và M, gọi K là số cách đi chuyển đúng khác nhau để đi hết đoạn đường n mét, hãy tính phần dư của K chia M.Subtest:  Có 20% số test ứng với 20% số điểm có n≤ 20;  Có 40% số test ứng với 40% số điểm có n ≤ 10^6;  Có 40% số test còn lại ứng với 40% số điểm có n ≤ 10^15.Ví dụ:Input:5 100 Output:13Solution:Tham khảo tại : http://simizer.com/SPFCode:Tham khảo tại: http://simizer.com/QP0",
              url: "/spoj/dhlocospoj"
            }
            ,

            {
              title: "[SPOJ] BONUS - VOI 2011 Phần thưởng",
              author: "Nicky.Rio",
              category: ["spoj"],
              tag: ["spoj", "dp"],
              content: "Link gốc:http://vnoi.info/problems/show/BONUS/Đề bàiTuấn là người chiến thắng trong một cuộc thi “tìm hiểu kiến thức vũ trụ” và được nhận các phần thưởng do công ty XYZ tài trợ. Các phần thưởng được bố trí trên một bảng hình vuông n x n có dạng một lưới ô vuông kích thước đơn vị. Các dòng của bảng được đánh số từ 1 đến n, từ trên xuống dưới và các cột của bảng được đánh số từ 1 đến n, từ trái qua phải. Ô nằm trên giao của dòng i và cột j được gọi là ô (i,j) và trên ô đó chứa một món quà có giá trị là a[i,j] (1 &lt;= i, j &lt;= n)Để nhận phần thưởng, Tuấn được phép chọn một hình vuông kích thước k x k chiếm trọn trong một số ô của bảng và nhận tất cả các phần quà có trong các ô nằm trong hình vuông đó.Yêu cầu:Hãy xác định tổng giá trị lớn nhất của món quà mà Tuấn có thể nhận được.Dữ liệu:  Dòng thứ nhất chứa hai sô nguyên dương n, k (n &lt;= 1000, n/3 &lt;= k &lt;= n).  Dòng thứ i trong số n dòng tiếp theo chứa n số nguyên dương, số thứ j là a[i,j] (a[i,j] &lt;= 1000)Kết quả:Ghi ra một số nguyên duy nhất là tổng giá trị lớn nhất của các món quà mà Tuấn có thể nhận được.Ví dụ:Input4 31 9 1 19 9 9 91 9 9 91 9 9 14Output86Solutionhttp://simizer.com/Q22Code mẫuhttp://simizer.com/PiD",
              url: "/spoj/spojbonus-voi-2011-phan-thuong"
            }
            ,

            {
              title: "[SPOJ] METERAIN - Mưa thiên thạch",
              author: "Joker",
              category: ["spoj"],
              tag: ["spoj", "convex-hull"],
              content: "Link bài gốc:http://vnoi.info/problems/show/METERAIN/Đề bài:Phú ông nhận được thông tin về một trận mưa thiên thạch sắp ập xuống trái đất. Không những thế, Phú ông còn biết tọa độ của vị trí điểm rơi của mỗi một thiên thạch. Phú ông nhờ Cuội xác định xem có bao nhiêu thiên thạch có thể rơi xuống cánh đồng của ông ta. Cánh đồng của Phú ông có dạng một hình đa giác lồi được xác định bởi danh sách các đỉnh được liệt kê theo thứ tự ngược chiều kim đồng hồ.Yêu cầu: Xác định xem trong tập cho trước các điểm rơi của thiên thạch, có bao nhiêu điểm nằm trong cánh đồng của Phú ông. Các điểm nằm trên biên của cánh đồng không được tính là điểm nằm trong cánh đồng.Input  Dòng đầu tiên là số nguyên n (3 &lt;= n &lt;= 5000) là số đỉnh của đa giác lồi mô tả cánh đồng của Phú ông.  Mỗi dòng trong n dòng tiếp theo chứa cặp tọa độ của một đỉnh của đa giác lồi.- Dòng tiếp theo là số nguyên m (2 &lt;= m &lt;= 5000) - số thiên thạch rơi xuống.  Mỗi dòng trong số m dòng cuối cùng chứa 2 số là tọa độ điểm rơi của một thiên thạch.Các tọa độ là các số nguyên có trị tuyệt đối không quá 10^6.OutputGhi ra m dòng, mỗi dòng tương ứng với 1 điểm rơi của thiên thạch. Ghi “YES” nếu điểm rơi của thiên thạch nằm trong cánh đồng và ghi “NO” nếu trái lại.Ví dụ:Input:42 48 46 84 643 54 75 56 7Output:NONOYES YESSolution:Tham khảo tại: http://simizer.com/SOhCode mẫu:Tham khảo tại: http://simizer.com/OCo",
              url: "/spoj/meterainspoj"
            }
            ,

            {
              title: "[SPOJ] QTREE5",
              author: "Nguyễn Minh Quân",
              category: ["spoj"],
              tag: ["spoj", "tree", "centroid-decomposition", "data-structure"],
              content: "Link bài tập gốc (tiếng Anh)http://www.vnoi.info/problems/show/QTREE5/Đề bài (tiếng Việt)Cho 1 cây với N đỉnh được đánh số từ 1 đến N. Ta định nghĩa dist(a, b) là số lượng cạnh trên đường đi từ đỉnh a đến đỉnh b.Mỗi nút có một màu, đen hoặc trắng. Khởi tạo mọi nút là màu đen.Bạn phải thực hiện các truy vấn sau:  0 i :   Thay đổi màu của nút i (đen thành trắng hoặc trắng thành đen)  1 v :   Đưa ra giá trị nhỏ nhất của dist(u, v), với nút u là một nút trắng(u có thể bằng v). Nếu nút v là nút trắng, kết quả là 0.Input  Dòng thứ nhất chứa 1 số nguyên dương N (N &lt;= 100000)  N-1 dòng tiếp theo, dòng thứ i có 2 số nguyên dương a, b biểu diễn một cạnh giữa a và b  Dòng tiếp theo là số nguyên dương Q là số truy vấn (Q &lt;= 100000)  Q dòng tiếp theo, mỗi dòng có dạng “0 i”  hoặc ”1 v”OutputVới mỗi truy vấn dạng ”1 v”, in ra 1 số nguyên dương biễu diễn kết quả. Nếu không có nút trắng nào trên cây, in ra -1Solutionhttp://simizer.com/F4QCode mẫuhttp://simizer.com/DoM",
              url: "/spoj/spoj-qtree5"
            }
            ,

            {
              title: "[SPOJ] QTREEX - Truy vấn trên cây",
              author: "itsjustwinds",
              category: ["spoj"],
              tag: ["data-structure", "spoj"],
              content: "Đề: http://vnoi.info/problems/show/QTREEX/Cho một cây gồm N nút đánh số từ 1-&gt;N. Các cạnh của cây đánh số từ 1-&gt; N - 1, mỗi cạnh có trọng số là một số nguyên. Bạn cần viết chương trình thực hiện dãy các lệnh sau:      CHANGE i v =&gt; Thay đổi trọng số của cạnh thứ i thành v        NEGATE a b =&gt; Đảo dấu trọng số của tất cả các cạnh nằm trên đường đi từ a đến b        QUERY a b =&gt; Tìm trọng số lớn nhất của các cạnh nằm trên đường đi từ a đến b  InputInput là một bộ gồm nhiều test. Dòng đầu của input là số test t ( t&lt;=20 ). Tiếp sau đó là các test.Mỗi test bắt đầu bằng một dòng trống. Dòng tiếp theo ghi một số N ( N&lt;=10000 ). N - 1 dòng tiếp theo, mỗi dòng ghi 3 số a, b và c mô tả một cạnh của cây nối a với b và có trọng số là c. Thứ tự của các cạnh chính là thứ tự xuất hiện trong input. Tiếp theo là dãy các lệnh như mô tả ở trên(số lệnh không quá 50000). Cuối mỗi test ghi một từ “DONE”.Dữ liệu vào luôn đảm bảo trọng số của các cạnh ở mỗi thời điểm có giá trị tuyệt đối không vượt quá 10000000.OutputVới mỗi lệnh “QUERY”, in ra kết quả tìm được. Nếu a = b thì ghi ra 0.ExampleInput:131 2 12 3 2QUERY 1 2CHANGE 1 3QUERY 1 2DONEOutput:13Chúc bạn may mắn.Hướng dẫn: http://simizer.com/tCyNhức đầu, chóng mặt, mắc ngủ ?????????????????????Sinh test fix rồi ngủ :PCode :http://simizer.com/A6V",
              url: "/spoj/qtreex"
            }
            ,

            {
              title: "[SPOJ] NKTOSS - Tung đồng xu",
              author: "itsjustwinds",
              category: ["spoj"],
              tag: ["spoj", "math", "dp"],
              content: "Link đề:http://vnoi.info/problems/show/NKTOSS/Ngày xưa, cách đây đã lâu lắm rồi, ở vương quốc Byteland tươi đẹp có một nàng công chúa xinh đẹp tuyệt trần. Thật không may, chính vì sự xinh đẹp đó đã làm phù thủy Astral đã bắt làm về làm người hầu cho ông ta. Đức Vua vô cùng hoang mang khi chuyện này xảy ra, ông không biết phải làm cách nào để giải cứu con mình (ông không thể mang quân đến đánh vì điều đó là vô nghĩa). Tuy nhiên, tên phù thủy này lại rất sợ một câu thần chú được suy ra từ việc giải một bài toán cổ của Thần Sphinx. Bài toán đó có thể được mô tả một cách đơn giản như sau: “Khi ta tung một đồng xu, ta sẽ nhận được mặt sấp hoặc ngửa. Nếu ta tung lần lượt N đồng xu thì có bao nhiêu trường hợp mà có ít nhất K đồng xu liên tiếp cùng là ngửa ?” . Đức vua hứa sẽ thưởng rất hậu hĩnh và gả công chúa cho ai giải được bài toán này. Thực ra công chúa và anh chàng làm vườn trong hoàng cung đã yêu thương nhau từ lâu. Anh chàng giờ đây đang rất bối rối và cần sự giúp đỡ của bạn.Dữ liệuMột dòng duy nhất ghi hai số N và K.Kết quảMột dòng duy nhất ghi số trường hợp đếm được.Giới hạn  1 ≤ K ≤ N ≤ 10000Ví dụDữ liệu:4 2Kết qủa8Dữ liệu:4 3Kết qủa3Hướng dẫnhttp://simizer.com/tFyChúc các bạn may mắn(lần sau) :PNhức đầu, chóng mặt, mắc ngủ?Sinh test fix bug rồi ngủ :PCode: http://simizer.com/A4O",
              url: "/spoj/nktoss"
            }
            ,

            {
              title: "[SPOJ] CHAIN2",
              author: "houtaru",
              category: ["spoj"],
              tag: ["spoj", "trie", "data-structure", "tree"],
              content: "Đề bài:http://vnoi.info/problems/show/CHAIN2/Chuỗi từ có độ dài n làmột dãy các từ w1, w2, …, wn sao cho vớimọi 1 ≤ i &lt; n, từ wi là tiền tố củatừ wi+1.Nhắc lại từ u có độdài k là tiền tố của từ v có độ dài l nếu l &gt; k và các ký tự đầu tiên của vtrùng với từ u.Cho tập hợp các từS={s1, s2, …, sm}. Tìm chuỗi từ dài nhất có thể xây dựng được bằng cách dùng cáctừ trong tập hợp S (có thể không sử dụng hết các từ).Dữ liệuDòng đầu tiên chứa sốnguyên m (1 ≤ m ≤ 250000). Mỗi dòng trong số m dòng sau chứa một từ trong tậpS.Biết rằng mỗi từ có độdài không quá 250000 ký tự và tổng độ dài của các từ không vượt quá 250000 kýtự.Kết quảIn ra một số duy nhấtlà độ dài của chuỗi từ dài nhất xây dựng được từ các từ trong tập đã cho.Solutionhttp://simizer.com/EaTCode Mẫuhttp://simizer.com/sl4",
              url: "/spoj/spoj-chain2"
            }
            ,

            {
              title: "[SPOJ] QTREE",
              author: "Admin Tổng quản",
              category: ["spoj"],
              tag: ["spoj", "tree", "heavy-light-decomposition", "data-structure"],
              content: "Link bài tập gốc (tiếng Anh)http://www.vnoi.info/problems/show/QTREE/Đề bài (tiếng Việt):Bạn được cho một đồ thị dạng cây có N đỉnh và N - 1 cạnh được đánh số bắt đầu từ 1. Bạn được yêu cầu thực hiện các truy vấn sau:  CHANGE i ti : đổi trọng số của cạnh thứ i thành ti  QUERY a b : tìm trọng số lớn nhất trong các cạnh trên đường đi từ a tới bInputDòng đầu tiên là một số nguyên t thể hiện số test case (t &lt;= 20). Với mỗi test case:  Dòng đầu tiên là một số nguyên N (N &lt;= 10000), N - 1 dòng tiếp theo, mỗi dòng chứa 3 số nguyên a, b, c thể hiện cạnh nối giữa 2 đỉnh a, b có trọng số c (c &lt;= 1000000)  Các dòng tiếp theo chứa các truy vấn “CHANGE i ti” và “QUERY a b”Test case kết thúc khi xuất hiện truy vấn “DONE”.Có 1 dòng trống giữa các test case.OutputVới mỗi truy vấn “QUERY”, in ra một số nguyên là kết quả của truy vấn đó.Solutionhttp://simizer.com/1EYCode mẫuhttp://simizer.com/1II",
              url: "/spoj/spoj-qtree"
            }
            ,

            {
              title: "About Us",
              author: "Admin Tổng Quản",
              category: [],
              tag: [],
              content: "Chào các bạn, mình là Admin Tổng Quản, founder của trang web Cowboy Coder :))Từng tham dự các kì thi Học sinh giỏi Quốc gia môn Tin học, những nguồn tài liệu trên mạng đã giúp mình rất nhiều trong việc cải thiện kĩ năng giải thuật - lập trình của mình. Giờ đây, khi không còn tham gia các cuộc thi học sinh giỏi, mình lại tiếp tục cùng một vài người bạn thành lập nên Cowboy Coder - trang web nhằm chia sẽ những kiến thức và kinh nghiệm lập trình cho mọi người xung quanh!Tại sao lại là Cowboy Coder?Trích dẫn từ trang wiki.c2 mà mình mạn phép dịch lại ở đây, thì:“Cowboy Coder là những lập trình viên viết code theo luật của chính họ. Họ có thể rất chi là giỏi về việc viết code, nhưng họ lại không làm theo những chuẩn mực, thủ tục, quy định hoặc bất cứ thứ gì mà môi trường làm việc nhóm đặt ra. Cowboy Coder có thể làm việc tốt khi làm một mình, hoặc trong môi trường CaveProgrammer cổ điển (ngồi một góc, dưới tầng hầm, cùng con IBM 709 cũ kĩ…), nhưng họ rất hiếm khi, nếu có thể, làm việc tốt trong một nhóm.”“Ôi vkđ, tại sao chúng nó lại đặt tên xấu cho trang của mình tới thế.”Tội lỗi là ở mình lúc đầu không có nghiên cứu kĩ :’(Chính xác thì Cowboy ở đây là nói tới Cowboy Bebop - một series phim yêu thích của mình. Khi đặt tên cho domain thì mình chỉ đơn giản là nghĩ tới sự kết hợp giữa hai cái mà mình thích, đó là code và anime, chứ mình không có biết tới Cowboy Coding là một hành vi xấu :’( Tiền trao cháo múc, không đổi được tên nữa, nên thôi đành gắn bó với nó vậy.Ở trên trang web có gì hay?  Bạn là học sinh - sinh viên và bạn muốn biết thêm về kiến thức thuật toán hay những công cụ lập trình phổ biến?  Bạn đang tham gia các cuộc thi trên mạng, nhưng rào cản ngôn ngữ khiến bạn không thể sử dụng toàn bộ khả năng của mình?  Bạn đang làm một bài khó khủng khiếp trên các trang Online Judge như SPOJ và cần sự giúp đỡ?Tại Cowboy Coder, chúng mình cung cấp cho các bạn những series bài viết không chỉ liên quan tới kiến thức lập trình mà còn về những kinh nghiệm trong nghề, được chính các bạn trong nhóm soạn thảo hoặc được tổng hợp từ nhiều nguồn uy tín. Ngoài ra, các bạn có thể tìm thấy lời giải và code hướng dẫn chất lượng cho những bài tập hay và khó trên các trang bài tập online phổ biến của học sinh Toán - Tin.Mỗi khi có những cuộc thi lập trình trên các trang Online Judge như các Codeforces Round hay các contest trên HackerRank, chúng mình cũng sẽ tham gia dịch đề bài trong thời gian diễn ra cuộc thi, và cung cấp lời giải sau khi cuộc thi kết thúc.Liên lạcBọn mình rất vui nếu bạn có thể like và follow page Cowboy Coder để nhiều người biết tới trang hơn ^^.Ngoài ra các bạn cũng có thể theo dõi nhóm trên GitHub của nhóm.Email: cowboycodervn@gmail.com.",
              url: "/about"
            }


          ];
        </script>

        <!-- Include lunr.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.0.4/fuse.min.js"></script>
        <script src="/js/search.js"></script>
      </div>

      <div class="col-sm-4">
        <aside>
          <div class="aside-section">
            <div class="label-custom">
              <span class="label-custom-text">Follow us on Facebook!</span>
            </div>

            <div class="fb-page" data-href="https://www.facebook.com/cowboycoding" data-small-header="false"
              data-adapt-container-width="true" data-hide-cover="false" data-show-facepile="true"></div>
          </div>

          <div class="aside-section">
            <div class="label-custom">
              <span class="label-custom-text">Bài viết gần đây</span>
            </div>
            <div class="recent">

              <div class="post-preview-side panel panel-default">
                <div class="post-preview-side-header">
                  <a href="/spoj/spoj-catgo-cat-go">
                    <div class="img-responsive-16by9">
                      <img class="post-preview-side-img" src="/img/uploads/[spoj] - catgo.jpg" />
                    </div>
                  </a>
                  <div class="post-preview-side-foreground"></div>
                  <div class="post-preview-side-metadata">
                    <a href="/spoj/spoj-catgo-cat-go">
                      <h4 class="post-preview-side-title">[SPOJ] CATGO - Cắt gỗ</h4>
                    </a>
                    <h5 class="post-preview-side-subtitle">06 Jan 2018</h5>
                  </div>
                </div>
                <div class="post-preview-side-body">
                  <span class="post-preview-side-text">Link đề bài: http://vnoi.info/problems/CATGO/ Đề bài: Giới hạn
                    Thời gian: 0.1s Bộ nhớ: 1536MB Mã...</span>
                </div>
              </div>

              <div class="post-preview-side panel panel-default">
                <div class="post-preview-side-header">
                  <a href="/spoj/spoj-traka-traka">
                    <div class="img-responsive-16by9">
                      <img class="post-preview-side-img" src="/img/uploads/[spoj] traka.jpg" />
                    </div>
                  </a>
                  <div class="post-preview-side-foreground"></div>
                  <div class="post-preview-side-metadata">
                    <a href="/spoj/spoj-traka-traka">
                      <h4 class="post-preview-side-title">[SPOJ] TRAKA - TRAKA</h4>
                    </a>
                    <h5 class="post-preview-side-subtitle">31 Oct 2017</h5>
                  </div>
                </div>
                <div class="post-preview-side-body">
                  <span class="post-preview-side-text">Link đề bài: http://vnoi.info/problems/show/TRAKA/ Đề bài: Có N
                    người thợ, M chiếc xe. Người thứ...</span>
                </div>
              </div>

              <div class="post-preview-side panel panel-default">
                <div class="post-preview-side-header">
                  <a href="/spoj/spoj-vosnet-social-network">
                    <div class="img-responsive-16by9">
                      <img class="post-preview-side-img" src="/img/uploads/[spoj] vosnet.jpg" />
                    </div>
                  </a>
                  <div class="post-preview-side-foreground"></div>
                  <div class="post-preview-side-metadata">
                    <a href="/spoj/spoj-vosnet-social-network">
                      <h4 class="post-preview-side-title">[SPOJ] VOSNET - Social Network</h4>
                    </a>
                    <h5 class="post-preview-side-subtitle">23 Oct 2017</h5>
                  </div>
                </div>
                <div class="post-preview-side-body">
                  <span class="post-preview-side-text">Link đề bài: http://vnoi.info/problems/show/VOSNET/ Đề bài:
                    Social Network - Một cụm từ chắc ai trong...</span>
                </div>
              </div>

              <div class="post-preview-side panel panel-default">
                <div class="post-preview-side-header">
                  <a href="/spoj/spoj-computer-may-tinh">
                    <div class="img-responsive-16by9">
                      <img class="post-preview-side-img" src="/img/uploads/[spoj]-computer.jpg" />
                    </div>
                  </a>
                  <div class="post-preview-side-foreground"></div>
                  <div class="post-preview-side-metadata">
                    <a href="/spoj/spoj-computer-may-tinh">
                      <h4 class="post-preview-side-title">[SPOJ] COMPUTER - Máy tính</h4>
                    </a>
                    <h5 class="post-preview-side-subtitle">14 Oct 2017</h5>
                  </div>
                </div>
                <div class="post-preview-side-body">
                  <span class="post-preview-side-text">Link đề bài : http://vnoi.info/problems/show/COMPUTER/ Đề bài:
                    Công ty phần mềm XYZ mới mua x...</span>
                </div>
              </div>

              <div class="post-preview-side panel panel-default">
                <div class="post-preview-side-header">
                  <a href="/article/c-co-ban-phan-27-ap-dung-c-vao-lap-trinh-thuc-te-phan-cuoi">
                    <div class="img-responsive-16by9">
                      <img class="post-preview-side-img" src="/img/uploads/C++ Co ban - Thumbnail.jpg" />
                    </div>
                  </a>
                  <div class="post-preview-side-foreground"></div>
                  <div class="post-preview-side-metadata">
                    <a href="/article/c-co-ban-phan-27-ap-dung-c-vao-lap-trinh-thuc-te-phan-cuoi">
                      <h4 class="post-preview-side-title">[C++ Cơ bản] Phần 28: Áp dụng C++ vào lập trình thực tế (phần
                        cuối)</h4>
                    </a>
                    <h5 class="post-preview-side-subtitle">13 Sep 2017</h5>
                  </div>
                </div>
                <div class="post-preview-side-body">
                  <span class="post-preview-side-text">Phần trước: [C++ Cơ bản] Phần 27: Template. Thư viện template
                    chuẩn của C++. Vậy...</span>
                </div>
              </div>

            </div>
          </div>
        </aside>
      </div>
    </div>

  </div>

  <footer>
    <div class="container">
      <h2 id="footer-contact-us">Contact us</h2>
      <p><span class="social-icon-button">
          <a class="fa-stack fa-2x" href="https://www.facebook.com/cowboycoding" target="_blank">
            <i class="fa fa-square fa-stack-2x" style="color:#3b5998;"></i>
            <i class="fa fa-facebook fa-stack" style="color:white;"></i>
          </a>
        </span>
        <span class="social-icon-button">
          <a class="fa-stack fa-2x" href="https://github.com/cowboycodervn" target="_blank">
            <i class="fa fa-square fa-stack-2x" style="color:#333;"></i>
            <i class="fa fa-github fa-stack" style="color:white;"></i>
          </a>
        </span>
        <span class="social-icon-button">
          <a class="fa-stack fa-2x" href="mailto:cowboycodervn@gmail.com" target="_blank">
            <i class="fa fa-square fa-stack-2x" style="color:red;"></i>
            <i class="fa fa-envelope fa-stack" style="color:white;"></i>
          </a>
        </span>
        <p />
      <p class="footer-paragraph">&copy; 2017 Cowboy Coder</p>
      <p class="footer-paragraph">Hosted by GitHub Page. Powered by Jekyll.</p>
    </div>
  </footer>

  <!-- jQuery library -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>

  <!-- Bootstrap -->
  <!-- Latest compiled JavaScript -->
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>

  <!-- Bootstrap Dropdown Hover JS -->
  <script src="/js/bootstrap-dropdownhover.min.js"></script>
</body>

</html>