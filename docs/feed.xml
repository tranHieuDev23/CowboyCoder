<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<generator uri="http://jekyllrb.com" version="3.5.0">Jekyll</generator>
<link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" />
<link href="http://localhost:4000/" rel="alternate" type="text/html" />
<updated>2019-12-13T09:12:48+07:00</updated>
<id>http://localhost:4000/</id>
<subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
</subtitle>
<entry>
<title>[SPOJ] CATGO - Cắt gỗ</title>
<link href="http://localhost:4000/spoj/spoj-catgo-cat-go" rel="alternate" type="text/html" title="[SPOJ] CATGO - Cắt gỗ" />
<published>2018-01-06T19:55:26+07:00</published>
<updated>2018-01-06T19:55:26+07:00</updated>
<id>http://localhost:4000/spoj/spoj-catgo-cat-go</id>
<content type="html" xml:base="http://localhost:4000/spoj/spoj-catgo-cat-go">&lt;h1 id=&quot;link-đề-bài-httpvnoiinfoproblemscatgo&quot;&gt;Link đề bài: &lt;a href=&quot;http://vnoi.info/problems/CATGO/&quot;&gt;http://vnoi.info/problems/CATGO/&lt;/a&gt;&lt;/h1&gt;

&lt;h1 id=&quot;đề-bài&quot;&gt;Đề bài:&lt;/h1&gt;
&lt;p&gt;Giới hạn
Thời gian: 0.1s
Bộ nhớ: 1536MB
Mã nguồn: 50000 bytes
Ở một xưởng gỗ có rất nhiều đoạn gỗ thừa. Để đạt năng suất cao, người ta muốn tận dụng những thanh gỗ này. Tất nhiên giá trị của mỗi đoạn gỗ sẽ phụ thuộc vào độ dài của chúng. Tuy nhiên sự phụ thuộc này không đơn giản chỉ là sự phụ thuộc tuyến tính: các thanh gỗ càng dài càng có giá trị cao. Do đó, nếu cần thiết, người ta sẽ cắt các thanh gỗ này ra làm nhiều đoạn nhỏ hơn.&lt;/p&gt;

&lt;p&gt;Người ta có một máy cắt, mỗi lần có thể cắt một thanh gỗ ra làm hai thanh có độ dài ngắn hơn. Do lưỡi cưa sẽ mòn dần trong quá trình cắt, chi phí của mỗi lần cắt sẽ được tính như sau: lần đầu sẽ mất 1VNĐ, lần thứ 2 sẽ là 2VNĐ, lần thứ 3 sẽ là 3VNĐ,…&lt;/p&gt;

&lt;p&gt;Nhiệm vụ của bạn sẽ là tính lợi nhuận lớn nhất có thể thu được từ các đoạn gỗ thừa này.&lt;/p&gt;

&lt;h2 id=&quot;dữ-liệu&quot;&gt;Dữ liệu&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Dòng đầu ghi số N, số thanh gỗ thừa.&lt;/li&gt;
  &lt;li&gt;N dòng sau, mỗi dòng ghi một số nguyên dương là độ dài của một thanh gỗ.&lt;/li&gt;
  &lt;li&gt;Dòng tiếp theo ghi số M, số độ dài có giá trị.&lt;/li&gt;
  &lt;li&gt;M dòng tiếp theo, mỗi dòng ghi 2 số nguyên dương lần lượt là độ dài của một đoạn gỗ và giá trị thu được (tính bằng VNĐ) nếu ta có đoạn gỗ đó.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;kết-quả&quot;&gt;Kết quả&lt;/h2&gt;

&lt;p&gt;Ghi ra một số duy nhất là lợi nhuận lớn nhất có được, đừng quên tính cả chi phí dùng để cắt gỗ.&lt;/p&gt;

&lt;h2 id=&quot;giới-hạn&quot;&gt;Giới hạn&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;1 ≤ N ≤ 50.&lt;/li&gt;
  &lt;li&gt;1 ≤ M ≤ 50.&lt;/li&gt;
  &lt;li&gt;Độ dài của một thanh gỗ không quá 50.&lt;/li&gt;
  &lt;li&gt;Giá trị thu được của một đoạn gỗ không quá 50.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ví-dụ&quot;&gt;Ví dụ&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Dữ liệu
2
3
4
2
1 10
2 11

Kết quả
55
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;solution-httpbrisktopiacom9wdv&quot;&gt;Solution: &lt;a href=&quot;http://brisktopia.com/9wDV&quot;&gt;http://brisktopia.com/9wDV&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id=&quot;code-httpbrisktopiacom9w0r&quot;&gt;Code: &lt;a href=&quot;http://brisktopia.com/9w0r&quot;&gt;http://brisktopia.com/9w0r&lt;/a&gt;&lt;/h2&gt;
</content>
<author>
<name>houtaru</name>
</author>
<category term="spoj" />
<category term="dp" />
<summary>Link đề bài: http://vnoi.info/problems/CATGO/Đề bài:Giới hạnThời gian: 0.1sBộ nhớ: 1536MBMã nguồn: 50000 bytesỞ một xưởng gỗ có rất nhiều đoạn gỗ thừa. Để đạt năng suất cao, người ta muốn tận dụng những thanh gỗ này. Tất nhiên giá trị của mỗi đoạn gỗ sẽ phụ thuộc vào độ dài của chúng. Tuy nhiên sự phụ thuộc này không đơn giản chỉ là sự phụ thuộc tuyến tính: các thanh gỗ càng dài càng có giá trị cao. Do đó, nếu cần thiết, người ta sẽ cắt các thanh gỗ này ra làm nhiều đoạn nhỏ hơn.Người ta có một máy cắt, mỗi lần có thể cắt một thanh gỗ ra làm hai thanh có độ dài ngắn hơn. Do lưỡi cưa sẽ mòn dần trong quá trình cắt, chi phí của mỗi lần cắt sẽ được tính như sau: lần đầu sẽ mất 1VNĐ, lần thứ 2 sẽ là 2VNĐ, lần thứ 3 sẽ là 3VNĐ,…Nhiệm vụ của bạn sẽ là tính lợi nhuận lớn nhất có thể thu được từ các đoạn gỗ thừa này.Dữ liệu  Dòng đầu ghi số N, số thanh gỗ thừa.  N dòng sau, mỗi dòng ghi một số nguyên dương là độ dài của một thanh gỗ.  Dòng tiếp theo ghi số M, số độ dài có giá trị.  M dòng tiếp theo, mỗi dòng ghi 2 số nguyên dương lần lượt là độ dài của một đoạn gỗ và giá trị thu được (tính bằng VNĐ) nếu ta có đoạn gỗ đó.Kết quảGhi ra một số duy nhất là lợi nhuận lớn nhất có được, đừng quên tính cả chi phí dùng để cắt gỗ.Giới hạn  1 ≤ N ≤ 50.  1 ≤ M ≤ 50.  Độ dài của một thanh gỗ không quá 50.  Giá trị thu được của một đoạn gỗ không quá 50.Ví dụDữ liệu23421 102 11Kết quả55Solution: http://brisktopia.com/9wDVCode: http://brisktopia.com/9w0r</summary>
</entry>
<entry>
<title>[SPOJ] TRAKA - TRAKA</title>
<link href="http://localhost:4000/spoj/spoj-traka-traka" rel="alternate" type="text/html" title="[SPOJ] TRAKA - TRAKA" />
<published>2017-10-31T01:38:52+07:00</published>
<updated>2017-10-31T01:38:52+07:00</updated>
<id>http://localhost:4000/spoj/spoj-traka-traka</id>
<content type="html" xml:base="http://localhost:4000/spoj/spoj-traka-traka">&lt;h1 id=&quot;link-đề-bài-httpvnoiinfoproblemsshowtraka&quot;&gt;Link đề bài: &lt;a href=&quot;http://vnoi.info/problems/show/TRAKA/&quot;&gt;http://vnoi.info/problems/show/TRAKA/&lt;/a&gt;&lt;/h1&gt;

&lt;h1 id=&quot;đề-bài&quot;&gt;Đề bài:&lt;/h1&gt;

&lt;p&gt;Có N người thợ, M chiếc xe. Người thứ i hoàn thành việc sửa bộ phận xe mình phụ trách với tốc độ T[i]. Xe thứ j có độ rắc rối là F[j]. Thời gian người thứ i cửa xong bộ phận người i phụ trách trên xe j trong thời gian T[i] * F[j]. Các công việc được thực hiện theo thứ tự từ người 1 -&amp;gt; n. Người i làm việc liên tục ko đc dừng lại(tức là sửa xong xe i thì đến xe i + 1). Với mỗi thời điểm t, mỗi chiếc xe chỉ được sửa bởi tối đa 1 người. Tính thời điểm bé nhất để n người sửa xong m chiếc xe.&lt;/p&gt;

&lt;h2 id=&quot;dữ-liệu&quot;&gt;Dữ Liệu:&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Dòng đầu gồm 2 số nguyên N (1 &amp;lt;= N &amp;lt;= 100 000) - số người thợ, M (1 &amp;lt;= M &amp;lt;= 100 000) - số chiếc xe cần sửa.&lt;/li&gt;
  &lt;li&gt;Dòng thứ i trong n dòng tiếp theo là T[i] - tốc độ sửa xong bộ phận người i phụ trách.&lt;/li&gt;
  &lt;li&gt;Dòng thứ j trong m dòng tiếp theo là F[j] - độ rắc rối của chiếc xe thứ j.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;kết-quả&quot;&gt;Kết quả:&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Gồm 1 dòng là kết quả của bài toán.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ví-dụ&quot;&gt;Ví dụ:&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input:

3 3
2
1
1
2
1
1

Output:

11
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;solution-httpvializercom1msr&quot;&gt;Solution: &lt;a href=&quot;http://vializer.com/1MsR&quot;&gt;http://vializer.com/1MsR&lt;/a&gt;&lt;/h2&gt;

&lt;h2 id=&quot;code-httpvializercom1k5j&quot;&gt;Code: &lt;a href=&quot;http://vializer.com/1K5j&quot;&gt;http://vializer.com/1K5j&lt;/a&gt;&lt;/h2&gt;
</content>
<author>
<name>houtaru</name>
</author>
<category term="spoj" />
<category term="shortest-path" />
<category term="geometry" />
<summary>Link đề bài: http://vnoi.info/problems/show/TRAKA/Đề bài:Có N người thợ, M chiếc xe. Người thứ i hoàn thành việc sửa bộ phận xe mình phụ trách với tốc độ T[i]. Xe thứ j có độ rắc rối là F[j]. Thời gian người thứ i cửa xong bộ phận người i phụ trách trên xe j trong thời gian T[i] * F[j]. Các công việc được thực hiện theo thứ tự từ người 1 -&amp;gt; n. Người i làm việc liên tục ko đc dừng lại(tức là sửa xong xe i thì đến xe i + 1). Với mỗi thời điểm t, mỗi chiếc xe chỉ được sửa bởi tối đa 1 người. Tính thời điểm bé nhất để n người sửa xong m chiếc xe.Dữ Liệu:  Dòng đầu gồm 2 số nguyên N (1 &amp;lt;= N &amp;lt;= 100 000) - số người thợ, M (1 &amp;lt;= M &amp;lt;= 100 000) - số chiếc xe cần sửa.  Dòng thứ i trong n dòng tiếp theo là T[i] - tốc độ sửa xong bộ phận người i phụ trách.  Dòng thứ j trong m dòng tiếp theo là F[j] - độ rắc rối của chiếc xe thứ j.Kết quả:  Gồm 1 dòng là kết quả của bài toán.Ví dụ:Input:3 3211211Output:11Solution: http://vializer.com/1MsRCode: http://vializer.com/1K5j</summary>
</entry>
<entry>
<title>[SPOJ] VOSNET - Social Network</title>
<link href="http://localhost:4000/spoj/spoj-vosnet-social-network" rel="alternate" type="text/html" title="[SPOJ] VOSNET - Social Network" />
<published>2017-10-23T23:35:50+07:00</published>
<updated>2017-10-23T23:35:50+07:00</updated>
<id>http://localhost:4000/spoj/spoj-vosnet-social-network</id>
<content type="html" xml:base="http://localhost:4000/spoj/spoj-vosnet-social-network">&lt;h1 id=&quot;link-đề-bài-httpvnoiinfoproblemsshowvosnet&quot;&gt;Link đề bài: &lt;a href=&quot;http://vnoi.info/problems/show/VOSNET/&quot;&gt;http://vnoi.info/problems/show/VOSNET/&lt;/a&gt;&lt;/h1&gt;

&lt;h1 id=&quot;đề-bài&quot;&gt;Đề bài:&lt;/h1&gt;

&lt;p&gt;Social Network - Một cụm từ chắc ai trong chúng ta đều biết! Một mạng xã hội sẽ gồm nhiều tài khoản (được biết như những người trong một xã hội) và các mối quan hệ giữa chúng (như sự quen biết giữa con người với con người).&lt;/p&gt;

&lt;p&gt;Chúng ta hãy cùng làm một “nghiên cứu” nho nhỏ về mạng xã hội. Mạng sẽ gồm N tài khoản (để đơn giản đặt tên từ 1 đến N) và M cặp quan hệ (U,V) cho biết U và V quen biết nhau.&lt;/p&gt;

&lt;p&gt;Theo dự đoán, cứ trung bình một tháng, một người sẽ quen hết tất cả những người có quen với bạn của người đó. Nói cách khác nếu:&lt;/p&gt;

&lt;p&gt;A quen với B, B quen với C;
A không quen với C
Thì sau một tháng A sẽ quen với C, và một mối quan hệ mới (A,C) được tạo thành !&lt;/p&gt;

&lt;p&gt;Sẽ đến 1 tháng, mà sẽ không có mối quan hệ mới nào được tạo thành (và sự phát triển của mạng xã hội sẽ tạm dừng, nếu không kích thích tạo thêm tài khoản mới, quan hệ mới) - người ta gọi tháng đó là tháng bão hòa.&lt;/p&gt;

&lt;p&gt;Cứ sau mỗi tháng, người ta sẽ thống kê số mối quan hệ mới được tạo thành. Dựa vào dự đoán ở trên, bạn hãy tính toán những con số quan trọng cho đó đến khi tháng bão hòa bắt đầu.&lt;/p&gt;

&lt;h2 id=&quot;input&quot;&gt;Input&lt;/h2&gt;
&lt;p&gt;Dòng đầu tiên gồm 2 số N và M;
M dòng tiếp theo, mỗi dòng gồm cặp số biểu diễn quan hệ (U,V);&lt;/p&gt;

&lt;h2 id=&quot;output&quot;&gt;Output&lt;/h2&gt;
&lt;p&gt;Một dòng duy nhất chứa 1 dãy số, số thứ i từ trái sang sẽ biểu diễn số mối quan hệ mới được tạo thành trong tháng thứ i (tất nhiên số cuối cùng sẽ là 0 - biểu diễn tháng bão hòa);&lt;/p&gt;

&lt;h2 id=&quot;example&quot;&gt;Example&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input:
6 6
1 2
2 3
3 4
4 6
2 5
5 6

Output:
7 2 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;giải-thích&quot;&gt;Giải thích:&lt;/h2&gt;
&lt;p&gt;Các mối quan hệ mới theo mỗi tháng:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;(1,3), (1,5), (2,4), (2,6), (3,5), (3,6), (4,5);&lt;/li&gt;
  &lt;li&gt;(1,4), (1,6);&lt;/li&gt;
  &lt;li&gt;Không tạo mới;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;giới-hạn&quot;&gt;Giới hạn&lt;/h2&gt;
&lt;p&gt;N ≤ 3000, M ≤ 6000;
20% số dữ liệu có N ≤ 100;&lt;/p&gt;

&lt;h1 id=&quot;solution-httptwineercom1iba&quot;&gt;Solution: &lt;a href=&quot;http://twineer.com/1IbA&quot;&gt;http://twineer.com/1IbA&lt;/a&gt;&lt;/h1&gt;

&lt;h1 id=&quot;code-httptwineercom1i8v&quot;&gt;Code: &lt;a href=&quot;http://twineer.com/1I8v&quot;&gt;http://twineer.com/1I8v&lt;/a&gt;&lt;/h1&gt;

</content>
<author>
<name>houtaru</name>
</author>
<category term="spoj" />
<category term="graph" />
<category term="math" />
<summary>Link đề bài: http://vnoi.info/problems/show/VOSNET/Đề bài:Social Network - Một cụm từ chắc ai trong chúng ta đều biết! Một mạng xã hội sẽ gồm nhiều tài khoản (được biết như những người trong một xã hội) và các mối quan hệ giữa chúng (như sự quen biết giữa con người với con người).Chúng ta hãy cùng làm một “nghiên cứu” nho nhỏ về mạng xã hội. Mạng sẽ gồm N tài khoản (để đơn giản đặt tên từ 1 đến N) và M cặp quan hệ (U,V) cho biết U và V quen biết nhau.Theo dự đoán, cứ trung bình một tháng, một người sẽ quen hết tất cả những người có quen với bạn của người đó. Nói cách khác nếu:A quen với B, B quen với C;A không quen với CThì sau một tháng A sẽ quen với C, và một mối quan hệ mới (A,C) được tạo thành !Sẽ đến 1 tháng, mà sẽ không có mối quan hệ mới nào được tạo thành (và sự phát triển của mạng xã hội sẽ tạm dừng, nếu không kích thích tạo thêm tài khoản mới, quan hệ mới) - người ta gọi tháng đó là tháng bão hòa.Cứ sau mỗi tháng, người ta sẽ thống kê số mối quan hệ mới được tạo thành. Dựa vào dự đoán ở trên, bạn hãy tính toán những con số quan trọng cho đó đến khi tháng bão hòa bắt đầu.InputDòng đầu tiên gồm 2 số N và M;M dòng tiếp theo, mỗi dòng gồm cặp số biểu diễn quan hệ (U,V);OutputMột dòng duy nhất chứa 1 dãy số, số thứ i từ trái sang sẽ biểu diễn số mối quan hệ mới được tạo thành trong tháng thứ i (tất nhiên số cuối cùng sẽ là 0 - biểu diễn tháng bão hòa);ExampleInput:6 61 22 33 44 62 55 6Output:7 2 0Giải thích:Các mối quan hệ mới theo mỗi tháng:  (1,3), (1,5), (2,4), (2,6), (3,5), (3,6), (4,5);  (1,4), (1,6);  Không tạo mới;Giới hạnN ≤ 3000, M ≤ 6000;20% số dữ liệu có N ≤ 100;Solution: http://twineer.com/1IbACode: http://twineer.com/1I8v</summary>
</entry>
<entry>
<title>[SPOJ] COMPUTER - Máy tính</title>
<link href="http://localhost:4000/spoj/spoj-computer-may-tinh" rel="alternate" type="text/html" title="[SPOJ] COMPUTER - Máy tính" />
<published>2017-10-14T09:52:05+07:00</published>
<updated>2017-10-14T09:52:05+07:00</updated>
<id>http://localhost:4000/spoj/spoj-computer-may-tinh</id>
<content type="html" xml:base="http://localhost:4000/spoj/spoj-computer-may-tinh">&lt;h2 id=&quot;link-đề-bài--httpvnoiinfoproblemsshowcomputer&quot;&gt;Link đề bài : &lt;a href=&quot;http://vnoi.info/problems/show/COMPUTER/&quot;&gt;http://vnoi.info/problems/show/COMPUTER/&lt;/a&gt;&lt;/h2&gt;

&lt;h2 id=&quot;đề-bài&quot;&gt;Đề bài:&lt;/h2&gt;
&lt;p&gt;Công ty phần mềm XYZ mới mua x máy tính để bàn và y máy tính xách tay. Giá một chiếc máy tính để bàn là a đôla còn giá một chiếc máy tính xách tay là b đôla. Để tránh sự thắc mắc giữa các phòng ban, Tổng giám đốc đã đưa ra cách phân bổ các máy tính này về n phòng ban như sau:&lt;/p&gt;

&lt;p&gt;Sắp xếp n phòng ban theo thứ tự về mức độ quan trọng của các phòng ban.
Tiến hành phân bổ các máy tính cho các phòng ban bảo đảm nếu phòng ban i có mức độ quan trọng nhỏ hơn mức độ quan trọng của phòng ban j thì tổng giá trị máy tính được phân bổ cho phòng ban i không được vượt quá tổng giá trị máy tính được phân bổ cho phòng ban j.
Phòng ban nhận được tổng giá trị máy tính nhỏ nhất là lớn nhất.
Là một lập trình viên giỏi nhưng lại thuộc phòng ban có mức độ quan trọng nhỏ nhất, Khanh muốn chứng tỏ tay nghề của mình với đồng nghiệp nên đã lập trình tính ra ngay được tổng giá trị máy tính mà phòng ban mình nhận được rồi mời bạn tính lại thử xem!&lt;/p&gt;

&lt;h1 id=&quot;yêu-cầu&quot;&gt;Yêu cầu&lt;/h1&gt;
&lt;p&gt;Cho x, a, y, b, n. Hãy tính tổng giá trị máy tính mà phòng Khanh nhận được.&lt;/p&gt;

&lt;h1 id=&quot;dữ-liệu&quot;&gt;Dữ liệu&lt;/h1&gt;
&lt;p&gt;Gồm 2 bộ dữ liệu, mỗi bộ trên một dòng, mỗi dòng chứa 5 số nguyên dương x, a, y, b, n (các số có giá trị không vượt quá 1000).&lt;/p&gt;

&lt;h1 id=&quot;kết-quả&quot;&gt;Kết quả&lt;/h1&gt;
&lt;p&gt;Gồm hai dòng là mỗi dòng là đáp án tương ứng với bộ dữ liệu vào.&lt;/p&gt;

&lt;h1 id=&quot;giới-hạn&quot;&gt;Giới hạn&lt;/h1&gt;
&lt;p&gt;50% số test có x,a,y,b,n không vượt quá 100.&lt;/p&gt;

&lt;h1 id=&quot;ví-dụ&quot;&gt;Ví dụ&lt;/h1&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Dữ liệu:
3 300 2 500 2
4 300 3 500 2

Kết quả:
900
1300
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;solution-httpyobuildercom8yjv&quot;&gt;Solution: &lt;a href=&quot;http://yobuilder.com/8Yjv&quot;&gt;http://yobuilder.com/8Yjv&lt;/a&gt;&lt;/h1&gt;
&lt;h1 id=&quot;code-httpyobuildercom8ymm&quot;&gt;Code: &lt;a href=&quot;http://yobuilder.com/8YmM&quot;&gt;http://yobuilder.com/8YmM&lt;/a&gt;&lt;/h1&gt;
</content>
<author>
<name>houtaru</name>
</author>
<category term="spoj" />
<category term="dp" />
<category term="binary-search" />
<summary>Link đề bài : http://vnoi.info/problems/show/COMPUTER/Đề bài:Công ty phần mềm XYZ mới mua x máy tính để bàn và y máy tính xách tay. Giá một chiếc máy tính để bàn là a đôla còn giá một chiếc máy tính xách tay là b đôla. Để tránh sự thắc mắc giữa các phòng ban, Tổng giám đốc đã đưa ra cách phân bổ các máy tính này về n phòng ban như sau:Sắp xếp n phòng ban theo thứ tự về mức độ quan trọng của các phòng ban.Tiến hành phân bổ các máy tính cho các phòng ban bảo đảm nếu phòng ban i có mức độ quan trọng nhỏ hơn mức độ quan trọng của phòng ban j thì tổng giá trị máy tính được phân bổ cho phòng ban i không được vượt quá tổng giá trị máy tính được phân bổ cho phòng ban j.Phòng ban nhận được tổng giá trị máy tính nhỏ nhất là lớn nhất.Là một lập trình viên giỏi nhưng lại thuộc phòng ban có mức độ quan trọng nhỏ nhất, Khanh muốn chứng tỏ tay nghề của mình với đồng nghiệp nên đã lập trình tính ra ngay được tổng giá trị máy tính mà phòng ban mình nhận được rồi mời bạn tính lại thử xem!Yêu cầuCho x, a, y, b, n. Hãy tính tổng giá trị máy tính mà phòng Khanh nhận được.Dữ liệuGồm 2 bộ dữ liệu, mỗi bộ trên một dòng, mỗi dòng chứa 5 số nguyên dương x, a, y, b, n (các số có giá trị không vượt quá 1000).Kết quảGồm hai dòng là mỗi dòng là đáp án tương ứng với bộ dữ liệu vào.Giới hạn50% số test có x,a,y,b,n không vượt quá 100.Ví dụDữ liệu:3 300 2 500 24 300 3 500 2Kết quả:9001300Solution: http://yobuilder.com/8YjvCode: http://yobuilder.com/8YmM</summary>
</entry>
<entry>
<title>[C++ Cơ bản] Phần 28: Áp dụng C++ vào lập trình thực tế (phần cuối)</title>
<link href="http://localhost:4000/article/c-co-ban-phan-27-ap-dung-c-vao-lap-trinh-thuc-te-phan-cuoi" rel="alternate" type="text/html" title="[C++ Cơ bản] Phần 28: Áp dụng C++ vào lập trình thực tế (phần cuối)" />
<published>2017-09-13T20:20:54+07:00</published>
<updated>2017-09-13T20:20:54+07:00</updated>
<id>http://localhost:4000/article/c-co-ban-phan-27-ap-dung-c-vao-lap-trinh-thuc-te-phan-cuoi</id>
<content type="html" xml:base="http://localhost:4000/article/c-co-ban-phan-27-ap-dung-c-vao-lap-trinh-thuc-te-phan-cuoi">&lt;p&gt;&lt;em&gt;Phần trước: &lt;a href=&quot;http://cowboycoder.tech/article/c-co-ban-phan-27-template-thu-vien-template-chuan-cua-c&quot;&gt;[C++ Cơ bản] Phần 27: Template. Thư viện template chuẩn của C++.&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Vậy là sau một chặng đường dài, chúng ta cuối cùng cũng đã đi đến cuối chặng đường học tập về ngôn ngữ C++ rồi, yeah :v&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/uploads/cpp-cơ-bản-28-1.gif&quot; alt=&quot;undefined&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Series bài viết mới chỉ giới thiệu cho các bạn những kiến thức cơ bản về ngôn ngữ C++. Nhằm mục đích làm cho bài viết trở nên dễ hiểu hơn, mình đã lược bỏ đi nhiều chi tiết rườm rà, chỉ để lại những đề mục quan trọng nhất. Để có thể thật sự thành thục được ngôn ngữ C++, bạn không thể chỉ mong chờ đọc xong một hai bài viết, mà cần phải vươn xa hơn, tự tìm hiểu tìm tòi và áp dụng những kiến thức học được vào trong ứng dụng thực tế.&lt;/p&gt;

&lt;p&gt;Để kết thúc series C++ Cơ bản, bài viết này sẽ giới thiệu với các bạn một số môi trường lập trình sử dụng C++ mà các bạn có thể nhanh chóng tìm 
hiểu, để đưa những kiến thức ở trong series bài viết này vào thực tiễn.&lt;/p&gt;

&lt;h1 id=&quot;microsoft-visual-studio&quot;&gt;Microsoft Visual Studio&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/img/uploads/cpp-cơ-bản-28-2.jpg&quot; alt=&quot;undefined&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Visual Studio là IDE do Microsoft phát triển, được sử dụng chủ yếu để phát triển các chương trình cho hệ điều hành Microsoft Windows. Ngoài ra IDE này còn hỗ trợ phát triển web app, website, các dịch vụ trên web và app dành cho các thiết bị di động. Visual Studio mặc định hỗ trợ các ngôn ngữ C, C++, C#, F#, VB.NET và TypeScript, nhưng có thể mở rộng ra để hỗ trợ nhiều ngôn ngữ và nền tảng hơn.&lt;/p&gt;

&lt;p&gt;Các bạn có thể tìm hiểu và download Visual Studio tại &lt;a href=&quot;https://www.visualstudio.com/&quot;&gt;https://www.visualstudio.com/&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;qt&quot;&gt;Qt&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/img/uploads/cpp-cơ-bản-28-3.jpg&quot; alt=&quot;undefined&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Qt (đọc giống như “cute”) là một framework cho phép tạo ra các ứng dụng chạy được trên nhiều nền tảng khác nhau, từ desktop, mobile tới các thiết bị IoT, mà không cần phải thực hiện nhiều thay đổi lên codebase. Qt có hai phiên bản, một phiên bản thương mại trả tiền và một phiên bản mã nguồn mở miễn phí. Các bạn có thể download phiên bản free tại &lt;a href=&quot;https://info.qt.io/download-qt-for-application-development&quot;&gt;https://info.qt.io/download-qt-for-application-development&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Hướng dẫn sử dụng Qt bằng tiếng Việt có tại &lt;a href=&quot;http://devnt.org/qt-tut-series-1/&quot;&gt;http://devnt.org/qt-tut-series-1/&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;cocos2d-x&quot;&gt;Cocos2d-x&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/img/uploads/cpp-cơ-bản-28-4.jpg&quot; alt=&quot;undefined&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Bạn muốn làm game và hi vọng trở thành Nguyễn Hà Đông với Flappy Bird thứ hai? Cocos2d-x là một framework mã nguồn mở cho phép người dùng tạo ra các game và app có giao diện đồ họa trên nhiều nền tảng. Trên stdio.vn có một series bài viết hướng dẫn đầy đủ về Cococs2d-x, từ cài đặt tới lập trình, tất cả đều bằng tiếng Việt, các bạn có thể xem thêm tại &lt;a href=&quot;https://www.stdio.vn/programs/content/2/games-va-cocos2d-x&quot;&gt;https://www.stdio.vn/programs/content/2/games-va-cocos2d-x&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;lập-trình-thi-đấu&quot;&gt;Lập trình thi đấu&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/img/uploads/cpp-cơ-bản-28-5.jpg&quot; alt=&quot;undefined&quot; /&gt;&lt;/p&gt;

&lt;p&gt;C++ cũng là một ngôn ngữ được yêu thích trong cộng đồng lập trình thi đấu. Tham gia các kì thi lập trình, bạn sẽ có thêm nhiều hiểu biết về thuật toán, kinh nghiệm trong lập trình, và làm đẹp cho hồ sơ cá nhân về sau. Các cuộc thi lập trình cũng có nhiều giải thưởng hấp dẫn dành cho những người chiến thắng.&lt;/p&gt;

&lt;p&gt;Các bạn có thể tìm hiểu thêm về lập trình thi đấu trong series bài viết Lập trình thi đấu cơ bản trên trang Cowboy Coder.&lt;/p&gt;

&lt;p&gt;Đến đây là kết thúc series bài viết C++ Cơ bản rồi. Mình rất cảm ơn các bạn đã theo dõi các bài viết của mình tới ngày hôm nay, và với những kiến thức các bạn đã học được qua cuộc hành trình này, xin chúc các bạn có nhiều thành công lớn hơn trên con đường sắp tới :))&lt;/p&gt;

</content>
<author>
<name>Admin Tổng Quản</name>
</author>
<category term="cpp-cơ-bản" />
<category term="programming" />
<summary>Phần trước: [C++ Cơ bản] Phần 27: Template. Thư viện template chuẩn của C++.Vậy là sau một chặng đường dài, chúng ta cuối cùng cũng đã đi đến cuối chặng đường học tập về ngôn ngữ C++ rồi, yeah :vSeries bài viết mới chỉ giới thiệu cho các bạn những kiến thức cơ bản về ngôn ngữ C++. Nhằm mục đích làm cho bài viết trở nên dễ hiểu hơn, mình đã lược bỏ đi nhiều chi tiết rườm rà, chỉ để lại những đề mục quan trọng nhất. Để có thể thật sự thành thục được ngôn ngữ C++, bạn không thể chỉ mong chờ đọc xong một hai bài viết, mà cần phải vươn xa hơn, tự tìm hiểu tìm tòi và áp dụng những kiến thức học được vào trong ứng dụng thực tế.Để kết thúc series C++ Cơ bản, bài viết này sẽ giới thiệu với các bạn một số môi trường lập trình sử dụng C++ mà các bạn có thể nhanh chóng tìm hiểu, để đưa những kiến thức ở trong series bài viết này vào thực tiễn.Microsoft Visual StudioVisual Studio là IDE do Microsoft phát triển, được sử dụng chủ yếu để phát triển các chương trình cho hệ điều hành Microsoft Windows. Ngoài ra IDE này còn hỗ trợ phát triển web app, website, các dịch vụ trên web và app dành cho các thiết bị di động. Visual Studio mặc định hỗ trợ các ngôn ngữ C, C++, C#, F#, VB.NET và TypeScript, nhưng có thể mở rộng ra để hỗ trợ nhiều ngôn ngữ và nền tảng hơn.Các bạn có thể tìm hiểu và download Visual Studio tại https://www.visualstudio.com/.QtQt (đọc giống như “cute”) là một framework cho phép tạo ra các ứng dụng chạy được trên nhiều nền tảng khác nhau, từ desktop, mobile tới các thiết bị IoT, mà không cần phải thực hiện nhiều thay đổi lên codebase. Qt có hai phiên bản, một phiên bản thương mại trả tiền và một phiên bản mã nguồn mở miễn phí. Các bạn có thể download phiên bản free tại https://info.qt.io/download-qt-for-application-development.Hướng dẫn sử dụng Qt bằng tiếng Việt có tại http://devnt.org/qt-tut-series-1/.Cocos2d-xBạn muốn làm game và hi vọng trở thành Nguyễn Hà Đông với Flappy Bird thứ hai? Cocos2d-x là một framework mã nguồn mở cho phép người dùng tạo ra các game và app có giao diện đồ họa trên nhiều nền tảng. Trên stdio.vn có một series bài viết hướng dẫn đầy đủ về Cococs2d-x, từ cài đặt tới lập trình, tất cả đều bằng tiếng Việt, các bạn có thể xem thêm tại https://www.stdio.vn/programs/content/2/games-va-cocos2d-x.Lập trình thi đấuC++ cũng là một ngôn ngữ được yêu thích trong cộng đồng lập trình thi đấu. Tham gia các kì thi lập trình, bạn sẽ có thêm nhiều hiểu biết về thuật toán, kinh nghiệm trong lập trình, và làm đẹp cho hồ sơ cá nhân về sau. Các cuộc thi lập trình cũng có nhiều giải thưởng hấp dẫn dành cho những người chiến thắng.Các bạn có thể tìm hiểu thêm về lập trình thi đấu trong series bài viết Lập trình thi đấu cơ bản trên trang Cowboy Coder.Đến đây là kết thúc series bài viết C++ Cơ bản rồi. Mình rất cảm ơn các bạn đã theo dõi các bài viết của mình tới ngày hôm nay, và với những kiến thức các bạn đã học được qua cuộc hành trình này, xin chúc các bạn có nhiều thành công lớn hơn trên con đường sắp tới :))</summary>
</entry>
<entry>
<title>[C++ Cơ bản] Phần 27: Template. Thư viện template chuẩn của C++.</title>
<link href="http://localhost:4000/article/c-co-ban-phan-27-template-thu-vien-template-chuan-cua-c" rel="alternate" type="text/html" title="[C++ Cơ bản] Phần 27: Template. Thư viện template chuẩn của C++." />
<published>2017-09-11T20:11:39+07:00</published>
<updated>2017-09-11T20:11:39+07:00</updated>
<id>http://localhost:4000/article/c-co-ban-phan-27-template-thu-vien-template-chuan-cua-c</id>
<content type="html" xml:base="http://localhost:4000/article/c-co-ban-phan-27-template-thu-vien-template-chuan-cua-c">&lt;p&gt;&lt;em&gt;Phần trước: &lt;a href=&quot;http://cowboycoder.tech/article/c-co-ban-phan-26-bai-thuc-hanh-game-do-vui&quot;&gt;[C++ Cơ bản] Phần 26: Bài thực hành - Game đố vui&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Giả sử ta muốn tạo ra một hàm lấy max của hai số nguyên, ta sẽ viết như sau&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
int Max(int x, int y)
{
    return (x &amp;gt; y? x : y);
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Cũng trong cùng một chương trình đó, ta muốn lấy max của hai &lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt;, ta sẽ phải viết thêm một hàm mới&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
string Max(string x, string y) // Overload
{
    return (x &amp;gt; y? x : y);
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Nếu như chỉ tới đây thôi thì không sao. Đằng này chương trình lại còn cần phải lấy max của hai giá trị kiểu &lt;code class=&quot;highlighter-rouge&quot;&gt;char&lt;/code&gt;, rồi &lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt;, của giá trị kiểu class mà ta thiết kế ra… Chả lẽ lại viết lại hết tất cả các hàm có cùng một nội dung lặp đi lặp lại? Template ra đời nhằm mục giải quyết các vấn đề như vậy.&lt;/p&gt;

&lt;h1 id=&quot;template-và-generic-programming&quot;&gt;Template và Generic programming&lt;/h1&gt;

&lt;p&gt;Generic programming là khả năng cho phép lập trình viên có thể viết chương trình có khả năng thích nghi với nhiều kiểu dữ liệu, thay vì một kiểu dữ liệu cố định. Kiểu dữ liệu được sử dụng sẽ được cung cấp khi chương trình gọi tới hàm hoặc class cài đặt generic. Trong C++, ta có thể áp dụng generic thông qua từ khóa &lt;code class=&quot;highlighter-rouge&quot;&gt;template&lt;/code&gt; (kiểu mẫu) và các tham số template. Tham số template là một kiểu tham số đặc biệt, có khả năng truyền kiểu dữ liệu/class vào để dùng trong hàm hoặc class generic.&lt;/p&gt;

&lt;p&gt;Để áp dụng generic, ta chèn thêm nội dung sau vào trước hàm hoặc class cần cài đặt:&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
template &amp;lt;/* danh sách tham số */&amp;gt;
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Trong đó danh sách tham số được liệt kê giống như tham số của hàm, trừ một điểm: kiểu dữ liệu có thể được truyền vào làm tham số, nếu kiểu dữ liệu của tham số này là &lt;code class=&quot;highlighter-rouge&quot;&gt;typename&lt;/code&gt; hoặc &lt;code class=&quot;highlighter-rouge&quot;&gt;class&lt;/code&gt;. Hai từ khóa này có giá trị như nhau trong template, nên bạn có thể sử dụng cái nào cũng được.&lt;/p&gt;

&lt;p&gt;Sau khi khai báo tham số template, ta có thể sử dụng tên của các tham số trong hàm hoặc class mục tiêu.&lt;/p&gt;

&lt;p&gt;Ví dụ với hàm max ở trên, ta muốn áp dụng generic để có một hàm max đa năng với mọi kiểu dữ liệu. Ta sẽ làm như sau:&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
template &lt;typename T=&quot;&quot;&gt; T Max(T x, T y)
{
    return (x &amp;gt; y? x : y);
}
{% endhighlight %}&lt;/typename&gt;&lt;/p&gt;

&lt;p&gt;Về sau chỉ cần gọi hàm &lt;code class=&quot;highlighter-rouge&quot;&gt;Max()&lt;/code&gt; với kiểu dữ liệu làm tham số template &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt;, chương trình sẽ tự động thay &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt; bằng kiểu dữ liệu được cung cấp trong ngoặc &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&amp;gt;&lt;/code&gt;, và chạy chương trình bình thường.&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
#include &lt;iostream&gt;&lt;/iostream&gt;&lt;/p&gt;

&lt;p&gt;using namespace std;&lt;/p&gt;

&lt;p&gt;template &lt;typename T=&quot;&quot;&gt; T Max(T x, T y)
{
    return (x &amp;gt; y? x : y);
}&lt;/typename&gt;&lt;/p&gt;

&lt;p&gt;int main()
{
    cout « Max&lt;int&gt;(2, 3) &amp;lt;&amp;lt; ' ' &amp;lt;&amp;lt; Max&lt;string&gt;(&quot;abc&quot;, &quot;adc&quot;);
    return 0;
}
{% endhighlight %}&lt;/string&gt;&lt;/int&gt;&lt;/p&gt;

&lt;p&gt;Output&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;3 adc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Ví dụ khi áp dụng với class: Một class với biến &lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt; được cung cấp kiểu dữ liệu về sau, thông qua template.&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
#include &lt;iostream&gt;&lt;/iostream&gt;&lt;/p&gt;

&lt;p&gt;using namespace std;&lt;/p&gt;

&lt;p&gt;template &lt;typename T=&quot;&quot;&gt; class Container
{
    public:
        T value;
};&lt;/typename&gt;&lt;/p&gt;

&lt;p&gt;int main()
{
    Container&lt;string&gt; stringContainer;
    stringContainer.value = &quot;Hello world!&quot;;
    Container&lt;int&gt; intContainer;
    intContainer.value = 100;
    cout &amp;lt;&amp;lt; stringContainer.value &amp;lt;&amp;lt; ' ' &amp;lt;&amp;lt; intContainer.value;
    return 0;
}
{% endhighlight %}&lt;/int&gt;&lt;/string&gt;&lt;/p&gt;

&lt;p&gt;Output&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Hello world! 100
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Chú ý rằng trong trường hợp với hàm &lt;code class=&quot;highlighter-rouge&quot;&gt;Max()&lt;/code&gt; ở trên, nếu như kiểu dữ liệu được cung cấp vào không hỗ trợ toán tử &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt; (ví dụ như một class không được overload toán tử này), hàm sẽ không thể hoạt động và chương trình sẽ báo lỗi khi dịch.&lt;/p&gt;

&lt;h1 id=&quot;ngoài-kiểu-dữ-liệu-ra-ta-có-thể-truyền-thông-tin-khác-vào-template-được-không&quot;&gt;Ngoài kiểu dữ liệu ra, ta có thể truyền thông tin khác vào template được không?&lt;/h1&gt;

&lt;p&gt;Hoàn toàn có thể! Ta chỉ cần thay &lt;code class=&quot;highlighter-rouge&quot;&gt;typename&lt;/code&gt; hoặc &lt;code class=&quot;highlighter-rouge&quot;&gt;class&lt;/code&gt; bằng kiểu dữ liệu bình thường là được. Chú ý tham số được cung cấp vào phải hoàn toàn xác định vào thời điểm dịch chương trình (có thể là các giá trị được viết thẳng như &lt;code class=&quot;highlighter-rouge&quot;&gt;100&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;'a'&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;abc&quot;&lt;/code&gt;, hoặc các biến được đánh dấu là hằng số bằng từ khóa &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;). Nếu không, chương trình sẽ báo lỗi khi dịch.&lt;/p&gt;

&lt;p&gt;Ví dụ áp dụng: Class sau sẽ có một mảng có kiểu dữ liệu và kích cỡ được cung cấp về sau qua template.&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
template &amp;lt;typename T, int size&amp;gt; class Example
{
    public:
        T arr[size];
};&lt;/p&gt;

&lt;p&gt;Example&amp;lt;int, 100&amp;gt; a;
{% endhighlight %}&lt;/p&gt;

&lt;h1 id=&quot;thư-viện-template-chuẩn-stl-của-c&quot;&gt;Thư viện template chuẩn STL của C++&lt;/h1&gt;
&lt;p&gt;Như các bạn đã thấy, template cho phép chúng ta tạo ra các đoạn code đa năng, sử dụng được với nhiều kiểu dữ liệu và trong nhiều trường hợp khác nhau. Bản thân ngôn ngữ C++ cũng cung cấp cho chúng ta hệ thống thư viện STL - Standard Template Library - với rất nhiều template hàm và cấu trúc dữ liệu mạnh mẽ, sẵn sàng đáp ứng các yêu cầu của dự án lập trình.&lt;/p&gt;

&lt;p&gt;STL rất rộng lớn, để có thể bao quát được hết các thư viện sẽ mất nhiều thời gian và đòi hỏi phải áp dụng nhiều trong thực tế để có thể thuần thục được. Các bạn có thể nghiên cứu thêm về hệ thống thư viện STL trong tài liệu &lt;a href=&quot;http://www.mediafire.com/download/5o1gllos4gjkz3k/STL.pdf&quot;&gt;C++ STL for newbies&lt;/a&gt; của tác giả Điêu Xuân Mạnh.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Phần sau: &lt;a href=&quot;http://cowboycoder.tech/article/c-co-ban-phan-27-ap-dung-c-vao-lap-trinh-thuc-te-phan-cuoi&quot;&gt;[C++ Cơ bản] Phần 28: Áp dụng C++ vào lập trình thực tế (phần cuối)&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</content>
<author>
<name>Admin Tổng Quản</name>
</author>
<category term="cpp-cơ-bản" />
<category term="programming" />
<summary>Phần trước: [C++ Cơ bản] Phần 26: Bài thực hành - Game đố vuiGiả sử ta muốn tạo ra một hàm lấy max của hai số nguyên, ta sẽ viết như sauint Max(int x, int y){    return (x &amp;gt; y? x : y);}Cũng trong cùng một chương trình đó, ta muốn lấy max của hai string, ta sẽ phải viết thêm một hàm mớistring Max(string x, string y) // Overload{    return (x &amp;gt; y? x : y);}Nếu như chỉ tới đây thôi thì không sao. Đằng này chương trình lại còn cần phải lấy max của hai giá trị kiểu char, rồi double, của giá trị kiểu class mà ta thiết kế ra… Chả lẽ lại viết lại hết tất cả các hàm có cùng một nội dung lặp đi lặp lại? Template ra đời nhằm mục giải quyết các vấn đề như vậy.Template và Generic programmingGeneric programming là khả năng cho phép lập trình viên có thể viết chương trình có khả năng thích nghi với nhiều kiểu dữ liệu, thay vì một kiểu dữ liệu cố định. Kiểu dữ liệu được sử dụng sẽ được cung cấp khi chương trình gọi tới hàm hoặc class cài đặt generic. Trong C++, ta có thể áp dụng generic thông qua từ khóa template (kiểu mẫu) và các tham số template. Tham số template là một kiểu tham số đặc biệt, có khả năng truyền kiểu dữ liệu/class vào để dùng trong hàm hoặc class generic.Để áp dụng generic, ta chèn thêm nội dung sau vào trước hàm hoặc class cần cài đặt:template &amp;lt;/* danh sách tham số */&amp;gt;Trong đó danh sách tham số được liệt kê giống như tham số của hàm, trừ một điểm: kiểu dữ liệu có thể được truyền vào làm tham số, nếu kiểu dữ liệu của tham số này là typename hoặc class. Hai từ khóa này có giá trị như nhau trong template, nên bạn có thể sử dụng cái nào cũng được.Sau khi khai báo tham số template, ta có thể sử dụng tên của các tham số trong hàm hoặc class mục tiêu.Ví dụ với hàm max ở trên, ta muốn áp dụng generic để có một hàm max đa năng với mọi kiểu dữ liệu. Ta sẽ làm như sau:template &amp;lt;typename T&amp;gt; T Max(T x, T y){    return (x &amp;gt; y? x : y);}Về sau chỉ cần gọi hàm Max() với kiểu dữ liệu làm tham số template T, chương trình sẽ tự động thay T bằng kiểu dữ liệu được cung cấp trong ngoặc &amp;lt;&amp;gt;, và chạy chương trình bình thường.#include &amp;lt;iostream&amp;gt;using namespace std;template &amp;lt;typename T&amp;gt; T Max(T x, T y){    return (x &amp;gt; y? x : y);}int main(){    cout &amp;lt;&amp;lt; Max&amp;lt;int&amp;gt;(2, 3) &amp;lt;&amp;lt; ' ' &amp;lt;&amp;lt; Max&amp;lt;string&amp;gt;(&quot;abc&quot;, &quot;adc&quot;);    return 0;}Output3 adcVí dụ khi áp dụng với class: Một class với biến value được cung cấp kiểu dữ liệu về sau, thông qua template.#include &amp;lt;iostream&amp;gt;using namespace std;template &amp;lt;typename T&amp;gt; class Container{    public:        T value;};int main(){    Container&amp;lt;string&amp;gt; stringContainer;    stringContainer.value = &quot;Hello world!&quot;;    Container&amp;lt;int&amp;gt; intContainer;    intContainer.value = 100;    cout &amp;lt;&amp;lt; stringContainer.value &amp;lt;&amp;lt; ' ' &amp;lt;&amp;lt; intContainer.value;    return 0;}OutputHello world! 100Chú ý rằng trong trường hợp với hàm Max() ở trên, nếu như kiểu dữ liệu được cung cấp vào không hỗ trợ toán tử &amp;gt; (ví dụ như một class không được overload toán tử này), hàm sẽ không thể hoạt động và chương trình sẽ báo lỗi khi dịch.Ngoài kiểu dữ liệu ra, ta có thể truyền thông tin khác vào template được không?Hoàn toàn có thể! Ta chỉ cần thay typename hoặc class bằng kiểu dữ liệu bình thường là được. Chú ý tham số được cung cấp vào phải hoàn toàn xác định vào thời điểm dịch chương trình (có thể là các giá trị được viết thẳng như 100, 'a', &quot;abc&quot;, hoặc các biến được đánh dấu là hằng số bằng từ khóa const). Nếu không, chương trình sẽ báo lỗi khi dịch.Ví dụ áp dụng: Class sau sẽ có một mảng có kiểu dữ liệu và kích cỡ được cung cấp về sau qua template.template &amp;lt;typename T, int size&amp;gt; class Example{    public:        T arr[size];};Example&amp;lt;int, 100&amp;gt; a;Thư viện template chuẩn STL của C++Như các bạn đã thấy, template cho phép chúng ta tạo ra các đoạn code đa năng, sử dụng được với nhiều kiểu dữ liệu và trong nhiều trường hợp khác nhau. Bản thân ngôn ngữ C++ cũng cung cấp cho chúng ta hệ thống thư viện STL - Standard Template Library - với rất nhiều template hàm và cấu trúc dữ liệu mạnh mẽ, sẵn sàng đáp ứng các yêu cầu của dự án lập trình.STL rất rộng lớn, để có thể bao quát được hết các thư viện sẽ mất nhiều thời gian và đòi hỏi phải áp dụng nhiều trong thực tế để có thể thuần thục được. Các bạn có thể nghiên cứu thêm về hệ thống thư viện STL trong tài liệu C++ STL for newbies của tác giả Điêu Xuân Mạnh.Phần sau: [C++ Cơ bản] Phần 28: Áp dụng C++ vào lập trình thực tế (phần cuối)</summary>
</entry>
<entry>
<title>[C++ Cơ bản] Phần 26: Bài thực hành - Game đố vui</title>
<link href="http://localhost:4000/article/c-co-ban-phan-26-bai-thuc-hanh-game-do-vui" rel="alternate" type="text/html" title="[C++ Cơ bản] Phần 26: Bài thực hành - Game đố vui" />
<published>2017-09-10T14:35:26+07:00</published>
<updated>2017-09-10T14:35:26+07:00</updated>
<id>http://localhost:4000/article/c-co-ban-phan-26-bai-thuc-hanh-game-do-vui</id>
<content type="html" xml:base="http://localhost:4000/article/c-co-ban-phan-26-bai-thuc-hanh-game-do-vui">&lt;p&gt;&lt;em&gt;Phần trước: &lt;a href=&quot;http://cowboycoder.tech/article/c-co-ban-phan-25-abstract-class-class-truu-tuong&quot;&gt;[C++ Cơ bản] Phần 25: Abstract class - Class trừu tượng&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Chào mừng các bạn đến với chương trình Ai là Cốt đơ trên trang Cowboy Coder. Để có thể giành được giải thưởng 100 triệu cái hắt hơi của chương trình, các bạn sẽ phải trả lời một vài câu hỏi. Các câu hỏi sẽ có 3 dạng: Câu hỏi trắc nghiệm, Câu hỏi đúng sai và Câu hỏi nhập số. Nào, hãy cùng nhau bắt đầu chương trình!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/uploads/cpp-cơ-bản-26-1.jpg&quot; alt=&quot;undefined&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Yeah, chả ai quan tâm đâu.&lt;/p&gt;

&lt;p&gt;Nhưng nếu bây giờ bạn phải triển khai phần mềm cho chương trình trên, bạn sẽ làm như thế nào? Bài thực hành này sẽ giúp bạn tạo được một chương trình đố vui bằng C++, đồng thời cũng giúp bạn tổng quát lại các kết thức về Lập trình hướng đối tượng với C++.&lt;/p&gt;

&lt;h1 id=&quot;yêu-cầu-của-bài-thực-hành&quot;&gt;Yêu cầu của bài thực hành&lt;/h1&gt;

&lt;p&gt;Khi chương trình khởi động, ta sẽ chỉ định chương trình đọc file chứa câu hỏi. File chứa câu hỏi sẽ có nội dung như sau:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Dòng đầu tiên chứa một số &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; - số lượng câu hỏi.&lt;/li&gt;
  &lt;li&gt;Các nhóm dòng tiếp theo chứa nội dung các câu hỏi. Dòng đầu tiên là một chữ cái biểu diễn loại câu hỏi - &lt;code class=&quot;highlighter-rouge&quot;&gt;M&lt;/code&gt; (Multiple Choice) là câu hỏi trắc nghiệm 4 đáp án, &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt; (True/False) là câu hỏi đúng sai và &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; (Number) là câu hỏi nhập đáp án dạng số.&lt;/li&gt;
  &lt;li&gt;Đối với câu hỏi dạng &lt;code class=&quot;highlighter-rouge&quot;&gt;M&lt;/code&gt;, 4 dòng tiếp theo chứa nội dung của 4 đáp án &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;D&lt;/code&gt;. Sau 4 dòng này là một dòng thứ 5, chứa đáp án được viết dưới dạng chữ in hoa.&lt;/li&gt;
  &lt;li&gt;Đối với câu hỏi dạng &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt;, dòng tiếp theo chứa đáp án &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt; hoặc &lt;code class=&quot;highlighter-rouge&quot;&gt;F&lt;/code&gt; (đúng hoặc sai).&lt;/li&gt;
  &lt;li&gt;Đối với câu hỏi dạng &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;, dòng tiếp theo chứa đáp án là một số thực.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Sau khi đọc hết &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; câu hỏi, chương trình sẽ lần lượt hiện ra các câu hỏi đã đọc vào. Người dùng sẽ trả lời các câu hỏi bằng kí tự in hoa (đối với câu hỏi dạng &lt;code class=&quot;highlighter-rouge&quot;&gt;M&lt;/code&gt; hoặc &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt;), hoặc bằng số thực (nếu là câu hỏi dạng &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;). Chương trình sẽ thông báo người dùng có trả lời đúng hay không, và nếu trả lời sai, thì đáp án đúng là gì. Kết thúc chương trình, chương trình sẽ thông báo số lượng câu trả lời người dùng đã trả lời đúng.&lt;/p&gt;

&lt;p&gt;Để cho đơn giản, ta mặc định người dùng luôn luôn nhập vào đúng kiểu đáp án, để không phải mất công kiểm tra.&lt;/p&gt;

&lt;p&gt;Các bạn có thể download chương trình đã hoàn thiện ở &lt;a href=&quot;https://github.com/cowboycodervn/Basic-C---Exercise-2/raw/master/Quiz.exe&quot;&gt;đây&lt;/a&gt;, cùng với file câu hỏi mẫu ở &lt;a href=&quot;https://github.com/cowboycodervn/Basic-C---Exercise-2/blob/master/INPUT.TXT&quot;&gt;đây&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;interface-question&quot;&gt;Interface &lt;code class=&quot;highlighter-rouge&quot;&gt;Question&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;Chắc hẳn các bạn cũng đã có thể &lt;em&gt;nghe nhạc hiệu đoán được chương trình&lt;/em&gt; rồi: Chúng ta sẽ sử dụng một interface &lt;code class=&quot;highlighter-rouge&quot;&gt;Question&lt;/code&gt; chung cho 3 loại câu hỏi trên, để có thể chung đường xử lý cho cả 3 dạng câu hỏi.&lt;/p&gt;

&lt;p&gt;Một câu hỏi có 3 chức năng cần cài đặt: đọc vào nội dung câu hỏi từ file input, in ra nội dung câu hỏi, và nhận vào câu trả lời. Do đó interface &lt;code class=&quot;highlighter-rouge&quot;&gt;Question&lt;/code&gt; sẽ cần phải cài đặt 3 hàm abstract &lt;code class=&quot;highlighter-rouge&quot;&gt;readFromFile()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;printQuestion()&lt;/code&gt; và &lt;code class=&quot;highlighter-rouge&quot;&gt;getAnswer()&lt;/code&gt; tương ứng, để các subclass triển khai sau.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;readFromFile()&lt;/code&gt; nhận một tham số truyền biến là một object thuộc class &lt;code class=&quot;highlighter-rouge&quot;&gt;ifstream&lt;/code&gt; - luồng vào từ file cần nhập - và đọc nội dung câu hỏi vào object. Nhớ là tham số truyền biến, sử dụng toán tử &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt;, nếu không sẽ sinh lỗi khi dịch.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;printQuestion()&lt;/code&gt; in ra nội dung câu hỏi theo mẫu có sẵn.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;getAnswer()&lt;/code&gt; là một hàm kiểu &lt;code class=&quot;highlighter-rouge&quot;&gt;bool&lt;/code&gt;, đợi người dùng nhập câu trả lời vào, in ra thông báo phù hợp và trả lại &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt; nếu người dùng trả lời đúng, &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt; nếu trả lời sai.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;{% highlight c++ %}
class Question
{
    public:
        virtual void readFromFile(ifstream &amp;amp;fileInput) =0;
        virtual void printQuestion() =0;
        virtual bool getAnswer() =0;
};
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Đừng quên thêm thư viện fstream vào để có thể sử dụng được ifstream nhé.&lt;/p&gt;

&lt;p&gt;Sau khi có interface &lt;code class=&quot;highlighter-rouge&quot;&gt;Question&lt;/code&gt; rồi, ta có thể dễ dàng hình dung ra nội dung của hàm &lt;code class=&quot;highlighter-rouge&quot;&gt;int main()&lt;/code&gt; ở dưới thành các bước sau:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Đọc file câu hỏi vào một mảng con trỏ interface &lt;code class=&quot;highlighter-rouge&quot;&gt;Question&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Mở file câu hỏi, sử dụng câu lệnh điều kiện để quyết định dùng loại class câu hỏi nào&lt;/li&gt;
  &lt;li&gt;Duyệt qua từng câu hỏi một, in ra nội dung, và nhận lại câu trả lời từ người dùng&lt;/li&gt;
  &lt;li&gt;In ra số lượng câu trả lời đúng, và kết thúc chương trình&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tạm thời ta sẽ bỏ trống phần đọc nội dung câu hỏi tới khi cài đặt xong class của 3 dạng câu hỏi về sau.&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
char fileName[100];
int n, correctAnswer = 0; /* correctAnswer là số lượng câu trả lời đúng */
Question *allQuestion[1000];&lt;/p&gt;

&lt;p&gt;int main()
{
    cout « “Hay nhap file cau hoi: “;
    cin » fileName;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ifstream fileInput; fileInput.open(fileName);
fileInput &amp;gt;&amp;gt; n;
/* Đọc vào nội dung các câu hỏi */

for (int i = 1; i &amp;lt;= n; i ++)
{
    allQuestion[i]-&amp;gt;PrintQuestion();
    if (allQuestion[i]-&amp;gt;GetAnswer())
        correctAnswer ++;
}

cout &amp;lt;&amp;lt; &quot;So luong cau tra loi dung: &quot; &amp;lt;&amp;lt; correctAnswer;
return 0; } {% endhighlight %}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;class-multiplequestion---câu-hỏi-trắc-nghiệm&quot;&gt;Class &lt;code class=&quot;highlighter-rouge&quot;&gt;MultipleQuestion&lt;/code&gt; - câu hỏi trắc nghiệm&lt;/h1&gt;

&lt;p&gt;Dạng câu hỏi đầu tiên ta triển khai sẽ là câu hỏi trắc nghiệm - class &lt;code class=&quot;highlighter-rouge&quot;&gt;MultipleQuestion&lt;/code&gt;. Trước khi làm bất cứ thao tác gì, đừng quên tuyên bố class này là subclass của interface &lt;code class=&quot;highlighter-rouge&quot;&gt;Question&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
class MultipleQuestion: public Question
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Câu hỏi trắc nghiệm thì cần có 1 nội dung lớn, 4 lựa chon và 1 đáp án đúng. Ta sẽ lưu trữ chúng trong các object &lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt; là &lt;code class=&quot;highlighter-rouge&quot;&gt;question&lt;/code&gt; (câu hỏi), mảng &lt;code class=&quot;highlighter-rouge&quot;&gt;string choice[]&lt;/code&gt; (lựa chọn) và biến &lt;code class=&quot;highlighter-rouge&quot;&gt;char correctAnswer&lt;/code&gt; (đáp án đúng). Chẳng có lý do gì mà ta muốn công khai các nội dung này ra cả, nên ta sẽ để chúng là &lt;code class=&quot;highlighter-rouge&quot;&gt;private&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
class MultipleQuestion: public Question
{
    private:
        string question, choice[4];
        char correctAnswer;
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Giờ tới lúc triển khai việc đọc. Nội dung câu hỏi và các đáp án chiếm trọn một dòng và bao gồm cả dấu cách. Ta cần cách đọc hết cả một dòng mà không bỏ qua dấu cách. Còn nhớ hàm &lt;code class=&quot;highlighter-rouge&quot;&gt;getline()&lt;/code&gt; ở bài thực hành trước chứ?&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
    public:
        void readFromFile(ifstream &amp;amp;fileInput)
        {
            getline(fileInput, question);
            for (int i = 0; i &amp;lt; 4; i ++)
                getline(fileInput, choice[i]);
            fileInput » correctAnswer;
        }
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Việc đọc câu hỏi vào rất đơn giản, việc in nội dung ra cũng vậy. Chỉ có một điều khác biệt, đó là ta cần in ra các chữ cái đại diện cho đáp án. Trong bảng mã ASCII mà C++ sử dụng, các chữ cái &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;D&lt;/code&gt; được đặt liền nhau. Do đó ta sẽ cộng biến đếm vào giá trị của kí tự &lt;code class=&quot;highlighter-rouge&quot;&gt;'A'&lt;/code&gt;, để trả lại chữ cái in ra phù hợp - biến &lt;code class=&quot;highlighter-rouge&quot;&gt;label&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
void printQuestion()
{
    cout « question « ‘\n’;
    for (int i = 0; i &amp;lt; 4; i ++)
    {
        char label = ‘A’ + i;
        cout « label « ”: “ « choice[i] « ‘\n’;
    }
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/uploads/cpp-cơ-bản-26-2.jpg&quot; alt=&quot;undefined&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Cuối cùng là việc đọc đáp án. Công việc này cũng rất đơn giản - chỉ cần &lt;code class=&quot;highlighter-rouge&quot;&gt;cin&lt;/code&gt; đáp án vào một biến dạng &lt;code class=&quot;highlighter-rouge&quot;&gt;char&lt;/code&gt;, và kiểm tra xem đáp án có bằng với &lt;code class=&quot;highlighter-rouge&quot;&gt;correctAnswer&lt;/code&gt; hay không để in ra thông báo phù hợp.&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
bool getAnswer()
{
    char answer; cin » answer;
    if (answer == correctAnswer)
    {
        cout « “Cau tra loi dung!\n”;
        return true;
    }
    else
    {
        cout « “Cau tra loi sai! Cau tra loi dung la “ « correctAnswer « ‘\n’;
        return false;
    }
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/uploads/cpp-cơ-bản-26-3.jpg&quot; alt=&quot;undefined&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Nội dung hoàn chỉnh của class &lt;code class=&quot;highlighter-rouge&quot;&gt;MultipleQuestion&lt;/code&gt; sẽ là như sau&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
class MultipleQuestion: public Question
{
    private:
        string question, choice[4];
        char correctAnswer;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public:
    void readFromFile(ifstream &amp;amp;fileInput)
    {
        getline(fileInput, question);
        for (int i = 0; i &amp;lt; 4; i ++)
            getline(fileInput, choice[i]);
        fileInput &amp;gt;&amp;gt; correctAnswer;
    }

    void printQuestion()
    {
        cout &amp;lt;&amp;lt; question &amp;lt;&amp;lt; '\n';
        for (int i = 0; i &amp;lt; 4; i ++)
        {
            char label = 'A' + i;
            cout &amp;lt;&amp;lt; label &amp;lt;&amp;lt; &quot;: &quot; &amp;lt;&amp;lt; choice[i] &amp;lt;&amp;lt; '\n';
        }
    }

    bool getAnswer()
    {
        char answer; cin &amp;gt;&amp;gt; answer;
        if (answer == correctAnswer)
        {
            cout &amp;lt;&amp;lt; &quot;Cau tra loi dung!\n&quot;;
            return true;
        }
        else
        {
            cout &amp;lt;&amp;lt; &quot;Cau tra loi sai! Cau tra loi dung la &quot; &amp;lt;&amp;lt; correctAnswer &amp;lt;&amp;lt; '\n';
            return false;
        }
    } }; {% endhighlight %}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;class-truefalse-câu-hỏi-đúng-sai-và-class-numberquestion-câu-hỏi-dạng-số&quot;&gt;Class &lt;code class=&quot;highlighter-rouge&quot;&gt;TrueFalse&lt;/code&gt; (câu hỏi đúng sai) và class &lt;code class=&quot;highlighter-rouge&quot;&gt;NumberQuestion&lt;/code&gt; (câu hỏi dạng số)&lt;/h1&gt;

&lt;p&gt;Dạng câu hỏi đúng sai giống hệt như dạng câu hỏi &lt;code class=&quot;highlighter-rouge&quot;&gt;MultipleQuestion&lt;/code&gt;, nhưng chỉ khác là từ 4 lựa chọn ta chỉ có 2 (&lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt; hoặc &lt;code class=&quot;highlighter-rouge&quot;&gt;F&lt;/code&gt;). Do đó cách triển khai cũng chỉ khác ở việc đọc nội dung vào và ở cách nội dung được in ra mà thôi.&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
class TrueFalse: public Question
{
    private:
        string question;
        char correctAnswer;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public:
    void readFromFile(ifstream &amp;amp;fileInput)
    {
        getline(fileInput, question);
        fileInput &amp;gt;&amp;gt; correctAnswer;
    }

    void printQuestion()
    {
        cout &amp;lt;&amp;lt; question &amp;lt;&amp;lt; &quot; (T/F)\n&quot;;
    }
    
    bool getAnswer()
    {
        char answer; cin &amp;gt;&amp;gt; answer;
        if (answer == correctAnswer)
        {
            cout &amp;lt;&amp;lt; &quot;Cau tra loi dung!\n&quot;;
            return true;
        }
        else
        {
            cout &amp;lt;&amp;lt; &quot;Cau tra loi sai! Cau tra loi dung la &quot; &amp;lt;&amp;lt; correctAnswer &amp;lt;&amp;lt; '\n';
            return false;
        }
    } }; {% endhighlight %}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/img/uploads/cpp-cơ-bản-26-4.jpg&quot; alt=&quot;undefined&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Class &lt;code class=&quot;highlighter-rouge&quot;&gt;NumberQuestion&lt;/code&gt; thì giống hệt class &lt;code class=&quot;highlighter-rouge&quot;&gt;TrueFalse&lt;/code&gt;, nhưng chỉ khác là phải chuyển &lt;code class=&quot;highlighter-rouge&quot;&gt;correctAnswer&lt;/code&gt; từ một kí tự thành một số thôi. Ta chỉ cần copy lại class này, đổi tên class và đổi kiểu dữ liệu của &lt;code class=&quot;highlighter-rouge&quot;&gt;correctAnswer&lt;/code&gt; thành &lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt;, thế là xong.&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
class NumberQuestion: public Question
{
    private:
        string question;
        double correctAnswer;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public:
    void readFromFile(ifstream &amp;amp;fileInput)
    {
        getline(fileInput, question);
        fileInput &amp;gt;&amp;gt; correctAnswer;
    }

    void printQuestion()
    {
        cout &amp;lt;&amp;lt; question &amp;lt;&amp;lt; &quot; (T/F)\n&quot;;
    }

    bool getAnswer()
    {
        double answer; cin &amp;gt;&amp;gt; answer;
        if (answer == correctAnswer)
        {
            cout &amp;lt;&amp;lt; &quot;Cau tra loi dung!\n&quot;;
            return true;
        }
        else
        {
            cout &amp;lt;&amp;lt; &quot;Cau tra loi sai! Cau tra loi dung la &quot; &amp;lt;&amp;lt; correctAnswer &amp;lt;&amp;lt; '\n';
            return false;
        }
    } }; {% endhighlight %}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/img/uploads/cpp-cơ-bản-26-5.jpg&quot; alt=&quot;undefined&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;áp-dụng-3-dạng-câu-hỏi-vào-chương-trình&quot;&gt;Áp dụng 3 dạng câu hỏi vào chương trình&lt;/h1&gt;

&lt;p&gt;Sau khi cài đặt xong 3 dạng câu hỏi, ta chỉ còn một chi tiết cuối, đó là đọc nội dung của chúng từ file. Ta sẽ sử dụng câu lệnh điều kiện &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; cho việc này - nếu như biến dạng &lt;code class=&quot;highlighter-rouge&quot;&gt;char type&lt;/code&gt; (loại, tức loại của câu hỏi) đọc vào có giá trị là &lt;code class=&quot;highlighter-rouge&quot;&gt;'M'&lt;/code&gt;, câu hỏi sẽ là câu hỏi trắc nghiệm và con trỏ tương ứng phải chỉ vào một đối tượng class &lt;code class=&quot;highlighter-rouge&quot;&gt;MultipleQuestion&lt;/code&gt;. Tương tự với hai dạng kia.&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
int main()
{
    cout « “Hay nhap file cau hoi: “;
    cin » fileName;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ifstream fileInput; fileInput.open(fileName);
fileInput &amp;gt;&amp;gt; n;
for (int i = 1; i &amp;lt;= n; i ++)
{
    char questionType;
    fileInput &amp;gt;&amp;gt; questionType;
    string temp; getline(fileInput, temp); /* Dọn dẹp phần còn lại của dòng để xuống dòng */
    if (questionType == 'M')
        allQuestion[i] = new MultipleQuestion;
    if (questionType == 'T')
        allQuestion[i] = new TrueFalse;
    if (questionType == 'N')
        allQuestion[i] = new NumberQuestion; {% endhighlight %}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Cuối cùng là việc đọc nội dung câu hỏi vào đối tượng.&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
        allQuestion[i]-&amp;gt;readFromFile(fileInput);
    }
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/uploads/cpp-cơ-bản-26-6.jpg&quot; alt=&quot;undefined&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Vậy là chương trình của chúng ta đã xong rồi! Các bạn có thể xem lại code của chương trình tại &lt;a href=&quot;https://github.com/cowboycodervn/Basic-C---Exercise-2/blob/master/Quiz.cpp&quot;&gt;đây&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;bình-luận&quot;&gt;Bình luận&lt;/h1&gt;

&lt;p&gt;OOP thật sự rất tiện lợi cho việc lắp đặt và nâng cấp - với interface &lt;code class=&quot;highlighter-rouge&quot;&gt;Question&lt;/code&gt; đã được định nghĩa sẵn, ta có thể thêm vào chương trình bất cứ loại câu hỏi nào mà ta có thể nghĩ ra, với điều kiện phải overload lại 3 hàm abstract cần thiết. Giả sử ta có một class phụ trách việc hiển thị câu hỏi lên giao diện đồ họa, ta cũng có thể điều chỉnh chương trình này lại sao cho phù hợp với cấu trúc của class kia, và lắp đặt lại thành một trò chơi câu hỏi đẹp mắt.&lt;/p&gt;

&lt;p&gt;Bài thực hành này kết thúc phần học về lập trình hướng đối tượng với C++. Bài viết tiếp theo sẽ giúp các bạn làm quen với STL - thư viện template của C++ và các class quan trọng trong thư viện này.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Phần sau: &lt;a href=&quot;http://cowboycoder.tech/article/c-co-ban-phan-27-template-thu-vien-template-chuan-cua-c&quot;&gt;[C++ Cơ bản] Phần 27: Template. Thư viện template chuẩn của C++.&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</content>
<author>
<name>Admin Tổng Quản</name>
</author>
<category term="cpp-cơ-bản" />
<category term="programming" />
<summary>Phần trước: [C++ Cơ bản] Phần 25: Abstract class - Class trừu tượngChào mừng các bạn đến với chương trình Ai là Cốt đơ trên trang Cowboy Coder. Để có thể giành được giải thưởng 100 triệu cái hắt hơi của chương trình, các bạn sẽ phải trả lời một vài câu hỏi. Các câu hỏi sẽ có 3 dạng: Câu hỏi trắc nghiệm, Câu hỏi đúng sai và Câu hỏi nhập số. Nào, hãy cùng nhau bắt đầu chương trình!Yeah, chả ai quan tâm đâu.Nhưng nếu bây giờ bạn phải triển khai phần mềm cho chương trình trên, bạn sẽ làm như thế nào? Bài thực hành này sẽ giúp bạn tạo được một chương trình đố vui bằng C++, đồng thời cũng giúp bạn tổng quát lại các kết thức về Lập trình hướng đối tượng với C++.Yêu cầu của bài thực hànhKhi chương trình khởi động, ta sẽ chỉ định chương trình đọc file chứa câu hỏi. File chứa câu hỏi sẽ có nội dung như sau:  Dòng đầu tiên chứa một số n - số lượng câu hỏi.  Các nhóm dòng tiếp theo chứa nội dung các câu hỏi. Dòng đầu tiên là một chữ cái biểu diễn loại câu hỏi - M (Multiple Choice) là câu hỏi trắc nghiệm 4 đáp án, T (True/False) là câu hỏi đúng sai và N (Number) là câu hỏi nhập đáp án dạng số.  Đối với câu hỏi dạng M, 4 dòng tiếp theo chứa nội dung của 4 đáp án A, B, C, D. Sau 4 dòng này là một dòng thứ 5, chứa đáp án được viết dưới dạng chữ in hoa.  Đối với câu hỏi dạng T, dòng tiếp theo chứa đáp án T hoặc F (đúng hoặc sai).  Đối với câu hỏi dạng N, dòng tiếp theo chứa đáp án là một số thực.Sau khi đọc hết n câu hỏi, chương trình sẽ lần lượt hiện ra các câu hỏi đã đọc vào. Người dùng sẽ trả lời các câu hỏi bằng kí tự in hoa (đối với câu hỏi dạng M hoặc T), hoặc bằng số thực (nếu là câu hỏi dạng N). Chương trình sẽ thông báo người dùng có trả lời đúng hay không, và nếu trả lời sai, thì đáp án đúng là gì. Kết thúc chương trình, chương trình sẽ thông báo số lượng câu trả lời người dùng đã trả lời đúng.Để cho đơn giản, ta mặc định người dùng luôn luôn nhập vào đúng kiểu đáp án, để không phải mất công kiểm tra.Các bạn có thể download chương trình đã hoàn thiện ở đây, cùng với file câu hỏi mẫu ở đây.Interface QuestionChắc hẳn các bạn cũng đã có thể nghe nhạc hiệu đoán được chương trình rồi: Chúng ta sẽ sử dụng một interface Question chung cho 3 loại câu hỏi trên, để có thể chung đường xử lý cho cả 3 dạng câu hỏi.Một câu hỏi có 3 chức năng cần cài đặt: đọc vào nội dung câu hỏi từ file input, in ra nội dung câu hỏi, và nhận vào câu trả lời. Do đó interface Question sẽ cần phải cài đặt 3 hàm abstract readFromFile(), printQuestion() và getAnswer() tương ứng, để các subclass triển khai sau.  readFromFile() nhận một tham số truyền biến là một object thuộc class ifstream - luồng vào từ file cần nhập - và đọc nội dung câu hỏi vào object. Nhớ là tham số truyền biến, sử dụng toán tử &amp;amp;, nếu không sẽ sinh lỗi khi dịch.  printQuestion() in ra nội dung câu hỏi theo mẫu có sẵn.  getAnswer() là một hàm kiểu bool, đợi người dùng nhập câu trả lời vào, in ra thông báo phù hợp và trả lại true nếu người dùng trả lời đúng, false nếu trả lời sai.class Question{    public:        virtual void readFromFile(ifstream &amp;amp;fileInput) =0;        virtual void printQuestion() =0;        virtual bool getAnswer() =0;};Đừng quên thêm thư viện fstream vào để có thể sử dụng được ifstream nhé.Sau khi có interface Question rồi, ta có thể dễ dàng hình dung ra nội dung của hàm int main() ở dưới thành các bước sau:  Đọc file câu hỏi vào một mảng con trỏ interface Question  Mở file câu hỏi, sử dụng câu lệnh điều kiện để quyết định dùng loại class câu hỏi nào  Duyệt qua từng câu hỏi một, in ra nội dung, và nhận lại câu trả lời từ người dùng  In ra số lượng câu trả lời đúng, và kết thúc chương trìnhTạm thời ta sẽ bỏ trống phần đọc nội dung câu hỏi tới khi cài đặt xong class của 3 dạng câu hỏi về sau.char fileName[100];int n, correctAnswer = 0; /* correctAnswer là số lượng câu trả lời đúng */Question *allQuestion[1000];int main(){    cout &amp;lt;&amp;lt; &quot;Hay nhap file cau hoi: &quot;;    cin &amp;gt;&amp;gt; fileName;    ifstream fileInput; fileInput.open(fileName);    fileInput &amp;gt;&amp;gt; n;    /* Đọc vào nội dung các câu hỏi */    for (int i = 1; i &amp;lt;= n; i ++)    {        allQuestion[i]-&amp;gt;PrintQuestion();        if (allQuestion[i]-&amp;gt;GetAnswer())            correctAnswer ++;    }    cout &amp;lt;&amp;lt; &quot;So luong cau tra loi dung: &quot; &amp;lt;&amp;lt; correctAnswer;    return 0;}Class MultipleQuestion - câu hỏi trắc nghiệmDạng câu hỏi đầu tiên ta triển khai sẽ là câu hỏi trắc nghiệm - class MultipleQuestion. Trước khi làm bất cứ thao tác gì, đừng quên tuyên bố class này là subclass của interface Question.class MultipleQuestion: public QuestionCâu hỏi trắc nghiệm thì cần có 1 nội dung lớn, 4 lựa chon và 1 đáp án đúng. Ta sẽ lưu trữ chúng trong các object string là question (câu hỏi), mảng string choice[] (lựa chọn) và biến char correctAnswer (đáp án đúng). Chẳng có lý do gì mà ta muốn công khai các nội dung này ra cả, nên ta sẽ để chúng là private.class MultipleQuestion: public Question{    private:        string question, choice[4];        char correctAnswer;Giờ tới lúc triển khai việc đọc. Nội dung câu hỏi và các đáp án chiếm trọn một dòng và bao gồm cả dấu cách. Ta cần cách đọc hết cả một dòng mà không bỏ qua dấu cách. Còn nhớ hàm getline() ở bài thực hành trước chứ?    public:        void readFromFile(ifstream &amp;amp;fileInput)        {            getline(fileInput, question);            for (int i = 0; i &amp;lt; 4; i ++)                getline(fileInput, choice[i]);            fileInput &amp;gt;&amp;gt; correctAnswer;        }Việc đọc câu hỏi vào rất đơn giản, việc in nội dung ra cũng vậy. Chỉ có một điều khác biệt, đó là ta cần in ra các chữ cái đại diện cho đáp án. Trong bảng mã ASCII mà C++ sử dụng, các chữ cái A, B, C, D được đặt liền nhau. Do đó ta sẽ cộng biến đếm vào giá trị của kí tự 'A', để trả lại chữ cái in ra phù hợp - biến label.void printQuestion(){    cout &amp;lt;&amp;lt; question &amp;lt;&amp;lt; '\n';    for (int i = 0; i &amp;lt; 4; i ++)    {        char label = 'A' + i;        cout &amp;lt;&amp;lt; label &amp;lt;&amp;lt; &quot;: &quot; &amp;lt;&amp;lt; choice[i] &amp;lt;&amp;lt; '\n';    }}Cuối cùng là việc đọc đáp án. Công việc này cũng rất đơn giản - chỉ cần cin đáp án vào một biến dạng char, và kiểm tra xem đáp án có bằng với correctAnswer hay không để in ra thông báo phù hợp.bool getAnswer(){    char answer; cin &amp;gt;&amp;gt; answer;    if (answer == correctAnswer)    {        cout &amp;lt;&amp;lt; &quot;Cau tra loi dung!\n&quot;;        return true;    }    else    {        cout &amp;lt;&amp;lt; &quot;Cau tra loi sai! Cau tra loi dung la &quot; &amp;lt;&amp;lt; correctAnswer &amp;lt;&amp;lt; '\n';        return false;    }}Nội dung hoàn chỉnh của class MultipleQuestion sẽ là như sauclass MultipleQuestion: public Question{    private:        string question, choice[4];        char correctAnswer;    public:        void readFromFile(ifstream &amp;amp;fileInput)        {            getline(fileInput, question);            for (int i = 0; i &amp;lt; 4; i ++)                getline(fileInput, choice[i]);            fileInput &amp;gt;&amp;gt; correctAnswer;        }        void printQuestion()        {            cout &amp;lt;&amp;lt; question &amp;lt;&amp;lt; '\n';            for (int i = 0; i &amp;lt; 4; i ++)            {                char label = 'A' + i;                cout &amp;lt;&amp;lt; label &amp;lt;&amp;lt; &quot;: &quot; &amp;lt;&amp;lt; choice[i] &amp;lt;&amp;lt; '\n';            }        }        bool getAnswer()        {            char answer; cin &amp;gt;&amp;gt; answer;            if (answer == correctAnswer)            {                cout &amp;lt;&amp;lt; &quot;Cau tra loi dung!\n&quot;;                return true;            }            else            {                cout &amp;lt;&amp;lt; &quot;Cau tra loi sai! Cau tra loi dung la &quot; &amp;lt;&amp;lt; correctAnswer &amp;lt;&amp;lt; '\n';                return false;            }        }};Class TrueFalse (câu hỏi đúng sai) và class NumberQuestion (câu hỏi dạng số)Dạng câu hỏi đúng sai giống hệt như dạng câu hỏi MultipleQuestion, nhưng chỉ khác là từ 4 lựa chọn ta chỉ có 2 (T hoặc F). Do đó cách triển khai cũng chỉ khác ở việc đọc nội dung vào và ở cách nội dung được in ra mà thôi.class TrueFalse: public Question{    private:        string question;        char correctAnswer;    public:        void readFromFile(ifstream &amp;amp;fileInput)        {            getline(fileInput, question);            fileInput &amp;gt;&amp;gt; correctAnswer;        }        void printQuestion()        {            cout &amp;lt;&amp;lt; question &amp;lt;&amp;lt; &quot; (T/F)\n&quot;;        }                bool getAnswer()        {            char answer; cin &amp;gt;&amp;gt; answer;            if (answer == correctAnswer)            {                cout &amp;lt;&amp;lt; &quot;Cau tra loi dung!\n&quot;;                return true;            }            else            {                cout &amp;lt;&amp;lt; &quot;Cau tra loi sai! Cau tra loi dung la &quot; &amp;lt;&amp;lt; correctAnswer &amp;lt;&amp;lt; '\n';                return false;            }        }};Class NumberQuestion thì giống hệt class TrueFalse, nhưng chỉ khác là phải chuyển correctAnswer từ một kí tự thành một số thôi. Ta chỉ cần copy lại class này, đổi tên class và đổi kiểu dữ liệu của correctAnswer thành double, thế là xong.class NumberQuestion: public Question{    private:        string question;        double correctAnswer;    public:        void readFromFile(ifstream &amp;amp;fileInput)        {            getline(fileInput, question);            fileInput &amp;gt;&amp;gt; correctAnswer;        }        void printQuestion()        {            cout &amp;lt;&amp;lt; question &amp;lt;&amp;lt; &quot; (T/F)\n&quot;;        }        bool getAnswer()        {            double answer; cin &amp;gt;&amp;gt; answer;            if (answer == correctAnswer)            {                cout &amp;lt;&amp;lt; &quot;Cau tra loi dung!\n&quot;;                return true;            }            else            {                cout &amp;lt;&amp;lt; &quot;Cau tra loi sai! Cau tra loi dung la &quot; &amp;lt;&amp;lt; correctAnswer &amp;lt;&amp;lt; '\n';                return false;            }        }};Áp dụng 3 dạng câu hỏi vào chương trìnhSau khi cài đặt xong 3 dạng câu hỏi, ta chỉ còn một chi tiết cuối, đó là đọc nội dung của chúng từ file. Ta sẽ sử dụng câu lệnh điều kiện if cho việc này - nếu như biến dạng char type (loại, tức loại của câu hỏi) đọc vào có giá trị là 'M', câu hỏi sẽ là câu hỏi trắc nghiệm và con trỏ tương ứng phải chỉ vào một đối tượng class MultipleQuestion. Tương tự với hai dạng kia.int main(){    cout &amp;lt;&amp;lt; &quot;Hay nhap file cau hoi: &quot;;    cin &amp;gt;&amp;gt; fileName;    ifstream fileInput; fileInput.open(fileName);    fileInput &amp;gt;&amp;gt; n;    for (int i = 1; i &amp;lt;= n; i ++)    {        char questionType;        fileInput &amp;gt;&amp;gt; questionType;        string temp; getline(fileInput, temp); /* Dọn dẹp phần còn lại của dòng để xuống dòng */        if (questionType == 'M')            allQuestion[i] = new MultipleQuestion;        if (questionType == 'T')            allQuestion[i] = new TrueFalse;        if (questionType == 'N')            allQuestion[i] = new NumberQuestion;Cuối cùng là việc đọc nội dung câu hỏi vào đối tượng.        allQuestion[i]-&amp;gt;readFromFile(fileInput);    }Vậy là chương trình của chúng ta đã xong rồi! Các bạn có thể xem lại code của chương trình tại đây.Bình luậnOOP thật sự rất tiện lợi cho việc lắp đặt và nâng cấp - với interface Question đã được định nghĩa sẵn, ta có thể thêm vào chương trình bất cứ loại câu hỏi nào mà ta có thể nghĩ ra, với điều kiện phải overload lại 3 hàm abstract cần thiết. Giả sử ta có một class phụ trách việc hiển thị câu hỏi lên giao diện đồ họa, ta cũng có thể điều chỉnh chương trình này lại sao cho phù hợp với cấu trúc của class kia, và lắp đặt lại thành một trò chơi câu hỏi đẹp mắt.Bài thực hành này kết thúc phần học về lập trình hướng đối tượng với C++. Bài viết tiếp theo sẽ giúp các bạn làm quen với STL - thư viện template của C++ và các class quan trọng trong thư viện này.Phần sau: [C++ Cơ bản] Phần 27: Template. Thư viện template chuẩn của C++.</summary>
</entry>
<entry>
<title>[C++ Cơ bản] Phần 25: Abstract class - Class trừu tượng</title>
<link href="http://localhost:4000/article/c-co-ban-phan-25-abstract-class-class-truu-tuong" rel="alternate" type="text/html" title="[C++ Cơ bản] Phần 25: Abstract class - Class trừu tượng" />
<published>2017-09-09T07:16:12+07:00</published>
<updated>2017-09-09T07:16:12+07:00</updated>
<id>http://localhost:4000/article/c-co-ban-phan-25-abstract-class-class-truu-tuong</id>
<content type="html" xml:base="http://localhost:4000/article/c-co-ban-phan-25-abstract-class-class-truu-tuong">&lt;p&gt;&lt;em&gt;Phần trước: &lt;a href=&quot;http://cowboycoder.tech/article/c-co-ban-phan-24-overload-viet-de-chuong-trinh-con-va-toan-tu&quot;&gt;[C++ Cơ bản] Phần 24: Overload - Viết đè chương trình con và toán tử&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Ở trong các bài viết trước về tính thừa kế và overload, chúng ta có nói đến ví dụ về class &lt;code class=&quot;highlighter-rouge&quot;&gt;Shape&lt;/code&gt; và &lt;code class=&quot;highlighter-rouge&quot;&gt;Rectangle&lt;/code&gt;. Class &lt;code class=&quot;highlighter-rouge&quot;&gt;Shape&lt;/code&gt; có một chương trình con là &lt;code class=&quot;highlighter-rouge&quot;&gt;printArea()&lt;/code&gt;, cho phép chương trình in ra diện tích của hình đang được biểu diễn bởi object. Tuy nhiên chi tiết hình được biểu diễn như thế nào, phải tới subclass &lt;code class=&quot;highlighter-rouge&quot;&gt;Rectangle&lt;/code&gt; mới có. Nếu ta gọi &lt;code class=&quot;highlighter-rouge&quot;&gt;printArea()&lt;/code&gt; ở &lt;code class=&quot;highlighter-rouge&quot;&gt;Shape&lt;/code&gt;, ta chỉ in ra kết quả là &lt;code class=&quot;highlighter-rouge&quot;&gt;No data&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
class Shape
{
    public:
        virtual void printArea()
        {
            cout « “No data\n”;
        }
};&lt;/p&gt;

&lt;p&gt;class Rectangle: public Shape
{
    private:
        double width, height;
    public:
        Rectangle(double _width, double _height)
        {
            width = _width;
            height = _height;
        }&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    void printArea()
    {
        cout &amp;lt;&amp;lt; width * height &amp;lt;&amp;lt; '\n';
    } }; {% endhighlight %}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Giờ chúng ta muốn thiết kế lại class &lt;code class=&quot;highlighter-rouge&quot;&gt;Shape&lt;/code&gt; như sau: Đằng nào thì cũng không biết hình được biểu diễn như thế nào rồi, ta không cho class &lt;code class=&quot;highlighter-rouge&quot;&gt;Shape&lt;/code&gt; có chương trình con &lt;code class=&quot;highlighter-rouge&quot;&gt;printArea()&lt;/code&gt; nữa. Tất cả các subclass của &lt;code class=&quot;highlighter-rouge&quot;&gt;Shape&lt;/code&gt; phải được thừa kế và phải overload lại &lt;code class=&quot;highlighter-rouge&quot;&gt;printArea()&lt;/code&gt; (vì bây giờ chúng có biểu diễn hình cụ thể rồi). Để có thể làm được như vậy, chúng ta sử dụng abstract class - class trừu tượng.&lt;/p&gt;

&lt;h1 id=&quot;nhắc-lại-về-tính-trừu-tượng---abstraction-của-oop&quot;&gt;Nhắc lại về tính trừu tượng - abstraction của OOP&lt;/h1&gt;

&lt;p&gt;Ở trong bài viết giới thiệu về OOP, chúng ta biết rằng abstraction là tính chất cho phép các hàm và chương trình con của chương trình có thể được gọi mà không cần quan tâm về mặt cài đặt ở phía sau. Tính chất này được biểu diễn qua hai điều sau:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Thứ nhất, việc ta có thể cài đặt quyền truy cập của các yếu tố trong class, giúp ta có thể công khai các yếu tố mặt tiền của object mà vẫn giấu đi các chi tiết cài đặt ở sau. Ví dụ như ở class &lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt;, ta có thể gọi hàm &lt;code class=&quot;highlighter-rouge&quot;&gt;substr()&lt;/code&gt; để lấy một &lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt; con của &lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt;, mà không cần quan tâm hàm này cài đặt ra sao.&lt;/li&gt;
  &lt;li&gt;Thứ hai, việc ta có thể chỉ định một hàm/chương trình con ở superclass là abstract (trừu tượng) - không có thông tin về nội dung thực hiện - và bắt buộc các subclass phải overload lại hàm này để có nội dung cụ thể. Khi ta tạo một object thuộc subclass, overload các hàm abstract của superclass, và gọi hàm đã được overload thông qua superclass (ví dụ như khi ta gán con trỏ object này cho một con trỏ object superclass), hàm đã được overload ở subclass sẽ được gọi.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Bài viết này sẽ xoay quanh yếu tố thứ hai.&lt;/p&gt;

&lt;h1 id=&quot;abstract-function-hàm-trừu-tượng&quot;&gt;Abstract function (hàm trừu tượng)&lt;/h1&gt;

&lt;p&gt;Để tuyên bố một hàm trong class là abstract, ta thêm &lt;code class=&quot;highlighter-rouge&quot;&gt;=0&lt;/code&gt; vào sau định nghĩa của hàm đó, và bỏ qua phần nội dung cài đặt. Chú ý là hàm đó phải có thể overload được (sử dụng từ khóa &lt;code class=&quot;highlighter-rouge&quot;&gt;virtual&lt;/code&gt;) và có dấu chấm phẩy ở cuối định nghĩa.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;virtual kiểu_dữ_liệu_trả_lại tên_hàm(các tham số) =0;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Ví dụ: Để định nghĩa chương trình con &lt;code class=&quot;highlighter-rouge&quot;&gt;printArea()&lt;/code&gt; trong class &lt;code class=&quot;highlighter-rouge&quot;&gt;Shape&lt;/code&gt; là abstract:&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
class Shape
{
    public:
        virtual void printArea() =0;
};
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Một class có hàm abstract được gọi là một interface (giao diện), trong khi class không có hàm abstract (tất cả đều được định nghĩa) được gọi là concrete class (class cụ thể). Ta không thể tạo ra một object thuộc vào class interface được, nhưng ta có thể tạo ra subclass của chúng.&lt;/p&gt;

&lt;p&gt;Subclass của interface hoặc phải overload lại tất cả các hàm abstract, hoặc các hàm không được overload sẽ được coi là abstract, và subclass mới sẽ trở thành một interface khác. Nếu như subclass là concrete class, ta có thể tạo ra các object mới thuộc về subclass đó.&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
class Shape
{
    public:
        virtual void printArea() =0;
};&lt;/p&gt;

&lt;p&gt;class Rectangle: public Shape
{
    private:
        double width, height;
    public:
        Rectangle(double _width, double _height)
        {
            width = _width;
            height = _height;
        }&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    void printArea()
    {
        cout &amp;lt;&amp;lt; width * height &amp;lt;&amp;lt; '\n';
    } };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Rectangle rec = Rectangle(2, 3);
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Các con trỏ của interface, chỉ tới các đối tượng có superclass là interface, cũng có thể được tạo ra và truy cập vào.&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
Shape *objectPointer;
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Ví dụ thực hành: Ta có class &lt;code class=&quot;highlighter-rouge&quot;&gt;Shape&lt;/code&gt; và &lt;code class=&quot;highlighter-rouge&quot;&gt;Rectangle&lt;/code&gt; như ở trên, ngoài ra ta còn cài đặt thêm hai class nữa là &lt;code class=&quot;highlighter-rouge&quot;&gt;Circle&lt;/code&gt; (hình tròn) và &lt;code class=&quot;highlighter-rouge&quot;&gt;Triangle&lt;/code&gt; (hình tam giác). &lt;code class=&quot;highlighter-rouge&quot;&gt;Circle&lt;/code&gt; có một biến &lt;code class=&quot;highlighter-rouge&quot;&gt;double radius&lt;/code&gt; (bán kính) và diện tích của &lt;code class=&quot;highlighter-rouge&quot;&gt;Circle&lt;/code&gt; sẽ được tính bằng &lt;code class=&quot;highlighter-rouge&quot;&gt;radius * radius * 3.14&lt;/code&gt;. &lt;code class=&quot;highlighter-rouge&quot;&gt;Triangle&lt;/code&gt; có ba biến &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;, đại diện cho 3 cạnh của tam giác, và diện tích sẽ tính bằng &lt;a href=&quot;https://vi.wikipedia.org/wiki/C%C3%B4ng_th%E1%BB%A9c_Heron&quot;&gt;công thức Heron&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Sau khi cài đặt hai class trên, ta sẽ tạo ra một mảng con trỏ &lt;code class=&quot;highlighter-rouge&quot;&gt;allShape[]&lt;/code&gt;, để truy cập tới các đối tượng &lt;code class=&quot;highlighter-rouge&quot;&gt;Rectangle&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Circle&lt;/code&gt; và &lt;code class=&quot;highlighter-rouge&quot;&gt;Triangle&lt;/code&gt;, và chạy hàm &lt;code class=&quot;highlighter-rouge&quot;&gt;printArea()&lt;/code&gt; của chúng.&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
#include &lt;iostream&gt;
#include &lt;cmath&gt; /* Để sử dụng hàm tính căn sqrt() */&lt;/cmath&gt;&lt;/iostream&gt;&lt;/p&gt;

&lt;p&gt;using namespace std;&lt;/p&gt;

&lt;p&gt;class Shape
{
    public:
        virtual void printArea() =0;
};&lt;/p&gt;

&lt;p&gt;class Rectangle: public Shape
{
    private:
        double width, height;
    public:
        Rectangle(double _width, double _height) /* Constructor */
        {
            width = _width;
            height = _height;
        }&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    void printArea()
    {
        cout &amp;lt;&amp;lt; width * height &amp;lt;&amp;lt; '\n';
    } };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;class Circle: public Shape
{
    private:
        double radius;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public:
    Circle(double _radius) /* Constructor */
    {
        radius = _radius;
    }

    void printArea()
    {
        cout &amp;lt;&amp;lt; radius * radius * 3.14 &amp;lt;&amp;lt; '\n';
    } };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;class Triangle: public Shape
{
    private:
        double a, b, c;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public:
    Triangle(double _a, double _b, double _c) /* Constructor */
    {
        a = _a; b = _b; c = _c;
    }

    void printArea()
    {
        double p = (a + b + c) / 2;
        cout &amp;lt;&amp;lt; sqrt(p * (p - a) * (p - b) * (p - c)) &amp;lt;&amp;lt; '\n'; /* Công thức Heron */
    } };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Shape &lt;em&gt;allShape[] = {
    new Rectangle(3, 4),
    new Circle(1),
    new Triangle(3, 4, 5)
};
int n = 3; /&lt;/em&gt; Số lượng phần tử trong mảng */&lt;/p&gt;

&lt;p&gt;int main()
{
    for (int i = 0; i &amp;lt; n; i ++)
        allShape[i]-&amp;gt;printArea();
    return 0;
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Output&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;12
3.14
6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;tại-sao-phải-sử-dụng-abstract-function-và-interface&quot;&gt;Tại sao phải sử dụng abstract function và interface?&lt;/h1&gt;

&lt;p&gt;Lý do thứ nhất là vì với interface, ta có thể bắt buộc các subclass của interface phải cài đặt gì, đảm bảo tính đồng bộ. Giả sử bạn tạo ra một cái TV có cổng video, mà bạn không quy định cổng video đó hoạt động như thế nào, các nhà sản xuất đầu kĩ thuật số sẽ mỗi người một nẻo, cuối cùng một cái TV mà có hàng trăm kiểu đầu vào khác nhau, thế là không được. Trong lập trình cũng như vậy.&lt;/p&gt;

&lt;p&gt;Lý do thứ hai là interface cho ta khả năng nâng cấp và mở rộng - không cần biết class của anh cài đặt như thế nào, miễn class của anh thừa hưởng cái interface như thế này, thì class của anh có thể lắp vào hoạt động với class của tôi - giống như với đầu vào video của TV vậy.&lt;/p&gt;

&lt;p&gt;Lý do thứ ba là với interface, ta có thể gom chung các đối tượng cùng thừa hưởng interface với nhau (ví dụ như các hình học trong ví dụ trên đã được gom chung vào một mảng con trỏ &lt;code class=&quot;highlighter-rouge&quot;&gt;allShape[]&lt;/code&gt;) để xử lý chung.&lt;/p&gt;

&lt;p&gt;Tới đây là kết thúc phần lập trình hướng đối tượng với C++ rồi. Bài viết tiếp theo sẽ là một bài thực hành, để các bạn có thể tổng hợp lại tất cả kiến thực hướng đối tượng với C++.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Phần sau: &lt;a href=&quot;http://cowboycoder.tech/article/c-co-ban-phan-26-bai-thuc-hanh-game-do-vui&quot;&gt;[C++ Cơ bản] Phần 26: Bài thực hành - Game đố vui&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</content>
<author>
<name>Admin Tổng Quản</name>
</author>
<category term="cpp-cơ-bản" />
<category term="programming" />
<summary>Phần trước: [C++ Cơ bản] Phần 24: Overload - Viết đè chương trình con và toán tửỞ trong các bài viết trước về tính thừa kế và overload, chúng ta có nói đến ví dụ về class Shape và Rectangle. Class Shape có một chương trình con là printArea(), cho phép chương trình in ra diện tích của hình đang được biểu diễn bởi object. Tuy nhiên chi tiết hình được biểu diễn như thế nào, phải tới subclass Rectangle mới có. Nếu ta gọi printArea() ở Shape, ta chỉ in ra kết quả là No data.class Shape{    public:        virtual void printArea()        {            cout &amp;lt;&amp;lt; &quot;No data\n&quot;;        }};class Rectangle: public Shape{    private:        double width, height;    public:        Rectangle(double _width, double _height)        {            width = _width;            height = _height;        }        void printArea()        {            cout &amp;lt;&amp;lt; width * height &amp;lt;&amp;lt; '\n';        }};Giờ chúng ta muốn thiết kế lại class Shape như sau: Đằng nào thì cũng không biết hình được biểu diễn như thế nào rồi, ta không cho class Shape có chương trình con printArea() nữa. Tất cả các subclass của Shape phải được thừa kế và phải overload lại printArea() (vì bây giờ chúng có biểu diễn hình cụ thể rồi). Để có thể làm được như vậy, chúng ta sử dụng abstract class - class trừu tượng.Nhắc lại về tính trừu tượng - abstraction của OOPỞ trong bài viết giới thiệu về OOP, chúng ta biết rằng abstraction là tính chất cho phép các hàm và chương trình con của chương trình có thể được gọi mà không cần quan tâm về mặt cài đặt ở phía sau. Tính chất này được biểu diễn qua hai điều sau:  Thứ nhất, việc ta có thể cài đặt quyền truy cập của các yếu tố trong class, giúp ta có thể công khai các yếu tố mặt tiền của object mà vẫn giấu đi các chi tiết cài đặt ở sau. Ví dụ như ở class string, ta có thể gọi hàm substr() để lấy một string con của string, mà không cần quan tâm hàm này cài đặt ra sao.  Thứ hai, việc ta có thể chỉ định một hàm/chương trình con ở superclass là abstract (trừu tượng) - không có thông tin về nội dung thực hiện - và bắt buộc các subclass phải overload lại hàm này để có nội dung cụ thể. Khi ta tạo một object thuộc subclass, overload các hàm abstract của superclass, và gọi hàm đã được overload thông qua superclass (ví dụ như khi ta gán con trỏ object này cho một con trỏ object superclass), hàm đã được overload ở subclass sẽ được gọi.Bài viết này sẽ xoay quanh yếu tố thứ hai.Abstract function (hàm trừu tượng)Để tuyên bố một hàm trong class là abstract, ta thêm =0 vào sau định nghĩa của hàm đó, và bỏ qua phần nội dung cài đặt. Chú ý là hàm đó phải có thể overload được (sử dụng từ khóa virtual) và có dấu chấm phẩy ở cuối định nghĩa.virtual kiểu_dữ_liệu_trả_lại tên_hàm(các tham số) =0;Ví dụ: Để định nghĩa chương trình con printArea() trong class Shape là abstract:class Shape{    public:        virtual void printArea() =0;};Một class có hàm abstract được gọi là một interface (giao diện), trong khi class không có hàm abstract (tất cả đều được định nghĩa) được gọi là concrete class (class cụ thể). Ta không thể tạo ra một object thuộc vào class interface được, nhưng ta có thể tạo ra subclass của chúng.Subclass của interface hoặc phải overload lại tất cả các hàm abstract, hoặc các hàm không được overload sẽ được coi là abstract, và subclass mới sẽ trở thành một interface khác. Nếu như subclass là concrete class, ta có thể tạo ra các object mới thuộc về subclass đó.class Shape{    public:        virtual void printArea() =0;};class Rectangle: public Shape{    private:        double width, height;    public:        Rectangle(double _width, double _height)        {            width = _width;            height = _height;        }        void printArea()        {            cout &amp;lt;&amp;lt; width * height &amp;lt;&amp;lt; '\n';        }};Rectangle rec = Rectangle(2, 3);Các con trỏ của interface, chỉ tới các đối tượng có superclass là interface, cũng có thể được tạo ra và truy cập vào.Shape *objectPointer;Ví dụ thực hành: Ta có class Shape và Rectangle như ở trên, ngoài ra ta còn cài đặt thêm hai class nữa là Circle (hình tròn) và Triangle (hình tam giác). Circle có một biến double radius (bán kính) và diện tích của Circle sẽ được tính bằng radius * radius * 3.14. Triangle có ba biến a, b, c, đại diện cho 3 cạnh của tam giác, và diện tích sẽ tính bằng công thức Heron.Sau khi cài đặt hai class trên, ta sẽ tạo ra một mảng con trỏ allShape[], để truy cập tới các đối tượng Rectangle, Circle và Triangle, và chạy hàm printArea() của chúng.#include &amp;lt;iostream&amp;gt;#include &amp;lt;cmath&amp;gt; /* Để sử dụng hàm tính căn sqrt() */using namespace std;class Shape{    public:        virtual void printArea() =0;};class Rectangle: public Shape{    private:        double width, height;    public:        Rectangle(double _width, double _height) /* Constructor */        {            width = _width;            height = _height;        }        void printArea()        {            cout &amp;lt;&amp;lt; width * height &amp;lt;&amp;lt; '\n';        }};class Circle: public Shape{    private:        double radius;    public:        Circle(double _radius) /* Constructor */        {            radius = _radius;        }        void printArea()        {            cout &amp;lt;&amp;lt; radius * radius * 3.14 &amp;lt;&amp;lt; '\n';        }};class Triangle: public Shape{    private:        double a, b, c;    public:        Triangle(double _a, double _b, double _c) /* Constructor */        {            a = _a; b = _b; c = _c;        }        void printArea()        {            double p = (a + b + c) / 2;            cout &amp;lt;&amp;lt; sqrt(p * (p - a) * (p - b) * (p - c)) &amp;lt;&amp;lt; '\n'; /* Công thức Heron */        }};Shape *allShape[] = {    new Rectangle(3, 4),    new Circle(1),    new Triangle(3, 4, 5)};int n = 3; /* Số lượng phần tử trong mảng */int main(){    for (int i = 0; i &amp;lt; n; i ++)        allShape[i]-&amp;gt;printArea();    return 0;}Output123.146Tại sao phải sử dụng abstract function và interface?Lý do thứ nhất là vì với interface, ta có thể bắt buộc các subclass của interface phải cài đặt gì, đảm bảo tính đồng bộ. Giả sử bạn tạo ra một cái TV có cổng video, mà bạn không quy định cổng video đó hoạt động như thế nào, các nhà sản xuất đầu kĩ thuật số sẽ mỗi người một nẻo, cuối cùng một cái TV mà có hàng trăm kiểu đầu vào khác nhau, thế là không được. Trong lập trình cũng như vậy.Lý do thứ hai là interface cho ta khả năng nâng cấp và mở rộng - không cần biết class của anh cài đặt như thế nào, miễn class của anh thừa hưởng cái interface như thế này, thì class của anh có thể lắp vào hoạt động với class của tôi - giống như với đầu vào video của TV vậy.Lý do thứ ba là với interface, ta có thể gom chung các đối tượng cùng thừa hưởng interface với nhau (ví dụ như các hình học trong ví dụ trên đã được gom chung vào một mảng con trỏ allShape[]) để xử lý chung.Tới đây là kết thúc phần lập trình hướng đối tượng với C++ rồi. Bài viết tiếp theo sẽ là một bài thực hành, để các bạn có thể tổng hợp lại tất cả kiến thực hướng đối tượng với C++.Phần sau: [C++ Cơ bản] Phần 26: Bài thực hành - Game đố vui</summary>
</entry>
<entry>
<title>[C++ Cơ bản] Phần 24: Overload - Viết đè chương trình con và toán tử</title>
<link href="http://localhost:4000/article/c-co-ban-phan-24-overload-viet-de-chuong-trinh-con-va-toan-tu" rel="alternate" type="text/html" title="[C++ Cơ bản] Phần 24: Overload - Viết đè chương trình con và toán tử" />
<published>2017-09-08T21:26:14+07:00</published>
<updated>2017-09-08T21:26:14+07:00</updated>
<id>http://localhost:4000/article/c-co-ban-phan-24-overload-viet-de-chuong-trinh-con-va-toan-tu</id>
<content type="html" xml:base="http://localhost:4000/article/c-co-ban-phan-24-overload-viet-de-chuong-trinh-con-va-toan-tu">&lt;p&gt;&lt;em&gt;Phần trước: &lt;a href=&quot;http://cowboycoder.tech/article/c-co-ban-phan-23-tinh-thua-ke-class-con-subclass&quot;&gt;[C++ Cơ bản] Phần 23: Tính thừa kế - Class con (subclass)&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Chúng ta đều biết hai kiểu dữ liệu số nguyên &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt; và &lt;code class=&quot;highlighter-rouge&quot;&gt;long long int&lt;/code&gt; đều có giới hạn về khoảng biểu diễn. Sẽ xảy ra trường hợp ta cần phải tự triển khai một kiểu dữ liệu số riêng để vượt qua các giới hạn ấy. Ý tưởng là tạo một class biểu diễn số bằng một string các kí tự chữ số. Vậy làm thế nào để có thể viết toán tử cộng trừ nhân chia cho class mới này?&lt;/p&gt;

&lt;p&gt;Trong bài viết này chúng ta sẽ học về overload - khả năng viết đè các chương trình con và toán tử đã định nghĩa từ trước.&lt;/p&gt;

&lt;h1 id=&quot;overload-chương-trình-con-trong-chương-trình-c&quot;&gt;Overload chương trình con trong chương trình C++&lt;/h1&gt;

&lt;p&gt;C++ cho phép chúng ta có nhiều chương trình con có cùng tên với nhau, với điều kiện là các biến tham số của mỗi một cá thể phải khác nhau - có thể khác nhau về số lượng hoặc về kiểu dữ liệu của tham số.&lt;/p&gt;

&lt;p&gt;Ví dụ:&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
#include &lt;iostream&gt;&lt;/iostream&gt;&lt;/p&gt;

&lt;p&gt;using namespace std;&lt;/p&gt;

&lt;p&gt;void print(int x)
{
    cout « “Int: “ « x « ‘\n’;
}&lt;/p&gt;

&lt;p&gt;void print(double x)
{
    cout « “Double: “ « x « ‘\n’;
}&lt;/p&gt;

&lt;p&gt;void print(string x)
{
    cout « “String: “ « x « ‘\n’;
}&lt;/p&gt;

&lt;p&gt;int main()
{
    print(1);
    print(3.14);
    print(“Hello world!”);
    return 0;
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Output&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Int: 1
Double: 3.14
String: Hello world!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Bộ dịch C++ sẽ tự động quyết định cá thể nào của chương trình con sẽ được chạy, dựa vào kiểu dữ liệu của tham số được cung cấp.&lt;/p&gt;

&lt;h1 id=&quot;overload-chương-trình-con-của-class-cha&quot;&gt;Overload chương trình con của class cha&lt;/h1&gt;

&lt;p&gt;Giả sử chúng ta có hai class &lt;code class=&quot;highlighter-rouge&quot;&gt;Shape&lt;/code&gt; (hình nói chung) và &lt;code class=&quot;highlighter-rouge&quot;&gt;Rectangle&lt;/code&gt; (hình chữ nhật), trong đó &lt;code class=&quot;highlighter-rouge&quot;&gt;Rectangle&lt;/code&gt; là subclass của &lt;code class=&quot;highlighter-rouge&quot;&gt;Shape&lt;/code&gt;. Hai class này đều có một hàm &lt;code class=&quot;highlighter-rouge&quot;&gt;printArea()&lt;/code&gt; để in diện tích của hình.&lt;/p&gt;

&lt;p&gt;Đối với class &lt;code class=&quot;highlighter-rouge&quot;&gt;Shape&lt;/code&gt;, do không có thông số cụ thể để định nghĩa hình, nên ta sẽ in ra dòng chữ &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;No data&quot;&lt;/code&gt; rồi xuống dòng.&lt;/p&gt;

&lt;p&gt;Đối với class &lt;code class=&quot;highlighter-rouge&quot;&gt;Rectangle&lt;/code&gt;, ta có hai biến &lt;code class=&quot;highlighter-rouge&quot;&gt;private&lt;/code&gt; kiểu &lt;code class=&quot;highlighter-rouge&quot;&gt;double width&lt;/code&gt; và &lt;code class=&quot;highlighter-rouge&quot;&gt;height&lt;/code&gt; - chiều rộng và chiều dài của hình chữ nhật. Khi gọi hàm &lt;code class=&quot;highlighter-rouge&quot;&gt;printArea()&lt;/code&gt; ta sẽ in ra diện tích của hình chữ nhật bằng &lt;code class=&quot;highlighter-rouge&quot;&gt;width * height&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Ta triển khai chương trình như sau:&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
#include &lt;iostream&gt;&lt;/iostream&gt;&lt;/p&gt;

&lt;p&gt;using namespace std;&lt;/p&gt;

&lt;p&gt;class Shape
{
    public:
        void printArea()
        {
            cout « “No data\n”;
        }
};&lt;/p&gt;

&lt;p&gt;class Rectangle: public Shape
{
    private:
        double width, height;
    public:
        Rectangle(double _width, double _height)
        {
            width = _width;
            height = _height;
        }&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    void printArea()
    {
        cout &amp;lt;&amp;lt; width * height &amp;lt;&amp;lt; '\n';
    } };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;int main()
{
    Shape* rec = new Rectangle(2, 3);
    rec -&amp;gt; printArea();
    return 0;
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Output&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;No data
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Hãy quan sát con trỏ object &lt;code class=&quot;highlighter-rouge&quot;&gt;rec&lt;/code&gt; ở dưới - không ổn lắm nhỉ. Đúng đây là một object thuộc class &lt;code class=&quot;highlighter-rouge&quot;&gt;Shape&lt;/code&gt; rồi, nhưng đây cũng là một object dạng &lt;code class=&quot;highlighter-rouge&quot;&gt;Rectangle&lt;/code&gt;. Khi ra lệnh chạy hàm &lt;code class=&quot;highlighter-rouge&quot;&gt;printArea()&lt;/code&gt; mà in ra &lt;code class=&quot;highlighter-rouge&quot;&gt;No data&lt;/code&gt; thì không được, ta muốn nó phải in ra như của class &lt;code class=&quot;highlighter-rouge&quot;&gt;Rectangle&lt;/code&gt; cơ.&lt;/p&gt;

&lt;p&gt;Giải pháp là overload hàm &lt;code class=&quot;highlighter-rouge&quot;&gt;printArea()&lt;/code&gt; của class &lt;code class=&quot;highlighter-rouge&quot;&gt;Shape&lt;/code&gt;. Để quy định một hàm trong class là hàm có thể overload được ở subclass, ta sử dụng từ khóa &lt;code class=&quot;highlighter-rouge&quot;&gt;virtual&lt;/code&gt;. Khi ta gọi một hàm từ con trỏ hoặc tham chiếu của một object, chương trình C++ sẽ xem xét class gốc của con trỏ hoặc tham chiếu là gì, và quyết định sử dụng hàm nào để chạy.&lt;/p&gt;

&lt;p&gt;Chỉ cần thêm từ khóa vào trước &lt;code class=&quot;highlighter-rouge&quot;&gt;void printArea()&lt;/code&gt; của class &lt;code class=&quot;highlighter-rouge&quot;&gt;Shape&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
virtual void printArea()
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Rồi chạy chương trình. Output sẽ ra &lt;code class=&quot;highlighter-rouge&quot;&gt;6&lt;/code&gt; - kết quả của việc chạy hàm &lt;code class=&quot;highlighter-rouge&quot;&gt;printArea()&lt;/code&gt; trên class &lt;code class=&quot;highlighter-rouge&quot;&gt;Rectangle&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Đây chính là cách polymorphism - tính đa hình của OOP - được biểu diễn trong C++.&lt;/p&gt;

&lt;p&gt;Chú ý là tính chất này chỉ xảy ra khi chạy hàm thông qua con trỏ hoặc tham chiếu - một khi đã gán vào một object thuộc superclass, object đó trở thành một object hoàn toàn độc lập, thuộc hẳn về superclass, nên sẽ chạy hàm gốc chứ không chạy hàm overload.&lt;/p&gt;

&lt;h1 id=&quot;overload-toán-tử&quot;&gt;Overload toán tử&lt;/h1&gt;

&lt;p&gt;Ta cũng có thể định nghĩa lại hoặc định nghĩa mới phần lớn các toán tử trong C++, để áp dụng vào các class ta tạo ra. Để overload toán tử ta sử dụng từ khóa &lt;code class=&quot;highlighter-rouge&quot;&gt;operator&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Lấy ví dụ với class &lt;code class=&quot;highlighter-rouge&quot;&gt;BigInt&lt;/code&gt; như ở đầu bài viết yêu cầu. Có hai phương pháp overload operator.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Overload bên trong class. Khi đó ta chỉ cần cung cấp giá trị bên phải toán tử làm tham số.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;{% highlight c++ %}
class BigInteger
{
    BigInteger operator + (BigInteger x)
    {
        return x;
    }
};
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Overload bên ngoài class, như một hàm của chương trình lớn. Khi đó ta cần cung cấp giá trị hai bên toán tử.&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
class BigInteger
{
    //nội dung;
};&lt;/p&gt;

&lt;p&gt;BigInteger operator + (BigInteger x, BigInteger y)
{
    //nội dung;
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Hãy để ý rằng các phép toán tử này cũng có kiểu dữ liệu trả về, giống như một chương trình con bình thường vậy - thực chất chúng cũng là chương trình con, nhưng được gọi bằng các toán tử thay vì bằng tên.&lt;/p&gt;

&lt;p&gt;Ta có thể overload tất cả các toán tử trong C++, trừ toán tử truy cập scope &lt;code class=&quot;highlighter-rouge&quot;&gt;::&lt;/code&gt;, toán tử truy cập yếu tố trong class &lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;, toán tử điều kiện &lt;code class=&quot;highlighter-rouge&quot;&gt;?:&lt;/code&gt; và toán tử tham chiếu yếu tố của class &lt;code class=&quot;highlighter-rouge&quot;&gt;.*&lt;/code&gt; (mà bạn chưa cần phải quan tâm ở đây).&lt;/p&gt;

&lt;p&gt;Subclass sẽ không được thừa hưởng các toán tử được overload của superclass.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Phần sau: &lt;a href=&quot;http://cowboycoder.tech/article/c-co-ban-phan-25-abstract-class-class-truu-tuong&quot;&gt;[C++ Cơ bản] Phần 25: Abstract class - Class trừu tượng&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

</content>
<author>
<name>Admin Tổng Quản</name>
</author>
<category term="cpp-cơ-bản" />
<category term="programming" />
<summary>Phần trước: [C++ Cơ bản] Phần 23: Tính thừa kế - Class con (subclass)Chúng ta đều biết hai kiểu dữ liệu số nguyên int và long long int đều có giới hạn về khoảng biểu diễn. Sẽ xảy ra trường hợp ta cần phải tự triển khai một kiểu dữ liệu số riêng để vượt qua các giới hạn ấy. Ý tưởng là tạo một class biểu diễn số bằng một string các kí tự chữ số. Vậy làm thế nào để có thể viết toán tử cộng trừ nhân chia cho class mới này?Trong bài viết này chúng ta sẽ học về overload - khả năng viết đè các chương trình con và toán tử đã định nghĩa từ trước.Overload chương trình con trong chương trình C++C++ cho phép chúng ta có nhiều chương trình con có cùng tên với nhau, với điều kiện là các biến tham số của mỗi một cá thể phải khác nhau - có thể khác nhau về số lượng hoặc về kiểu dữ liệu của tham số.Ví dụ:#include &amp;lt;iostream&amp;gt;using namespace std;void print(int x){    cout &amp;lt;&amp;lt; &quot;Int: &quot; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; '\n';}void print(double x){    cout &amp;lt;&amp;lt; &quot;Double: &quot; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; '\n';}void print(string x){    cout &amp;lt;&amp;lt; &quot;String: &quot; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; '\n';}int main(){    print(1);    print(3.14);    print(&quot;Hello world!&quot;);    return 0;}OutputInt: 1Double: 3.14String: Hello world!Bộ dịch C++ sẽ tự động quyết định cá thể nào của chương trình con sẽ được chạy, dựa vào kiểu dữ liệu của tham số được cung cấp.Overload chương trình con của class chaGiả sử chúng ta có hai class Shape (hình nói chung) và Rectangle (hình chữ nhật), trong đó Rectangle là subclass của Shape. Hai class này đều có một hàm printArea() để in diện tích của hình.Đối với class Shape, do không có thông số cụ thể để định nghĩa hình, nên ta sẽ in ra dòng chữ &quot;No data&quot; rồi xuống dòng.Đối với class Rectangle, ta có hai biến private kiểu double width và height - chiều rộng và chiều dài của hình chữ nhật. Khi gọi hàm printArea() ta sẽ in ra diện tích của hình chữ nhật bằng width * height.Ta triển khai chương trình như sau:#include &amp;lt;iostream&amp;gt;using namespace std;class Shape{    public:        void printArea()        {            cout &amp;lt;&amp;lt; &quot;No data\n&quot;;        }};class Rectangle: public Shape{    private:        double width, height;    public:        Rectangle(double _width, double _height)        {            width = _width;            height = _height;        }        void printArea()        {            cout &amp;lt;&amp;lt; width * height &amp;lt;&amp;lt; '\n';        }};int main(){    Shape* rec = new Rectangle(2, 3);    rec -&amp;gt; printArea();    return 0;}OutputNo dataHãy quan sát con trỏ object rec ở dưới - không ổn lắm nhỉ. Đúng đây là một object thuộc class Shape rồi, nhưng đây cũng là một object dạng Rectangle. Khi ra lệnh chạy hàm printArea() mà in ra No data thì không được, ta muốn nó phải in ra như của class Rectangle cơ.Giải pháp là overload hàm printArea() của class Shape. Để quy định một hàm trong class là hàm có thể overload được ở subclass, ta sử dụng từ khóa virtual. Khi ta gọi một hàm từ con trỏ hoặc tham chiếu của một object, chương trình C++ sẽ xem xét class gốc của con trỏ hoặc tham chiếu là gì, và quyết định sử dụng hàm nào để chạy.Chỉ cần thêm từ khóa vào trước void printArea() của class Shapevirtual void printArea()Rồi chạy chương trình. Output sẽ ra 6 - kết quả của việc chạy hàm printArea() trên class Rectangle.Đây chính là cách polymorphism - tính đa hình của OOP - được biểu diễn trong C++.Chú ý là tính chất này chỉ xảy ra khi chạy hàm thông qua con trỏ hoặc tham chiếu - một khi đã gán vào một object thuộc superclass, object đó trở thành một object hoàn toàn độc lập, thuộc hẳn về superclass, nên sẽ chạy hàm gốc chứ không chạy hàm overload.Overload toán tửTa cũng có thể định nghĩa lại hoặc định nghĩa mới phần lớn các toán tử trong C++, để áp dụng vào các class ta tạo ra. Để overload toán tử ta sử dụng từ khóa operator.Lấy ví dụ với class BigInt như ở đầu bài viết yêu cầu. Có hai phương pháp overload operator.  Overload bên trong class. Khi đó ta chỉ cần cung cấp giá trị bên phải toán tử làm tham số.class BigInteger{    BigInteger operator + (BigInteger x)    {        return x;    }};Overload bên ngoài class, như một hàm của chương trình lớn. Khi đó ta cần cung cấp giá trị hai bên toán tử.class BigInteger{    //nội dung;};BigInteger operator + (BigInteger x, BigInteger y){    //nội dung;}Hãy để ý rằng các phép toán tử này cũng có kiểu dữ liệu trả về, giống như một chương trình con bình thường vậy - thực chất chúng cũng là chương trình con, nhưng được gọi bằng các toán tử thay vì bằng tên.Ta có thể overload tất cả các toán tử trong C++, trừ toán tử truy cập scope ::, toán tử truy cập yếu tố trong class ., toán tử điều kiện ?: và toán tử tham chiếu yếu tố của class .* (mà bạn chưa cần phải quan tâm ở đây).Subclass sẽ không được thừa hưởng các toán tử được overload của superclass.Phần sau: [C++ Cơ bản] Phần 25: Abstract class - Class trừu tượng</summary>
</entry>
<entry>
<title>[C++ Cơ bản] Phần 23: Tính thừa kế - Class con (subclass)</title>
<link href="http://localhost:4000/article/c-co-ban-phan-23-tinh-thua-ke-class-con-subclass" rel="alternate" type="text/html" title="[C++ Cơ bản] Phần 23: Tính thừa kế - Class con (subclass)" />
<published>2017-09-07T19:47:07+07:00</published>
<updated>2017-09-07T19:47:07+07:00</updated>
<id>http://localhost:4000/article/c-co-ban-phan-23-tinh-thua-ke-class-con-subclass</id>
<content type="html" xml:base="http://localhost:4000/article/c-co-ban-phan-23-tinh-thua-ke-class-con-subclass">&lt;p&gt;&lt;em&gt;Phần trước: &lt;a href=&quot;http://cowboycoder.tech/article/c-co-ban-phan-22-class-va-object&quot;&gt;[C++ Cơ bản] Phần 22: Class và Object&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Tính thừa kết giúp chúng ta tiết kiệm công sức viết code, bằng cách để cho các class con (subclass) thừa hưởng các tính chất của class cha (superclass). Trong bài viết này chúng ta sẽ tìm hiểu về cách triển khai tính thừa kế trong C++.&lt;/p&gt;

&lt;h1 id=&quot;định-nghĩa-subclass&quot;&gt;Định nghĩa subclass&lt;/h1&gt;

&lt;p&gt;Để định nghĩa subclass, ta sử dụng cú pháp&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class tên_class: kiểu_thừa_kế_1 tên_superclass_1, kiểu_thừa_kế_2 tên superclass_2,…
{
    nội dung;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Trong đó kiểu thừa kế có thể là &lt;code class=&quot;highlighter-rouge&quot;&gt;public&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;protected&lt;/code&gt;, hoặc &lt;code class=&quot;highlighter-rouge&quot;&gt;private&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Ví dụ: Chương trình sau có 2 class &lt;code class=&quot;highlighter-rouge&quot;&gt;Animal&lt;/code&gt; và &lt;code class=&quot;highlighter-rouge&quot;&gt;Cat&lt;/code&gt;, trong đó &lt;code class=&quot;highlighter-rouge&quot;&gt;Cat&lt;/code&gt; là subclass của &lt;code class=&quot;highlighter-rouge&quot;&gt;Animal&lt;/code&gt;, do đó &lt;code class=&quot;highlighter-rouge&quot;&gt;Cat&lt;/code&gt; thừa hưởng hai biến &lt;code class=&quot;highlighter-rouge&quot;&gt;type&lt;/code&gt; và &lt;code class=&quot;highlighter-rouge&quot;&gt;area&lt;/code&gt; của &lt;code class=&quot;highlighter-rouge&quot;&gt;Animal&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
#include &lt;iostream&gt;&lt;/iostream&gt;&lt;/p&gt;

&lt;p&gt;using namespace std;&lt;/p&gt;

&lt;p&gt;class Animal
{
    protected:
        string type, area;
};&lt;/p&gt;

&lt;p&gt;class Cat: public Animal
{
    private:
        string name;
        int age;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public:

    string getType()
    {
        return type;
    }

    void setType(string _type)
    {
        type = _type;
    } };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;int main()
{
    Cat cat;
    cat.setType(“Cat”);
    cout « cat.getType();
    return 0;
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Output&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Cat
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Sau khi định nghĩa subclass xong, ta lại có thể tiếp tục định nghĩa subclass của nó nữa. Ví dụ như class &lt;code class=&quot;highlighter-rouge&quot;&gt;MeoTamThe&lt;/code&gt; sau đây là subclass của &lt;code class=&quot;highlighter-rouge&quot;&gt;Cat&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
class MeoTamThe: public Cat
{
    public:
        string color[3];
};
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Một object khi thuộc về một class thì cũng sẽ thuộc về tất cả các superclass của class đó. Để dễ hình dung thì “Nếu đây là một con mèo, thì đây cũng là một con động vật”.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Animal cat = Cat();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/img/uploads/cpp-cơ-bản-22-1.jpg&quot; alt=&quot;undefined&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;quyền-truy-cập&quot;&gt;Quyền truy cập&lt;/h1&gt;

&lt;p&gt;Subclass có quyền truy cập tới tất cả các yếu tố &lt;code class=&quot;highlighter-rouge&quot;&gt;public&lt;/code&gt; và &lt;code class=&quot;highlighter-rouge&quot;&gt;protected&lt;/code&gt; của superclass.&lt;/p&gt;

&lt;h1 id=&quot;quyền-thừa-kế&quot;&gt;Quyền thừa kế&lt;/h1&gt;

&lt;p&gt;Quyền truy cập của các yếu tố mà subclass được thừa kế sẽ phụ thuộc vào kiểu thừa kế của subclass đối với superclass.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Nếu kiểu thừa kế là &lt;code class=&quot;highlighter-rouge&quot;&gt;public&lt;/code&gt;, tất cả các yếu tố &lt;code class=&quot;highlighter-rouge&quot;&gt;public&lt;/code&gt; và &lt;code class=&quot;highlighter-rouge&quot;&gt;protected&lt;/code&gt; của superclass sẽ giữ nguyên quyền truy cập khi thừa kế xuống subclass.&lt;/li&gt;
  &lt;li&gt;Nếu kiểu thừa kế là &lt;code class=&quot;highlighter-rouge&quot;&gt;protected&lt;/code&gt;, tất cả các yếu tố &lt;code class=&quot;highlighter-rouge&quot;&gt;public&lt;/code&gt; và &lt;code class=&quot;highlighter-rouge&quot;&gt;protected&lt;/code&gt; của superclass sẽ trở thành &lt;code class=&quot;highlighter-rouge&quot;&gt;protected&lt;/code&gt; của subclass.&lt;/li&gt;
  &lt;li&gt;Nếu kiểu thừa kế là &lt;code class=&quot;highlighter-rouge&quot;&gt;private&lt;/code&gt;, tất cả các yếu tố &lt;code class=&quot;highlighter-rouge&quot;&gt;public&lt;/code&gt; và &lt;code class=&quot;highlighter-rouge&quot;&gt;protected&lt;/code&gt; của superclass sẽ trở thành &lt;code class=&quot;highlighter-rouge&quot;&gt;private&lt;/code&gt; của subclass.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Kiểu thừa kế giống như là việc co gọn quyền truy cập khi xuống tới subclass vậy.&lt;/p&gt;

&lt;p&gt;Subclass sẽ không được thừa hưởng các yếu tố sau:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;constructor, destructor và copy constructor của superclass.&lt;/li&gt;
  &lt;li&gt;Các toán tử đã bị viết đè (overload) ở class cha. Ta sẽ nghiên cứu thêm về overload trong bài viết tiếp theo.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;thừa-kế-từ-nhiều-class&quot;&gt;Thừa kế từ nhiều class&lt;/h1&gt;

&lt;p&gt;Một class trong C++ có thể được thừa kế từ nhiều superclass, chỉ cần liệt kê danh sách các class thừa kế ở trong định nghĩa của nó.&lt;/p&gt;

&lt;p&gt;Ví dụ ở trong chương trình sau, class &lt;code class=&quot;highlighter-rouge&quot;&gt;MyClass&lt;/code&gt; được thừa kế từ hai class &lt;code class=&quot;highlighter-rouge&quot;&gt;SuperClassOne&lt;/code&gt; và &lt;code class=&quot;highlighter-rouge&quot;&gt;SuperClassTwo&lt;/code&gt;, nên có thể sử dụng được hai biến &lt;code class=&quot;highlighter-rouge&quot;&gt;intOne&lt;/code&gt; và &lt;code class=&quot;highlighter-rouge&quot;&gt;intTwo&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
#include &lt;iostream&gt;&lt;/iostream&gt;&lt;/p&gt;

&lt;p&gt;using namespace std;&lt;/p&gt;

&lt;p&gt;class SuperClassOne
{
    protected:
        int intOne;
};&lt;/p&gt;

&lt;p&gt;class SuperClassTwo
{
    protected:
        int intTwo;
};&lt;/p&gt;

&lt;p&gt;class MyClass: public SuperClassOne, public SuperClassTwo
{
    public:
        MyClass(int _intOne, int _intTwo)
        {
            intOne = _intOne;
            intTwo = _intTwo;
        }&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    int getSum()
    {
        return intOne + intTwo;
    } };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;int main()
{
    MyClass myObject = MyClass(1, 1);
    cout « myObject.getSum();
    return 0;
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Output&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Phần sau: &lt;a href=&quot;http://cowboycoder.tech/article/c-co-ban-phan-24-overload-viet-de-chuong-trinh-con-va-toan-tu&quot;&gt;[C++ Cơ bản] Phần 24: Overload - Viết đè chương trình con và toán tử&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

</content>
<author>
<name>Admin Tổng Quản</name>
</author>
<category term="cpp-cơ-bản" />
<category term="programming" />
<summary>Phần trước: [C++ Cơ bản] Phần 22: Class và ObjectTính thừa kết giúp chúng ta tiết kiệm công sức viết code, bằng cách để cho các class con (subclass) thừa hưởng các tính chất của class cha (superclass). Trong bài viết này chúng ta sẽ tìm hiểu về cách triển khai tính thừa kế trong C++.Định nghĩa subclassĐể định nghĩa subclass, ta sử dụng cú phápclass tên_class: kiểu_thừa_kế_1 tên_superclass_1, kiểu_thừa_kế_2 tên superclass_2,…{    nội dung;}Trong đó kiểu thừa kế có thể là public, protected, hoặc private.Ví dụ: Chương trình sau có 2 class Animal và Cat, trong đó Cat là subclass của Animal, do đó Cat thừa hưởng hai biến type và area của Animal.#include &amp;lt;iostream&amp;gt;using namespace std;class Animal{    protected:        string type, area;};class Cat: public Animal{    private:        string name;        int age;    public:        string getType()        {            return type;        }        void setType(string _type)        {            type = _type;        }};int main(){    Cat cat;    cat.setType(&quot;Cat&quot;);    cout &amp;lt;&amp;lt; cat.getType();    return 0;}OutputCatSau khi định nghĩa subclass xong, ta lại có thể tiếp tục định nghĩa subclass của nó nữa. Ví dụ như class MeoTamThe sau đây là subclass của Cat.class MeoTamThe: public Cat{    public:        string color[3];};Một object khi thuộc về một class thì cũng sẽ thuộc về tất cả các superclass của class đó. Để dễ hình dung thì “Nếu đây là một con mèo, thì đây cũng là một con động vật”.Animal cat = Cat();Quyền truy cậpSubclass có quyền truy cập tới tất cả các yếu tố public và protected của superclass.Quyền thừa kếQuyền truy cập của các yếu tố mà subclass được thừa kế sẽ phụ thuộc vào kiểu thừa kế của subclass đối với superclass.  Nếu kiểu thừa kế là public, tất cả các yếu tố public và protected của superclass sẽ giữ nguyên quyền truy cập khi thừa kế xuống subclass.  Nếu kiểu thừa kế là protected, tất cả các yếu tố public và protected của superclass sẽ trở thành protected của subclass.  Nếu kiểu thừa kế là private, tất cả các yếu tố public và protected của superclass sẽ trở thành private của subclass.Kiểu thừa kế giống như là việc co gọn quyền truy cập khi xuống tới subclass vậy.Subclass sẽ không được thừa hưởng các yếu tố sau:  constructor, destructor và copy constructor của superclass.  Các toán tử đã bị viết đè (overload) ở class cha. Ta sẽ nghiên cứu thêm về overload trong bài viết tiếp theo.Thừa kế từ nhiều classMột class trong C++ có thể được thừa kế từ nhiều superclass, chỉ cần liệt kê danh sách các class thừa kế ở trong định nghĩa của nó.Ví dụ ở trong chương trình sau, class MyClass được thừa kế từ hai class SuperClassOne và SuperClassTwo, nên có thể sử dụng được hai biến intOne và intTwo.#include &amp;lt;iostream&amp;gt;using namespace std;class SuperClassOne{    protected:        int intOne;};class SuperClassTwo{    protected:        int intTwo;};class MyClass: public SuperClassOne, public SuperClassTwo{    public:        MyClass(int _intOne, int _intTwo)        {            intOne = _intOne;            intTwo = _intTwo;        }        int getSum()        {            return intOne + intTwo;        }};int main(){    MyClass myObject = MyClass(1, 1);    cout &amp;lt;&amp;lt; myObject.getSum();    return 0;}Output2Phần sau: [C++ Cơ bản] Phần 24: Overload - Viết đè chương trình con và toán tử</summary>
</entry>
</feed>
